/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/login': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Login Email */
    post: operations['login_email_login_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/login/api_key': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Login Api Key */
    post: operations['login_api_key_login_api_key_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/login/social': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Login Social */
    post: operations['login_social_login_social_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/logout': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Logout */
    post: operations['logout_logout_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/current_user': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Current User */
    get: operations['current_user_current_user_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/presigned_url': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Presigned Url */
    get: operations['get_presigned_url_presigned_url_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verify_email': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify Email */
    post: operations['verify_email_verify_email_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Token */
    get: operations['get_token_token_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/changelog': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Current Changelog */
    get: operations['get_current_changelog_changelog_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/healthcheck': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Healthcheck */
    get: operations['healthcheck_healthcheck_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/{training_or_inference}/validate_dataset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate Dataset
     * @description Validate a dataset for training.
     */
    post: operations['validate_dataset_projects__project_id___training_or_inference__validate_dataset_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/{training_mode}/start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start Training Job
     * @description Start training.
     */
    post: operations['start_training_job_projects__project_id___training_mode__start_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/training/{training_job_id}/status/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Training Status
     * @description Get the status for a training job.
     */
    get: operations['training_status_projects__project_id__training__training_job_id__status__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/training/{training_job_id}/token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Token For Training Job
     * @description Get the status for a training job.
     */
    post: operations['get_token_for_training_job_training__training_job_id__token_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/user_roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get User Roles
     * @description Get all user roles.
     */
    get: operations['get_user_roles_user_roles_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/request_access': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request Access
     * @description Endpoint for a user to request access to the console.
     *
     *     This is often the first step for a user to sign up for the console. The user record is created with
     *     `email_is_verified=None`, which signifies that the user has requested access but hasn't been invited yet.
     */
    post: operations['request_access_request_access_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/signup_link': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate Signup Link
     * @description Generate a signup link for a new user.
     *
     *     This endpoint is used by admins in the console Command Center.
     *     We create an unverified user entry and send a signup email to the new user.
     *
     *     The user is then verified via one of the following endpoints:
     *     - POST /users
     *     - POST /users/social
     */
    post: operations['generate_signup_link_signup_link_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/invite_users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Invite Users */
    post: operations['invite_users_invite_users_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Users */
    get: operations['list_users_users_get'];
    put?: never;
    /**
     * Create Or Verify User
     * @description Create a new user with an email and password.
     *
     *     If no admin exists (first user), the user will be created as an admin.
     *
     *     Otherwise:
     *     - User record was already created when the admin invited the user
     *     - We should verify the user's email
     */
    post: operations['create_or_verify_user_users_post'];
    /** Delete User Self */
    delete: operations['delete_user_self_users_delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/social': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create Or Verify User Social
     * @description Create a user using a social login provider.
     *
     *     All social users are created with `email_is_verified=True`, don't need to be invited and are by default read-only
     *     (unless they are the first user, in which case they are set to admin).
     */
    post: operations['create_or_verify_user_social_users_social_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/all': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List All Users
     * @deprecated
     * @description List all users in the system.
     *
     *     This endpoint is optimized to count project and runs for each user. This endpoint must be placed before
     *     `/users/{user_id}` so that "all" is not interpreted as a UUID4.
     */
    get: operations['list_all_users_users_all_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/{user_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get User */
    get: operations['get_user_users__user_id__get'];
    /** Update User */
    put: operations['update_user_users__user_id__put'];
    post?: never;
    /** Delete User */
    delete: operations['delete_user_users__user_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/{user_id}/runs/latest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Latest User Run
     * @description Gets the most recent run for a User, ordered by last updated.
     */
    get: operations['get_latest_user_run_users__user_id__runs_latest_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/{user_id}/runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Runs For User
     * @description Get all user created runs across all projects they can access.
     *
     *     This returns a filtered list of projects with only runs created by this user.
     */
    get: operations['get_project_runs_for_user_users__user_id__runs_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generate_password_reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Generate Password Reset Link */
    get: operations['generate_password_reset_link_generate_password_reset_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generate_password_reset_email': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Generate Password Reset Email */
    get: operations['generate_password_reset_email_generate_password_reset_email_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/password_reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Password Reset
     * @description Reset a user's password.
     *
     *     A password reset with a valid token should always verify the user. (See default of
     *     UserPasswordResetRequest.email_is_verified is True)
     */
    post: operations['password_reset_password_reset_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/{user_id}/transfer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer User Data
     * @description Transfers all projects, runs, and edits created by a user to another user.
     */
    post: operations['transfer_user_data_users__user_id__transfer_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/current_user/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Current User Groups */
    get: operations['list_current_user_groups_current_user_groups_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/{user_id}/api_keys': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Api Keys */
    get: operations['get_api_keys_users__user_id__api_keys_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/api_keys': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create Api Key */
    post: operations['create_api_key_users_api_keys_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/users/api_keys/{api_key_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Delete Api Key */
    delete: operations['delete_api_key_users_api_keys__api_key_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/prompt_datasets': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Prompt Datasets
     * @deprecated
     */
    get: operations['list_prompt_datasets_projects__project_id__prompt_datasets_get'];
    put?: never;
    /**
     * Upload Prompt Evaluation Dataset
     * @deprecated
     */
    post: operations['upload_prompt_evaluation_dataset_projects__project_id__prompt_datasets_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Datasets */
    get: operations['list_datasets_datasets_get'];
    put?: never;
    /** Upload Dataset */
    post: operations['upload_dataset_datasets_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Dataset */
    get: operations['get_dataset_datasets__dataset_id__get'];
    put?: never;
    post?: never;
    /** Delete Dataset */
    delete: operations['delete_dataset_datasets__dataset_id__delete'];
    options?: never;
    head?: never;
    /** Update Dataset */
    patch: operations['update_dataset_datasets__dataset_id__patch'];
    trace?: never;
  };
  '/datasets/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Datasets */
    post: operations['query_datasets_datasets_query_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/prompt_datasets/{dataset_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Download Prompt Dataset
     * @deprecated
     */
    get: operations['download_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__get'];
    /**
     * Update Prompt Dataset
     * @deprecated
     */
    put: operations['update_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__put'];
    post?: never;
    /**
     * Delete Prompt Dataset
     * @deprecated
     */
    delete: operations['delete_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/content': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Dataset Content */
    get: operations['get_dataset_content_datasets__dataset_id__content_get'];
    /**
     * Rollback Dataset Content
     * @description Rollback the content of a dataset to a previous version.
     */
    put: operations['rollback_dataset_content_datasets__dataset_id__content_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update Dataset Content
     * @description Update the content of a dataset.
     *
     *     The `index` and `column_name` fields are treated as keys tied to a specific version of the dataset.
     *     As such, these values are considered immutable identifiers for the dataset's structure.
     *
     *     For example, if an edit operation changes the name of a column, subsequent edit operations in
     *     the same request should reference the column using its original name.
     *
     *     The `If-Match` header is used to ensure that updates are only applied if the client's version of the dataset
     *     matches the server's version. This prevents conflicts from simultaneous updates. The `ETag` header in the response
     *     provides the new version identifier after a successful update.
     */
    patch: operations['update_dataset_content_datasets__dataset_id__content_patch'];
    trace?: never;
  };
  '/datasets/{dataset_id}/download': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Download Dataset */
    get: operations['download_dataset_datasets__dataset_id__download_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/content/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Dataset Content */
    post: operations['query_dataset_content_datasets__dataset_id__content_query_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List User Dataset Collaborators
     * @description List the users with which the dataset has been shared.
     */
    get: operations['list_user_dataset_collaborators_datasets__dataset_id__users_get'];
    put?: never;
    /** Create User Dataset Collaborators */
    post: operations['create_user_dataset_collaborators_datasets__dataset_id__users_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Group Dataset Collaborators
     * @description List the groups with which the dataset has been shared.
     */
    get: operations['list_group_dataset_collaborators_datasets__dataset_id__groups_get'];
    put?: never;
    /**
     * Create Group Dataset Collaborators
     * @description Share a dataset with groups.
     */
    post: operations['create_group_dataset_collaborators_datasets__dataset_id__groups_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/users/{user_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete User Dataset Collaborator
     * @description Remove a user's access to a dataset.
     */
    delete: operations['delete_user_dataset_collaborator_datasets__dataset_id__users__user_id__delete'];
    options?: never;
    head?: never;
    /**
     * Update User Dataset Collaborator
     * @description Update the sharing permissions of a user on a dataset.
     */
    patch: operations['update_user_dataset_collaborator_datasets__dataset_id__users__user_id__patch'];
    trace?: never;
  };
  '/datasets/{dataset_id}/groups/{group_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete Group Dataset Collaborator
     * @description Remove a group's access to a dataset.
     */
    delete: operations['delete_group_dataset_collaborator_datasets__dataset_id__groups__group_id__delete'];
    options?: never;
    head?: never;
    /**
     * Update Group Dataset Collaborator
     * @description Update the sharing permissions of a group on a dataset.
     */
    patch: operations['update_group_dataset_collaborator_datasets__dataset_id__groups__group_id__patch'];
    trace?: never;
  };
  '/datasets/{dataset_id}/versions/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Dataset Versions */
    post: operations['query_dataset_versions_datasets__dataset_id__versions_query_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/versions/{version_index}/content': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Dataset Version Content */
    get: operations['get_dataset_version_content_datasets__dataset_id__versions__version_index__content_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/datasets/{dataset_id}/versions/{version_index}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** Update Dataset Version */
    patch: operations['update_dataset_version_datasets__dataset_id__versions__version_index__patch'];
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/edits': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Run Edits
     * @description Gets all edits in a project/run/split.
     *
     *     :param project_id: project_id :param run_id: run_id :param split: split :param include_exported: Whether to also
     *     query exported (past) edits. Default True. If True, return will include historical edits that have already been
     *     exported
     */
    get: operations['get_run_edits_projects__project_id__runs__run_id__split__split__edits_get'];
    put?: never;
    /**
     * Create Edit
     * @description Creates a Edit.
     *
     *     If setting sample_ids, the IDs must exist in the project/run/split. If setting filter, use the same filter params as
     *     used in /insights/summary
     *
     *     **Cannot set both sample_ids and filter, must use only one.**
     *
     *     If in a run type that has tasks (see multi-label runs) you must set a task as part of the body.
     */
    post: operations['create_edit_projects__project_id__runs__run_id__split__split__edits_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/edits/exports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Edits Exports
     * @description Gets all exported edits from a project/run/split.
     *
     *     Returns the id, edit_id, time of export, and user id that made the export
     */
    get: operations['get_edits_exports_projects__project_id__runs__run_id__split__split__edits_exports_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/edits/{edit_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Edit
     * @description Gets an edit.
     */
    get: operations['get_edit_edits__edit_id__get'];
    put?: never;
    post?: never;
    /** Delete Edit */
    delete: operations['delete_edit_edits__edit_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/edits/{edit_id}/content': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Edit Content
     * @description Gets the data for an edit, including the text, predicted label and true label.
     */
    get: operations['get_edit_content_edits__edit_id__content_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/edits/content': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Edit Contents For Run
     * @description Gets the data for all edits in a run.
     *
     *     Equivalent logic to /edits/edit_id/content except for all edits in a run
     */
    get: operations['get_edit_contents_for_run_projects__project_id__runs__run_id__split__split__edits_content_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/edits/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export Edits
     * @description Exports the resulting dataframe after a series of edits.
     *
     *     If overrides are provided, and the original edit had a task, the override MUST explicitly have a task set (typically
     *     the same task as the edit)
     */
    post: operations['export_edits_edits_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/edits/export/remote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export Edits Remote
     * @description Exports the resulting dataframe after a series of edits to a remote object store.
     *
     *     Note that the file type is determined by the suffix of the object name. Must be one of csv, parquet, json, arrow
     *
     *     If overrides are provided, and the original edit had a task, the override MUST explicitly have a task set (typically
     *     the same task as the edit)
     */
    post: operations['export_edits_remote_edits_export_remote_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/edits/labels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get New Labels For Run Edits
     * @description Returns any newly created labels for the edits within a run/split.
     *
     *     Newly created labels are those that were created via the `create_new_label` action
     */
    get: operations['get_new_labels_for_run_edits_projects__project_id__runs__run_id__split__split__edits_labels_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/edits/{edit_id}/review': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add Review For Edit
     * @description Add a review for an edit.
     *
     *     Must have access to the run with which the edit exists in. Users CAN review their own edits (as per ticket
     *     instructions)
     */
    post: operations['add_review_for_edit_edits__edit_id__review_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/embeddings/available': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Has Embeddings
     * @description Returns whether or not model embeddings are available for this run/split.
     */
    get: operations['has_embeddings_projects__project_id__runs__run_id__split__split__embeddings_available_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/embeddings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Embeddings
     * @description Get all embedding data for 500k (or otherwise requested) data points.
     *
     *     This will take a random sample of the dataset. It exports the result as a csv
     *     in order to reduce request size and response latency (as results can be large)
     *     This will return:
     *     * id
     *     * gold (index)
     *     * prediction (index)
     *     * data quality
     *     * text_sample
     *     * x coordinate
     *     * y coordinate
     *     ** any metadata columns explicitly requested
     *
     *     Set data_view=true to return data embeddings instead of model embeddings. If
     *     data embeddings are not available, an exception will be thrown
     *
     *     Set use_seed=false for random batches of embeddings on every response. This is
     *     useful for batching, but should remain true if you are requesting a single set
     *     of embeddings. If you are returning all embeddings, this parameter is useless
     */
    post: operations['get_embeddings_projects__project_id__runs__run_id__split__split__embeddings_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/embeddings/point': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Point Embeddings
     * @description Get all data (including text) for requested embedding points.
     *
     *     Select either via point IDs, or by selecting a Circle around them (providing
     *     an x, y, and radius (eg "circle": {"x": 0.1, "y": 0.2, "radius": 0.5}).
     *
     *     Only points or a circle are allowed, not both. Max 15 points per request.
     *     This will return:
     *     * id
     *     * gold (string) (for non inference)
     *     * prediction (string)
     *     * dep (for non inference)
     *     * confidence
     *     * text_sample
     *     * x coordinate
     *     * y coordinate
     *
     *     Set data_view=true to return data embeddings instead of model embeddings. If
     *     data embeddings are not available, an error will be thrown
     */
    post: operations['get_point_embeddings_projects__project_id__runs__run_id__split__split__embeddings_point_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/alerts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Evaluate Alerts */
    get: operations['list_evaluate_alerts_projects__project_id__runs__run_id__prompts_alerts_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/insights/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get Metric Insights With Filters */
    post: operations['get_metric_insights_with_filters_projects__project_id__runs__run_id__prompts_insights_metrics_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/evaluate/runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create Workflows Run
     * @description Create a new Evaluate run with workflows.
     *
     *     Use this endpoint to create a new Evaluate run with workflows. The request body should contain the `workflows` to be ingested and evaluated.
     *
     *     Additionally, specify the `project_id` or `project_name` to which the workflows should be ingested. If the project does not exist, it will be created. If the project exists, the workflows will be logged to it. If both `project_id` and `project_name` are provided, `project_id` will take precedence. The `run_name` is optional and will be auto-generated (timestamp-based) if not provided.
     *
     *     The body is also expected to include the configuration for the scorers to be used in the evaluation. This configuration will be used to evaluate the workflows and generate the results.
     */
    post: operations['create_workflows_run_evaluate_runs_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/evaluate/run-workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Evaluate Run Results
     * @description Fetch evaluation results for a specific run including rows and aggregate information.
     */
    post: operations['get_evaluate_run_results_evaluate_run_workflows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/experiments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Experiments
     * @description Retrieve all experiments for a project.
     */
    get: operations['list_experiments_projects__project_id__experiments_get'];
    put?: never;
    /**
     * Create Experiment
     * @description Create a new experiment for a project.
     */
    post: operations['create_experiment_projects__project_id__experiments_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/experiments/{experiment_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Experiment
     * @description Retrieve a specific experiment.
     */
    get: operations['get_experiment_projects__project_id__experiments__experiment_id__get'];
    /**
     * Update Experiment
     * @description Update a specific experiment.
     */
    put: operations['update_experiment_projects__project_id__experiments__experiment_id__put'];
    post?: never;
    /**
     * Delete Experiment
     * @description Delete a specific experiment.
     */
    delete: operations['delete_experiment_projects__project_id__experiments__experiment_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Export Data */
    post: operations['export_data_projects__project_id__runs__run_id__split__split__export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/export/remote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Export Data Remote */
    post: operations['export_data_remote_projects__project_id__runs__run_id__split__split__export_remote_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/features/columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Feature Columns
     * @description Lists the names of the features for a given project_id/run_id.
     *
     *     This endpoint is for tabular data only.
     */
    get: operations['list_feature_columns_projects__project_id__runs__run_id__features_columns_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/feedback/templates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Feedback Templates */
    get: operations['list_feedback_templates_projects__project_id__feedback_templates_get'];
    put?: never;
    /** Create Feedback Template */
    post: operations['create_feedback_template_projects__project_id__feedback_templates_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/feedback/templates/{template_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Feedback Template */
    get: operations['get_feedback_template_projects__project_id__feedback_templates__template_id__get'];
    put?: never;
    post?: never;
    /** Delete Feedback Template */
    delete: operations['delete_feedback_template_projects__project_id__feedback_templates__template_id__delete'];
    options?: never;
    head?: never;
    /** Update Feedback Template */
    patch: operations['update_feedback_template_projects__project_id__feedback_templates__template_id__patch'];
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/feedback/templates/{template_id}/index/{index}/rating': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Feedback Rating */
    get: operations['get_feedback_rating_projects__project_id__runs__run_id__feedback_templates__template_id__index__index__rating_get'];
    /**
     * Create Feedback Rating
     * @description Record a feedack rating for a specific sample in a run. For prompt chains, the index must be the root node.
     */
    put: operations['create_feedback_rating_projects__project_id__runs__run_id__feedback_templates__template_id__index__index__rating_put'];
    post?: never;
    /** Delete Feedback Rating */
    delete: operations['delete_feedback_rating_projects__project_id__runs__run_id__feedback_templates__template_id__index__index__rating_delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/ratings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Apply Bulk Feedback
     * @description Record multiple feedback ratings
     */
    post: operations['apply_bulk_feedback_projects__project_id__runs__run_id__ratings_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/feedback/templates/{template_id}/nodes/{node_id}/rating': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Feedback Rating Observe */
    get: operations['get_feedback_rating_observe_projects__project_id__feedback_templates__template_id__nodes__node_id__rating_get'];
    /**
     * Create Feedback Rating Observe
     * @description Record a feedack rating for a specific sample in a run. For prompt chains, the index must be the root node.
     */
    put: operations['create_feedback_rating_observe_projects__project_id__feedback_templates__template_id__nodes__node_id__rating_put'];
    post?: never;
    /** Delete Feedback Rating Observe */
    delete: operations['delete_feedback_rating_observe_projects__project_id__feedback_templates__template_id__nodes__node_id__rating_delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generated-scorers/generate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Generate */
    post: operations['generate_generated_scorers_generate_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generated-scorers/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Validate */
    post: operations['validate_generated_scorers_validate_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generated-scorers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get All */
    get: operations['get_all_generated_scorers_get'];
    put?: never;
    /** Create */
    post: operations['create_generated_scorers_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generated-scorers/task-results/{task_result_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Task Result */
    get: operations['get_task_result_generated_scorers_task_results__task_result_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/generated-scorers/{generated_scorer_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get */
    get: operations['get_generated_scorers__generated_scorer_id__get'];
    put?: never;
    post?: never;
    /** Delete */
    delete: operations['delete_generated_scorers__generated_scorer_id__delete'];
    options?: never;
    head?: never;
    /** Update */
    patch: operations['update_generated_scorers__generated_scorer_id__patch'];
    trace?: never;
  };
  '/group_roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Group Roles */
    get: operations['get_group_roles_group_roles_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Groups */
    get: operations['list_groups_groups_get'];
    put?: never;
    /** Create Group */
    post: operations['create_group_groups_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/groups/{group_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Group */
    get: operations['get_group_groups__group_id__get'];
    put?: never;
    post?: never;
    /** Delete Group */
    delete: operations['delete_group_groups__group_id__delete'];
    options?: never;
    head?: never;
    /** Update Group */
    patch: operations['update_group_groups__group_id__patch'];
    trace?: never;
  };
  '/groups/{group_id}/members': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Group Members */
    get: operations['list_group_members_groups__group_id__members_get'];
    put?: never;
    /** Add User To Group */
    post: operations['add_user_to_group_groups__group_id__members_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/groups/{group_id}/members/{user_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Delete Group Member */
    delete: operations['delete_group_member_groups__group_id__members__user_id__delete'];
    options?: never;
    head?: never;
    /** Update Group Member */
    patch: operations['update_group_member_groups__group_id__members__user_id__patch'];
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/summary': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Summary Statistics
     * @description Populates the core components of the Galileo Console.
     *
     *     Calculate summary statistics, data rows, hard/easy thresholds, DEP distribution for
     *      the cohort, and applies any filters requested.
     *
     *     Args:
     *         project_id
     *         run_id
     *         split
     *         current_user (User, optional): The current user making the HTTP request.
     *             Defaults to Depends(authentication_service.current_user).
     *         inference_name (bool, default ""): Optional inference name. Required if split
     *             is inference
     *         summary_request (SummaryRequest, optional): See SummaryRequest.
     *
     *     Returns:
     *         SplitRunResults
     */
    post: operations['get_summary_statistics_projects__project_id__runs__run_id__split__split__insights_summary_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/groupby': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Groupby Statistics
     * @description Calculates statistics for a particular categorical groupby column.
     *
     *     Calculates f1, precision, recall, DEP (if applicable), confidence (if applicable),
     *     and count, for each group in the groupby column.
     *
     *     Args:
     *         project_id
     *         run_id
     *         split
     *         groupby_col: Required query param. The column to calculate statistics on
     *         current_user (User, optional): The current user making the HTTP request.
     *             Defaults to Depends(authentication_service.current_user).
     *         inference_name (bool, default ""): Optional inference name. Required if split
     *             is inference
     *         groupby_request (ContentRequest, optional): See ContentRequest. Optional filters
     *         for the request
     *
     *     Returns:
     *         GroupByMetrics
     */
    post: operations['get_groupby_statistics_projects__project_id__runs__run_id__split__split__insights_groupby_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/ids': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Insight Ids
     * @description Gets ids from a given filter.
     *
     *     Request params should match the /summary request
     *
     *     Returns:
     *         List[int]
     */
    post: operations['get_insight_ids_projects__project_id__runs__run_id__split__split__insights_ids_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/percentage/sample': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Percentage
     * @description Gets the percentage of the current filter against the original dataframe.
     *
     *     Use this route if you just need a percentage without calculating all summary stats
     */
    post: operations['get_percentage_projects__project_id__runs__run_id__split__split__insights_percentage_sample_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/thresholds': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Thresholds
     * @description Gets the DEP score hard/easy thresholds for a project/run/split.
     *
     *     If in a multi-label model, you must provide a task
     */
    post: operations['get_thresholds_projects__project_id__runs__run_id__split__split__insights_thresholds_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/split/{split}/insights/compare': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compare Runs
     * @description Gets overall statistics for multiple runs as well as slice statistics.
     */
    post: operations['compare_runs_projects__project_id__split__split__insights_compare_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/distribution': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Column Distribution
     * @description Calculates density distribution / histogram for a numeric column.
     *
     *     Args:
     *         project_id
     *         run_id
     *         split
     *         inference_name (bool, default ""): Optional inference name. Required if split
     *             is inference
     *         current_user (User, optional): The current user making the HTTP request.
     *             Defaults to Depends(authentication_service.current_user).
     *
     *         distribution_request (DistributionRequest):
     *         In request body:
     *         col: Required. The column to calculate distribution on
     *         nbins: Number of bins for the distribution. Default 20
     *         limit_min: Minimum value for the limit of the dist. Default to min of column
     *         limit_max: Maximum value for the limit of the dist. Default to min of column
     *         Inherits from ContentRequest.
     *             - Optional filters for the request
     *
     *     Returns:
     *         Distribution
     */
    post: operations['get_column_distribution_projects__project_id__runs__run_id__split__split__insights_distribution_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Model Metrics
     * @description Calculates f1, precision, and recall for a run/split given a set of filters.
     *
     *     :param macro: Whether to macro average or weighted average metrics.     Default False (weighted) :param
     *     metrics_request: Filters to pass in before calculating metrics
     */
    post: operations['get_model_metrics_projects__project_id__runs__run_id__split__split__insights_metrics_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/metrics/tasks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Task Metrics
     * @description [MLTC ONLY] This route calculates the overall F1 score per task.
     */
    post: operations['get_task_metrics_projects__project_id__runs__run_id__split__split__insights_metrics_tasks_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/co_occurrence': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Label Co Occurrence
     * @description [MLTC ONLY] This route calculates label co-occurrence across tasks.
     */
    post: operations['get_label_co_occurrence_projects__project_id__runs__run_id__split__split__insights_co_occurrence_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/similar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Similar From Split
     * @description Gets similar samples from another split.
     *
     *     Given a set of samples from a dataframe from split {split}, find the most similar samples from split {from_split}
     *     and return those IDs
     */
    post: operations['get_similar_from_split_projects__project_id__runs__run_id__split__split__insights_similar_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/cbo_clusters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Cbo Clusters For Split
     * @deprecated
     * @description Returns the list of available CBO (class boundary overlap) clusters for the.
     *
     *     dataframe given some (or no) filters.
     *
     *     The clusters are returned as a list of CBOCluster in order of num_samples descending
     */
    post: operations['get_cbo_clusters_for_split_projects__project_id__runs__run_id__split__split__insights_cbo_clusters_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/cartograph_clusters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Cartograph Clusters For Split
     * @description Get information about the Cartograph clusters found for a split.
     */
    post: operations['get_cartograph_clusters_for_split_projects__project_id__runs__run_id__split__split__insights_cartograph_clusters_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/communities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Communities For Split
     * @description Returns the list of available Communities (class confusions)
     */
    post: operations['get_communities_for_split_projects__project_id__runs__run_id__split__split__insights_communities_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/top': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Top Insights
     * @description Returns the list of top insights for UI to consume.
     *
     *     Dataframe given some (or no) filters.
     *
     *     The insights returned are:
     *     - top erroneous words (NER)
     *     - top misclassified pairs
     *     - top correlation pairs (tabular data)
     */
    post: operations['get_top_insights_projects__project_id__runs__run_id__split__split__insights_top_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/charts/correlation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Correlation Matrix Chart
     * @description Fetches data to populate a chart on the UI.
     *
     *     Dataframe given some (or no) filters.
     *
     *     Available charts are:
     *     - correlation matrix (tabular data)
     *     - feature pairwise accuracy matrix (tabular data), to come...
     */
    post: operations['get_correlation_matrix_chart_projects__project_id__runs__run_id__split__split__insights_charts_correlation_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/alerts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Alerts For Run
     * @description Gets alerts for project/run/split.
     *
     *     Optionally gets dismissed cards as well
     */
    get: operations['get_alerts_for_run_projects__project_id__runs__run_id__split__split__insights_alerts_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/alerts/{alert_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Dismiss Alert
     * @description Marks an alert as dismissed. Dismissed alerts wont be queries by the GET.
     *
     *     This is the new name for xray. After some deprecation time we will rename everything
     */
    delete: operations['dismiss_alert_projects__project_id__runs__run_id__split__split__insights_alerts__alert_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/errors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Errors
     * @description Get the available errors for a run (if any)
     */
    get: operations['get_errors_projects__project_id__runs__run_id__split__split__insights_errors_get'];
    put?: never;
    /**
     * Get Error Counts
     * @description Returns the counts of errors, per error type.
     *
     *     Currently NER and OD support
     */
    post: operations['get_error_counts_projects__project_id__runs__run_id__split__split__insights_errors_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/map': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Map For Run
     * @description [OD ONLY] Calculates mean Average Precision for the (potentially filtered) df.
     *
     *     Also includes the errors and their scores for the insights chart. The
     *     `map_threshold` defaults to 0.5, but can be changed in the ContentRequest
     */
    post: operations['get_map_for_run_projects__project_id__runs__run_id__split__split__insights_map_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/semseg/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Segmentation Metrics For Run
     * @description [Sem Seg ONLY] Calculates mean and boundary IoU for the (filtered) df.
     */
    post: operations['get_segmentation_metrics_for_run_projects__project_id__runs__run_id__split__split__insights_semseg_metrics_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/seq2seq/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Seq2Seq Metrics For Run
     * @description [Seq2Seq ONLY] Calculates bleu, rouge, and DEP for the (filtered) df.
     */
    post: operations['get_seq2seq_metrics_for_run_projects__project_id__runs__run_id__split__split__insights_seq2seq_metrics_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/rows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Data Rows
     * @description Returns rows of data for the run/split with optional filters applied.
     *
     *     Also responds if there is a next page available (more rows)
     *     [MLTC] - A task must be provided
     *     [OD] - A default map_threshold is provided at 0.5. This can be changed in the body
     *         of the request, and will result in different error values for each returned row
     */
    post: operations['get_data_rows_projects__project_id__runs__run_id__split__split__insights_rows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/insights/errors/{error_name}/distribution': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Error Distribution For Column
     * @description Returns the breakdown of a given error per unique column.
     */
    post: operations['get_error_distribution_for_column_projects__project_id__runs__run_id__split__split__insights_errors__error_name__distribution_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Integrations
     * @description List the created integrations for the requesting user.
     */
    get: operations['list_integrations_integrations_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/available': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Available Integrations
     * @description List all of the available integrations to be created in Galileo.
     */
    get: operations['list_available_integrations_integrations_available_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Integration
     * @description Gets the integration data formatted for the specified integration.
     */
    get: operations['get_integration_integrations__name__get'];
    put?: never;
    post?: never;
    /**
     * Delete Integration
     * @description Delete the integration created by this user.
     */
    delete: operations['delete_integration_integrations__name__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/{name}/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Integration Status
     * @description Checks if the integration status is active or not.
     */
    get: operations['get_integration_status_integrations__name__status_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/anthropic': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update an Anthropic integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_anthropic_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/aws_bedrock': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update an AWS integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_aws_bedrock_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/aws_sagemaker': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update an AWS integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_aws_sagemaker_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/azure': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update an Azure integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_azure_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/unity-catalog/sql': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Unity Catalog Integration
     * @deprecated
     * @description Create or update a databricks integration for this user from Galileo.
     */
    put: operations['create_or_update_unity_catalog_integration_integrations_databricks_unity_catalog_sql_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Unity Catalog Integration
     * @description Create or update a databricks integration for this user from Galileo.
     */
    put: operations['create_or_update_unity_catalog_integration_integrations_databricks_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/catalogs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Databricks Catalogs */
    get: operations['get_databricks_catalogs_integrations_databricks_catalogs_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/databases': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Databases For Cluster */
    get: operations['get_databases_for_cluster_integrations_databricks_databases_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Export To Databricks */
    post: operations['export_to_databricks_integrations_databricks_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/edits/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export Edits Databricks
     * @description Exports the resulting dataframe after a series of edits to databricks delta lake.
     *
     *     If overrides are provided, and the original edit had a task, the override MUST explicitly have a task set (typically
     *     the same task as the edit)
     */
    post: operations['export_edits_databricks_integrations_databricks_edits_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/unity-catalog/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Export To Databricks Unity Catalog */
    post: operations['export_to_databricks_unity_catalog_integrations_databricks_unity_catalog_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/databricks/unity-catalog/edits/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Export Edits Databricks Unity Catalog */
    post: operations['export_edits_databricks_unity_catalog_integrations_databricks_unity_catalog_edits_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/labelstudio': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update a labelstudio integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_labelstudio_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/labelstudio/projects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Labelstudio Projects */
    get: operations['get_labelstudio_projects_integrations_labelstudio_projects_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/labelstudio/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Export To Labelstudio */
    post: operations['export_to_labelstudio_integrations_labelstudio_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/mistral': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update an Mistral integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_mistral_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/openai': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update an OpenAI integration for this user from Galileo.
     */
    put: operations['create_or_update_integration_integrations_openai_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/vertex_ai': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update a Google Vertex AI integration for a user.
     */
    put: operations['create_or_update_integration_integrations_vertex_ai_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/integrations/writer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create Or Update Integration
     * @description Create or update a Writer integration for a user.
     */
    put: operations['create_or_update_integration_integrations_writer_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/jobs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create Job */
    post: operations['create_job_jobs_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/jobs/{job_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Job
     * @description Get a job by id.
     */
    get: operations['get_job_jobs__job_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/jobs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Jobs For Project Run
     * @description Get all jobs by for a project and run.
     *
     *     Returns them in order of creation from newest to oldest.
     */
    get: operations['get_jobs_for_project_run_projects__project_id__runs__run_id__jobs_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/jobs/latest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Latest Job For Project Run
     * @description Returns the most recently updated job for a run.
     */
    get: operations['get_latest_job_for_project_run_projects__project_id__runs__run_id__jobs_latest_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/llm_integrations/{llm_integration}/models': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Available Models
     * @description Get the list of supported models for the LLM integration.
     */
    get: operations['get_available_models_llm_integrations__llm_integration__models_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/llm_integrations/{llm_integration}/scorer_models': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Available Scorer Models
     * @description Get the list of supported scorer models for the LLM integration.
     */
    get: operations['get_available_scorer_models_llm_integrations__llm_integration__scorer_models_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/log_streams': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Log Streams
     * @description Retrieve all log streams for a project.
     */
    get: operations['list_log_streams_projects__project_id__log_streams_get'];
    put?: never;
    /**
     * Create Log Stream
     * @description Create a new log stream for a project.
     */
    post: operations['create_log_stream_projects__project_id__log_streams_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/log_streams/{log_stream_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Log Stream
     * @description Retrieve a specific log stream.
     */
    get: operations['get_log_stream_projects__project_id__log_streams__log_stream_id__get'];
    /**
     * Update Log Stream
     * @description Update a specific log stream.
     */
    put: operations['update_log_stream_projects__project_id__log_streams__log_stream_id__put'];
    post?: never;
    /**
     * Delete Log Stream
     * @description Delete a specific log stream.
     */
    delete: operations['delete_log_stream_projects__project_id__log_streams__log_stream_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/meta/columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List Metadata Columns
     * @description Describes the available metadata columns for a given project_id/run_id.
     *
     *     Response is a list of MetaInfo objects with fields:
     *     name
     *     is_categorical
     *     unique_values
     *     unique_values_filtered (if filter applied)
     *     n_unique_values
     *     n_unique_values_filtered (if filter applied)
     *     max
     *     min
     */
    post: operations['list_metadata_columns_projects__project_id__runs__run_id__split__split__meta_columns_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/metric_critiques': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create Metric Critiques */
    post: operations['create_metric_critiques_projects__project_id__metric_critiques_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/metric_critiques/{critique_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Delete Metric Critique */
    delete: operations['delete_metric_critique_projects__project_id__metric_critiques__critique_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/alerts/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create
     * @description Create alert for llm-monitor.
     */
    post: operations['create_projects__project_id__alerts_create_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/alerts/{monitor_alert_config_id}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Update
     * @description Create alert for llm-monitor.
     */
    put: operations['update_projects__project_id__alerts__monitor_alert_config_id__update_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/alerts/{monitor_alert_config_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Alert By Id */
    get: operations['get_alert_by_id_projects__project_id__alerts__monitor_alert_config_id__get'];
    put?: never;
    post?: never;
    /**
     * Delete Alert
     * @description Get all rows from monitor_records.
     *
     *     Returns them in order of creation from newest to oldest.
     */
    delete: operations['delete_alert_projects__project_id__alerts__monitor_alert_config_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/alerts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Alerts By Project */
    get: operations['list_alerts_by_project_projects__project_id__alerts_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/observe/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Log Workflows
     * @description Log workflows to an Observe project.
     *
     *     Use this endpoint to log workflows to an Observe project. The request body should contain the
     *     `workflows` to be ingested.
     *
     *     Additionally, specify the `project_id` or `project_name` to which the workflows should be ingested.
     *     If the project does not exist, it will be created. If the project exists, the workflows will be logged to it.
     *     If both `project_id` and `project_name` are provided, `project_id` will take precedence.
     */
    post: operations['log_workflows_observe_workflows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/observe/projects/{project_id}/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Workflows
     * @description Get workflows for a specific run in an Observe project.
     */
    post: operations['get_workflows_observe_projects__project_id__workflows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/ingest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Ingest
     * @description Ingest batches of transaction records from llm-monitor.
     */
    post: operations['ingest_projects__project_id__observe_ingest_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/rows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Rows
     * @description Get all rows from monitor_records.
     *
     *     Returns them in order of creation from newest to oldest.
     */
    post: operations['get_rows_projects__project_id__observe_rows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/filter_options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Filter Options
     * @description Get filter options for the observe view.
     */
    get: operations['get_filter_options_projects__project_id__observe_filter_options_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/metric_critique_columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Metric Critique Columns
     * @description Get the metadata for the columns in the observe view.
     */
    get: operations['get_metric_critique_columns_projects__project_id__observe_metric_critique_columns_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export Rows
     * @description Export rows from monitor_records as jsonl or csv.
     */
    post: operations['export_rows_projects__project_id__observe_export_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/export/databricks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export Rows Databricks
     * @description Export rows from monitor_records to databricks.
     */
    post: operations['export_rows_databricks_projects__project_id__observe_export_databricks_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get Metrics */
    post: operations['get_metrics_projects__project_id__observe_metrics_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete Rows
     * @description Get all rows from monitor_records.
     *
     *     Returns them in order of creation from newest to oldest.
     */
    post: operations['delete_rows_projects__project_id__observe_delete_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/workflows-count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get Workflow Count */
    post: operations['get_workflow_count_projects__project_id__observe_workflows_count_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/integrations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Integrations
     * @description Get the integrations for a project.
     */
    get: operations['get_project_integrations_projects__project_id__observe_integrations_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/column_schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Metrics Schema Endpoint
     * @description Get column_schema for each metric.
     */
    get: operations['get_metrics_schema_endpoint_projects__project_id__observe_column_schema_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/observe/user_metadata': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get User Metadata Endpoint
     * @description Get user_metadata fields for a project.
     */
    get: operations['get_user_metadata_endpoint_projects__project_id__observe_user_metadata_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/organizations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create Organization */
    post: operations['create_organization_organizations_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/organizations/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Organizations */
    post: operations['query_organizations_organizations_query_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/project_settings/{project_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Update Project Settings Legacy */
    put: operations['update_project_settings_legacy_project_settings__project_id__put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Settings */
    get: operations['get_settings_projects__project_id__settings_get'];
    /** Update Project Settings */
    put: operations['update_project_settings_projects__project_id__settings_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/settings/scorers_config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Scorers Config */
    get: operations['get_scorers_config_projects__project_id__settings_scorers_config_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/project/{project_id}/settings/scorers_config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Scorers Config */
    get: operations['get_scorers_config_project__project_id__settings_scorers_config_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/settings/observe': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Observe Settings */
    get: operations['get_observe_settings_projects__project_id__settings_observe_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/settings/evaluate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Evaluate Settings */
    get: operations['get_evaluate_settings_projects__project_id__settings_evaluate_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/collaborator_roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Collaborator Roles */
    get: operations['get_collaborator_roles_collaborator_roles_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Projects
     * @deprecated
     * @description Gets projects for a user.
     *
     *     If provided, filters on project_name and project_type.
     *
     *     DEPRECATED in favor of `get_projects_paginated`.
     */
    get: operations['get_projects_projects_get'];
    put?: never;
    /**
     * Create Project
     * @description Create a new project.
     */
    post: operations['create_project_projects_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/paginated': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Projects Paginated
     * @description Gets projects for a user with pagination.
     *
     *     If provided, filters on project_name and project_type.
     */
    post: operations['get_projects_paginated_projects_paginated_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Projects Count
     * @description Gets total count of projects for a user with applied filters.
     */
    post: operations['get_projects_count_projects_count_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/all': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get All Projects
     * @deprecated
     * @description Gets all public projects and all private projects that the user has access to.
     *
     *     For Enterprise SaaS Clusters, this will return all projects in the cluster.
     *
     *     DEPRECATED in favor of `get_projects_paginated`.
     */
    get: operations['get_all_projects_projects_all_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Project */
    get: operations['get_project_projects__project_id__get'];
    /** Update Project */
    put: operations['update_project_projects__project_id__put'];
    post?: never;
    /**
     * Delete Project
     * @description Deletes a project and all associated runs and objects.
     *
     *     Any user with project access can delete a project.
     *     Note that `get_project_by_id` calls `user_can_access_project`.
     */
    delete: operations['delete_project_projects__project_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/upload_file': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Upload File */
    post: operations['upload_file_projects__project_id__upload_file_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List User Project Collaborators
     * @description List the users with which the project has been shared.
     */
    get: operations['list_user_project_collaborators_projects__project_id__users_get'];
    put?: never;
    /**
     * Create User Project Collaborators
     * @description Share a project with users.
     */
    post: operations['create_user_project_collaborators_projects__project_id__users_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Group Project Collaborators
     * @description List the groups with which the project has been shared.
     */
    get: operations['list_group_project_collaborators_projects__project_id__groups_get'];
    put?: never;
    /**
     * Create Group Project Collaborators
     * @description Share a project with groups.
     */
    post: operations['create_group_project_collaborators_projects__project_id__groups_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/users/{user_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete User Project Collaborator
     * @description Remove a user's access to a project.
     */
    delete: operations['delete_user_project_collaborator_projects__project_id__users__user_id__delete'];
    options?: never;
    head?: never;
    /**
     * Update User Project Collaborator
     * @description Update the sharing permissions of a user on a project.
     */
    patch: operations['update_user_project_collaborator_projects__project_id__users__user_id__patch'];
    trace?: never;
  };
  '/projects/{project_id}/groups/{group_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete Group Project Collaborator
     * @description Remove a group's access to a project.
     */
    delete: operations['delete_group_project_collaborator_projects__project_id__groups__group_id__delete'];
    options?: never;
    head?: never;
    /**
     * Update Group Project Collaborator
     * @description Update the sharing permissions of a group on a project.
     */
    patch: operations['update_group_project_collaborator_projects__project_id__groups__group_id__patch'];
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/chains/ingest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Ingest Prompt Chain Run */
    post: operations['ingest_prompt_chain_run_projects__project_id__runs__run_id__chains_ingest_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/chains/ingest/batch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Ingest Batch */
    post: operations['ingest_batch_projects__project_id__runs__run_id__chains_ingest_batch_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/prompts/models/all': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get All Models */
    get: operations['get_all_models_prompts_models_all_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/rows/columnar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get Rows As Columns With Filters */
    post: operations['get_rows_as_columns_with_filters_projects__project_id__runs__run_id__prompts_rows_columnar_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/rows/{row_id}/columnar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Row As Column */
    get: operations['get_row_as_column_projects__project_id__runs__run_id__prompts_rows__row_id__columnar_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/prompts/rows/columnar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Multi Run Sample Ids
     * @description Given a list of runs with the same inputs, output the indices of each sample in each run.
     */
    get: operations['get_multi_run_sample_ids_projects__project_id__runs_prompts_rows_columnar_get'];
    put?: never;
    /**
     * Get Multi Run Samples For Row Ids
     * @description Given run_ids with their corresponding row ids, retrieve the samples for those row_ids.
     */
    post: operations['get_multi_run_samples_for_row_ids_projects__project_id__runs_prompts_rows_columnar_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/rows/chains/{chain_id}/columnar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Chain As Columns */
    get: operations['get_chain_as_columns_projects__project_id__runs__run_id__prompts_rows_chains__chain_id__columnar_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/prompts/rows/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Groups */
    get: operations['get_groups_prompts_rows_groups_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/export_prompt_dataset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export Prompt Dataset
     * @deprecated
     */
    get: operations['export_prompt_dataset_projects__project_id__runs__run_id__prompts_export_prompt_dataset_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/chains/{chain_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Prompt Chain Rows */
    get: operations['get_prompt_chain_rows_projects__project_id__runs__run_id__chains__chain_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/rows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Rows
     * @deprecated
     */
    get: operations['get_rows_projects__project_id__runs__run_id__prompts_rows_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/scorers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Submit Scorers
     * @description Trigger jobs to recompute a metric based on recompute settings.
     */
    put: operations['submit_scorers_projects__project_id__scorers_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/scorers/{scorer_name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Put Score */
    put: operations['put_score_projects__project_id__runs__run_id__prompts_scorers__scorer_name__put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/templates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Templates
     * @description Get all prompt templates for a project.
     *
     *     Parameters
     *     ----------
     *     project_id : UUID4
     *         Project ID.
     *     db_read : Session, optional
     *         Session object to execute DB reads, by default Depends(get_db_read).
     *
     *     Returns
     *     -------
     *     List[GetTemplateResponse]
     *         List of prompt template responses.
     */
    get: operations['get_project_templates_projects__project_id__templates_get'];
    put?: never;
    /**
     * Create Prompt Template With Version
     * @description For a given project, create a prompt template.
     *
     *     We first create a prompt template version, and then create a prompt template that
     *     points to that version as the selected version.
     *
     *     Parameters
     *     ----------
     *     project_id : UUID4
     *         Project ID.
     *     current_user : User, optional
     *         User who sent the request, by default Depends(authentication_service.current_user)
     *     create_request : CreatePromptTemplateWithVersionRequestBody, optional
     *         Request body, by default Body( ...,
     *             examples=
     *             [BasePromptTemplateVersion.test_data() | BasePromptTemplate.test_data()],
     *         )
     *     db_read : Session, optional
     *         Session object to execute DB reads, by default Depends(get_db_read)
     *
     *     Returns
     *     -------
     *     CreatePromptTemplateResponse
     *         Details about the created prompt template.
     */
    post: operations['create_prompt_template_with_version_projects__project_id__templates_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/templates/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Template Version By Name
     * @description Get a prompt template from a project.
     *
     *     Parameters
     *     ----------
     *     project_id : UUID4
     *         Prokect ID.
     *     template_name : str
     *         Prompt template name.
     *     version : Optional[int]
     *         Version number to fetch. defaults to selected version.
     *     db_read : Session, optional
     *         Session object to execute DB reads, by default Depends(get_db_read).
     *
     *
     *     Returns
     *     -------
     *     GetTemplateResponse
     *         Prompt template response.
     */
    get: operations['get_template_version_by_name_projects__project_id__templates_versions_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/templates/{template_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Template From Project
     * @description Get a prompt template from a project.
     *
     *     Parameters
     *     ----------
     *     template_id : UUID4
     *         Prompt template ID.
     *     project_id : UUID4
     *         Prokect ID.
     *     db_read : Session, optional
     *         Session object to execute DB reads, by default Depends(get_db_read).
     *
     *     Returns
     *     -------
     *     GetTemplateResponse
     *         Prompt template response.
     */
    get: operations['get_template_from_project_projects__project_id__templates__template_id__get'];
    put?: never;
    post?: never;
    /** Delete Template */
    delete: operations['delete_template_projects__project_id__templates__template_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/templates/{template_id}/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create Prompt Template Version
     * @description Create a prompt template version for a given prompt template.
     *
     *     Parameters
     *     ----------
     *     project_id : UUID4
     *         Project ID.
     *     template_id : UUID4
     *         Prompt template ID.
     *     current_user : User, optional
     *         Authenticated user, by default Depends(authentication_service.current_user)
     *     body : dict, optional
     *         Body of the request, by default Body( ...,
     *             examples=[CreatePromptTemplateVersionRequest.test_data()],
     *         )
     *     db_read : Session, optional
     *         Database session, by default Depends(get_db_read)
     *
     *     Returns
     *     -------
     *     BasePromptTemplateVersionResponse
     *         Response with details about the created prompt template version.
     */
    post: operations['create_prompt_template_version_projects__project_id__templates__template_id__versions_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/templates/{template_id}/versions/{version}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Template Version
     * @description Get a specific version of a prompt template.
     *
     *     Parameters
     *     ----------
     *     template_id : UUID4
     *         Template ID.
     *     version : int
     *         Version number to fetch.
     *     current_user : User, optional
     *         User who is authorized, by default Depends(authentication_service.current_user).
     *     db_read : Session, optional
     *         Database session, by default Depends(get_db_read)
     *
     *     Returns
     *     -------
     *     BasePromptTemplateVersionResponse
     *         Prompt template version response.
     */
    get: operations['get_template_version_projects__project_id__templates__template_id__versions__version__get'];
    /** Set Selected Template Version */
    put: operations['set_selected_template_version_projects__project_id__templates__template_id__versions__version__put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/protect/invoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Invoke */
    post: operations['invoke_protect_invoke_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/registered-scorers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Scorers */
    get: operations['list_scorers_registered_scorers_get'];
    /** Create Or Update */
    put: operations['create_or_update_registered_scorers_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/registered-scorers/{registered_scorer_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Delete Scorer */
    delete: operations['delete_scorer_registered_scorers__registered_scorer_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/scorer-settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Settings */
    get: operations['get_settings_projects__project_id__runs__run_id__scorer_settings_get'];
    put?: never;
    /** Upsert Scorers Config */
    post: operations['upsert_scorers_config_projects__project_id__runs__run_id__scorer_settings_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Runs
     * @description Gets all runs for a project.
     *
     *     If a run_name is provided, gets the run with that name, or []
     */
    get: operations['get_project_runs_projects__project_id__runs_get'];
    put?: never;
    /** Create Run */
    post: operations['create_run_projects__project_id__runs_post'];
    /**
     * Delete Runs
     * @description Deletes runs by their ids.
     *
     *     Only runs within the same project can be deleted.
     */
    delete: operations['delete_runs_projects__project_id__runs_delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/prompts/runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Prompt Runs
     * @description Gets all prompt runs for a project.
     *
     *     This is different from get_project_runs because it adds extra details that are needed for the prompt run page.
     */
    get: operations['get_project_prompt_runs_projects__project_id__prompts_runs_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/prompts/runs/columnar': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Prompt Runs As Columns
     * @deprecated
     * @description Gets all prompt runs for a project in a columnar format.
     *
     *     This is different from get_project_prompt_runs because it:
     *     1. Returns results in a columnar format instead of a key-value pair of arrays.
     *     2. Includes metadata about each of the columns.
     *     3. Includes mappings to each column's display names and super column names.
     */
    get: operations['get_project_prompt_runs_as_columns_projects__project_id__prompts_runs_columnar_get'];
    put?: never;
    /**
     * Get Project Prompt Runs As Columns With Filters
     * @description Gets all prompt runs for a project in a columnar format.
     *
     *     This is different from get_project_prompt_runs because it:
     *     1. Returns results in a columnar format instead of a key-value pair of arrays.
     *     2. Includes metadata about each of the columns.
     *     3. Includes mappings to each column's display names and super column names.
     */
    post: operations['get_project_prompt_runs_as_columns_with_filters_projects__project_id__prompts_runs_columnar_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Run */
    get: operations['get_run_projects__project_id__runs__run_id__get'];
    /** Update Run */
    put: operations['update_run_projects__project_id__runs__run_id__put'];
    post?: never;
    /** Delete Run */
    delete: operations['delete_run_projects__project_id__runs__run_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/prompts/runs/{run_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Prompt Run
     * @deprecated
     * @description Gets a specific prompt run for the project.
     *
     *     This is different from get_project_runs because it adds extra details that are needed for the prompt run page.
     */
    get: operations['get_prompt_run_projects__project_id__prompts_runs__run_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/link': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Run Link */
    get: operations['get_run_link_projects__project_id__runs__run_id__link_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/tasks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Run Tasks
     * @description Gets tasks for a given multi-label project_id/run_id.
     *
     *     This is for multi-label runs, otherwise it will raise an exception
     */
    get: operations['get_run_tasks_projects__project_id__runs__run_id__tasks_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/labels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Run Labels
     * @description Gets labels for a given project_id/run_id.
     *
     *     Split is not required because labels are the same across splits. If this is a multi-label run, a task is required,
     *     otherwise it is not expected
     */
    get: operations['get_run_labels_projects__project_id__runs__run_id__labels_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/inference_names': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Run Inference Names
     * @description Gets logged inference names for a given project_id/run_id.
     *
     *     If no inference names are logged, this will return an empty list
     */
    get: operations['get_run_inference_names_projects__project_id__runs__run_id__inference_names_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/epochs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Num Epochs For Run
     * @description Gets the number of training epochs for the run.
     */
    get: operations['get_num_epochs_for_run_projects__project_id__runs__run_id__split__split__epochs_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/splits': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Splits
     * @description Gets logged splits for a given project_id/run_id.
     */
    get: operations['get_splits_projects__project_id__runs__run_id__splits_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Metrics For Run
     * @description List metrics for a run.
     *
     *     Optionally provide a key to narrow the search
     */
    get: operations['get_metrics_for_run_projects__project_id__runs__run_id__metrics_get'];
    /**
     * Set Metric For Run
     * @description Sets or updates a metric for a run.
     */
    put: operations['set_metric_for_run_projects__project_id__runs__run_id__metrics_put'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/prompts/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Prompt Aggregate Metrics As Singleton Columns */
    get: operations['get_prompt_aggregate_metrics_as_singleton_columns_projects__project_id__runs__run_id__prompts_metrics_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/tags': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Run Tags
     * @description Gets tags for a given project_id/run_id.
     */
    get: operations['get_run_tags_projects__project_id__runs__run_id__tags_get'];
    put?: never;
    /**
     * Set Tag For Run
     * @description Sets or updates a tag for a run.
     */
    post: operations['set_tag_for_run_projects__project_id__runs__run_id__tags_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/tags/{tag_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Run Tag
     * @description Gets tags for a given project_id/run_id.
     */
    get: operations['get_run_tag_projects__project_id__runs__run_id__tags__tag_id__get'];
    /**
     * Update Tag For Run
     * @description Sets or updates a tag for a run.
     */
    put: operations['update_tag_for_run_projects__project_id__runs__run_id__tags__tag_id__put'];
    post?: never;
    /** Delete Run Tag */
    delete: operations['delete_run_tag_projects__project_id__runs__run_id__tags__tag_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scorers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create */
    post: operations['create_scorers_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scorers/{scorer_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Scorer */
    get: operations['get_scorer_scorers__scorer_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** Update */
    patch: operations['update_scorers__scorer_id__patch'];
    trace?: never;
  };
  '/scorers/{scorer_id}/version/llm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create Llm Scorer Version */
    post: operations['create_llm_scorer_version_scorers__scorer_id__version_llm_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scorers/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List Scorers With Filters */
    post: operations['list_scorers_with_filters_scorers_list_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scorers/tags': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Tags */
    get: operations['list_tags_scorers_tags_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/scorers/{scorer_id}/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Scorer Versions */
    get: operations['get_scorer_versions_scorers__scorer_id__versions_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/slices': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Project Slices
     * @description Gets all slices in a project.
     *
     *     If slice_name is provided, returns the slice with that name, else []
     */
    get: operations['get_project_slices_projects__project_id__slices_get'];
    put?: never;
    /**
     * Create Slice
     * @description Creates a Slice.
     *
     *     The "logic" field of a slice should be dictionary that matches the fields of a ProcRequest (without the project,
     *     run, or split). On request, the logic will be validated. The returned Slice's "logic" field should fit directly into
     *     a ProcRequest (barring the run_id and Split. Those must be provided by the client).
     */
    post: operations['create_slice_projects__project_id__slices_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/split/{split}/slices': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Slice Metrics For Run
     * @description Gets all slices in specific run.
     *
     *     We apply the logic and compute metrics for each slice.
     */
    get: operations['get_slice_metrics_for_run_projects__project_id__runs__run_id__split__split__slices_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/slices/{slice_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Slice
     * @description Gets a slice.
     *
     *     The returned slice will have a "logic" field that will be directly usable in a ProcRequest (barring the run_id and
     *     Split. Those must be provided by the client).
     */
    get: operations['get_slice_projects__project_id__slices__slice_id__get'];
    /**
     * Update Slice
     * @description Updates a slice.
     *
     *     When updating a slice, you cannot update individual fields. You must update the ENTIRE slice. Meaning whatever is
     *     sent in the request will become the new slice.
     */
    put: operations['update_slice_projects__project_id__slices__slice_id__put'];
    post?: never;
    /** Delete Slice */
    delete: operations['delete_slice_projects__project_id__slices__slice_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/stages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Stage */
    get: operations['get_stage_projects__project_id__stages_get'];
    put?: never;
    /** Create Stage */
    post: operations['create_stage_projects__project_id__stages_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/stages/{stage_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Pause Stage */
    put: operations['pause_stage_projects__project_id__stages__stage_id__put'];
    /** Update Stage */
    post: operations['update_stage_projects__project_id__stages__stage_id__post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/traces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log Traces */
    post: operations['log_traces_projects__project_id__traces_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/traces/available_columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Traces Available Columns */
    post: operations['traces_available_columns_projects__project_id__traces_available_columns_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/spans/available_columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Spans Available Columns */
    post: operations['spans_available_columns_projects__project_id__spans_available_columns_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/traces/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Traces */
    post: operations['query_traces_projects__project_id__traces_search_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/spans/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Spans */
    post: operations['query_spans_projects__project_id__spans_search_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/traces/{trace_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Trace */
    get: operations['get_trace_projects__project_id__traces__trace_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/spans/{span_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Span */
    get: operations['get_span_projects__project_id__spans__span_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/models/{model_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Model Endpoint
     * @description Gets a model from the database and returns the presigned url to download it :param project_id: project id :param
     *     run_id: run id :param model_id: model id :param db_read: database session :param current_user: current user.
     */
    get: operations['get_model_endpoint_models__model_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/models': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get All Models
     * @description Gets all models for a run :param project_id: project id :param run_id: run id :param db_read: database session
     *     :param current_user: current user.
     */
    get: operations['get_all_models_models_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/runs/{run_id}/model': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Model By Run
     * @description Gets a model from the database and returns the presigned url to download it :param run_id: run id :param db_read:
     *
     *     database session.
     */
    get: operations['get_model_by_run_projects__project_id__runs__run_id__model_get'];
    put?: never;
    /**
     * Upload Model
     * @description Uploads a model to the object store and creates a model record in the database :param project_id: project id
     *     :param run_id: run id :param validation_request: model upload request.
     */
    post: operations['upload_model_projects__project_id__runs__run_id__model_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/models/all': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get All Models For Project
     * @description Gets all models for a run :param project_id: project id :param run_id: run id :param db_read: database
     *     session.
     */
    get: operations['get_all_models_for_project_projects__project_id__models_all_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/projects/{project_id}/bookmark': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Bookmark Project */
    put: operations['bookmark_project_projects__project_id__bookmark_put'];
    post?: never;
    /** Unbookmark Project */
    delete: operations['unbookmark_project_projects__project_id__bookmark_delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/usage_plans': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Usage Plans
     * @description Get the static usage plans for the supported subscription plans.
     *
     *     Returns:
     *         dict[UsagePlanName, UsagePlan]: A dictionary mapping subscription plan types
     *             to their corresponding usage plans.
     */
    get: operations['get_usage_plans_usage_plans_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/healthcheck': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Healthcheck */
    get: operations['healthcheck_v1_healthcheck_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Token */
    get: operations['get_token_v1_token_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/evaluate/runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create Workflows Run
     * @description Create a new Evaluate run with workflows.
     *
     *     Use this endpoint to create a new Evaluate run with workflows. The request body should contain the `workflows` to be ingested and evaluated.
     *
     *     Additionally, specify the `project_id` or `project_name` to which the workflows should be ingested. If the project does not exist, it will be created. If the project exists, the workflows will be logged to it. If both `project_id` and `project_name` are provided, `project_id` will take precedence. The `run_name` is optional and will be auto-generated (timestamp-based) if not provided.
     *
     *     The body is also expected to include the configuration for the scorers to be used in the evaluation. This configuration will be used to evaluate the workflows and generate the results.
     */
    post: operations['create_workflows_run_v1_evaluate_runs_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/evaluate/run-workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Evaluate Run Results
     * @description Fetch evaluation results for a specific run including rows and aggregate information.
     */
    post: operations['get_evaluate_run_results_v1_evaluate_run_workflows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/observe/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Log Workflows
     * @description Log workflows to an Observe project.
     *
     *     Use this endpoint to log workflows to an Observe project. The request body should contain the
     *     `workflows` to be ingested.
     *
     *     Additionally, specify the `project_id` or `project_name` to which the workflows should be ingested.
     *     If the project does not exist, it will be created. If the project exists, the workflows will be logged to it.
     *     If both `project_id` and `project_name` are provided, `project_id` will take precedence.
     */
    post: operations['log_workflows_v1_observe_workflows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/observe/projects/{project_id}/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get Workflows
     * @description Get workflows for a specific run in an Observe project.
     */
    post: operations['get_workflows_v1_observe_projects__project_id__workflows_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v1/protect/invoke': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Invoke */
    post: operations['invoke_v1_protect_invoke_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/healthcheck': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Healthcheck */
    get: operations['healthcheck_v2_healthcheck_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Token */
    get: operations['get_token_v2_token_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/traces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Log Traces */
    post: operations['log_traces_v2_projects__project_id__traces_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/traces/available_columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Traces Available Columns */
    post: operations['traces_available_columns_v2_projects__project_id__traces_available_columns_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/spans/available_columns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Spans Available Columns */
    post: operations['spans_available_columns_v2_projects__project_id__spans_available_columns_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/traces/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Traces */
    post: operations['query_traces_v2_projects__project_id__traces_search_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/spans/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query Spans */
    post: operations['query_spans_v2_projects__project_id__spans_search_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/traces/{trace_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Trace */
    get: operations['get_trace_v2_projects__project_id__traces__trace_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/spans/{span_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Span */
    get: operations['get_span_v2_projects__project_id__spans__span_id__get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/log_streams': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Log Streams
     * @description Retrieve all log streams for a project.
     */
    get: operations['list_log_streams_v2_projects__project_id__log_streams_get'];
    put?: never;
    /**
     * Create Log Stream
     * @description Create a new log stream for a project.
     */
    post: operations['create_log_stream_v2_projects__project_id__log_streams_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/log_streams/{log_stream_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Log Stream
     * @description Retrieve a specific log stream.
     */
    get: operations['get_log_stream_v2_projects__project_id__log_streams__log_stream_id__get'];
    /**
     * Update Log Stream
     * @description Update a specific log stream.
     */
    put: operations['update_log_stream_v2_projects__project_id__log_streams__log_stream_id__put'];
    post?: never;
    /**
     * Delete Log Stream
     * @description Delete a specific log stream.
     */
    delete: operations['delete_log_stream_v2_projects__project_id__log_streams__log_stream_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/experiments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Experiments
     * @description Retrieve all experiments for a project.
     */
    get: operations['list_experiments_v2_projects__project_id__experiments_get'];
    put?: never;
    /**
     * Create Experiment
     * @description Create a new experiment for a project.
     */
    post: operations['create_experiment_v2_projects__project_id__experiments_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/projects/{project_id}/experiments/{experiment_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Experiment
     * @description Retrieve a specific experiment.
     */
    get: operations['get_experiment_v2_projects__project_id__experiments__experiment_id__get'];
    /**
     * Update Experiment
     * @description Update a specific experiment.
     */
    put: operations['update_experiment_v2_projects__project_id__experiments__experiment_id__put'];
    post?: never;
    /**
     * Delete Experiment
     * @description Delete a specific experiment.
     */
    delete: operations['delete_experiment_v2_projects__project_id__experiments__experiment_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** ActionResult */
    ActionResult: {
      /** @description Type of action that was taken. */
      type: components['schemas']['ActionType'];
      /**
       * Value
       * @description Value of the action that was taken.
       */
      value: string;
    };
    /**
     * ActionType
     * @enum {string}
     */
    ActionType: 'OVERRIDE' | 'PASSTHROUGH';
    /** AgentStep */
    AgentStep: {
      /**
       * @description Type of the step. By default, it is set to agent. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'agent';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Steps
       * @description Steps in the workflow.
       */
      steps?: (
        | components['schemas']['WorkflowStep']
        | components['schemas']['ChainStep']
        | components['schemas']['LlmStep']
        | components['schemas']['RetrieverStep']
        | components['schemas']['ToolStep']
        | components['schemas']['AgentStep']
      )[];
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildren'] | null;
    };
    /** AgenticWorkflowSuccessScorer */
    AgenticWorkflowSuccessScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'agentic_workflow_success';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default plus
       * @constant
       */
      type?: 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /**
     * AgenticWorkflowSuccessTemplate
     * @description Template for the agentic workflow success metric,
     *     containing all the info necessary to send the agentic workflow success prompt.
     */
    AgenticWorkflowSuccessTemplate: {
      /**
       * Metric System Prompt
       * @default You will receive the chat history from a chatbot application between a user and an AI. At the end of the chat history, it is AIs turn to act.
       *
       *     In the chat history, the user can either ask questions, which are answered with words, or make requests that require calling tools and actions to resolve. Sometimes these are given as orders, and these should be treated as questions or requests. The AI's turn may involve several steps which are a combination of internal reflections, planning, selecting tools, calling tools, and ends with the AI replying to the user.
       *     Your task involves the following steps:
       *
       *     ########################
       *
       *     Step 1: user_last_input and user_ask
       *
       *     First, identify the user's last input in the chat history. From this input, create a list with one entry for each user question, request, or order. If there are no user asks in the user's last input, leave the list empty and skip ahead, considering the AI's turn successful.
       *
       *     ########################
       *
       *     Step 2: ai_final_response and answer_or_resolution
       *
       *     Identify the AI's final response to the user: it is the very last step in the AI's turn.
       *
       *     For every user_ask, focus on ai_final_response and try to extract either an answer or a resolution using the following definitions:
       *     - An answer is a part of the AI's final response that directly responds to all or part of a user's question, or asks for further information or clarification.
       *     - A resolution is a part of the AI's final response that confirms a successful resolution, or asks for further information or clarification in order to answer a user's request.
       *
       *     If the AI's final response does not address the user ask, simply write "No answer or resolution provided in the final response". Do not shorten the answer or resolution; provide the entire relevant part.
       *
       *     ########################
       *
       *     Step 3: tools_input_output
       *
       *     Examine every step in the AI's turn and identify which tool/function step seemingly contributed to creating the answer or resolution. Every tool call should be linked to a user ask. If an AI step immediately before or after the tool call mentions planning or using a tool for answering a user ask, the tool call should be associated with that user ask. If the answer or resolution strongly resembles the output of a tool, the tool call should also be associated with that user ask.
       *
       *     Create a list containing the concatenation of the entire input and output of every tool used in formulating the answer or resolution. The tool input is listed as an AI step before calling the tool, and the tool output is listed as a tool step.
       *
       *     ########################
       *
       *     Step 4: properties, boolean_properties and answer_successful
       *
       *     For every answer or resolution from Step 2, check the following properties one by one to determine which are satisfied:
       *     - factually_wrong: the answer contains factual errors.
       *     - addresses_different_ask: the answer or resolution addresses a slightly different user ask (make sure to differentiate this from asking clarifying questions related to the current ask).
       *     - not_adherent_to_tools_output: the answer or resolution includes citations from a tool's output, but some are wrongly copied or attributed.
       *     - mentions_inability: the answer or resolution mentions an inability to complete the user ask.
       *     - mentions_unsuccessful_attempt: the answer or resolution mentions an unsuccessful or failed attempt to complete the user ask.
       *
       *     Then copy all the properties (only the boolean value) in the list boolean_properties.
       *
       *     Finally, set answer_successful to `false` if any entry in boolean_properties is set to `true`, otherwise set answer_successful to `true`.
       *
       *     ########################
       *
       *     You must respond in the following JSON format:
       *     ```
       *     {
       *         "user_last_input": string,
       *         "ai_final_response": string,
       *         "asks_and_answers": list[dict],
       *         "ai_turn_is_successful": boolean,
       *         "explanation": string
       *     }
       *     ```
       *
       *     Your tasks are defined as follows:
       *
       *     - **"asks_and_answers"**: Perform all the tasks described in the steps above. Your answer should be a list where each user ask appears as:
       *
       *     ```
       *     {
       *         "user_ask": string,
       *         "answer_or_resolution": string,
       *         "tools_input_output": list[string],
       *         "properties" : {
       *             "factually_wrong": boolean,
       *             "addresses_different_ask": boolean,
       *             "not_adherent_to_tools_output": boolean,
       *             "mentions_inability": boolean,
       *             "mentions_unsuccessful_attempt": boolean
       *         },
       *         "boolean_properties": list[boolean],
       *         "answer_successful": boolean
       *     }
       *     ```
       *
       *     - **"ai_turn_is_successful"**: Respond `true` if at least one answer_successful is True, otherwise respond `false`.
       *
       *     - **"explanation"**: If at least one answer was considered successful, explain why. Otherwise explain why all answers were not successful.
       *
       *     You must respond with a valid JSON object; be sure to escape special characters.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @default I have a multi-turn chatbot application where the assistant is an agent that has access to tools. An assistant workflow can involves possibly multiple tool selections steps, tool calls steps, and finally a reply to the user. I want a metric that assesses whether each assistant's workflow was thoughtfully planned and ended up helping answer the queries.
       *
       */
      metric_description?: string;
      /**
       * Value Field Name
       * @default ai_turn_is_successful
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default Chatbot history:
       *     ```
       *     {query}
       *     ```
       *
       *     AI's turn:
       *     ```
       *     {response}
       *     ```
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @default [
       *       {
       *         "generation_prompt_and_response": "Chatbot history:\n```\nsystem: You are a helpful assistant, with no access to external functions.\nuser: Can you analyze the given C# code and identify any errors present? Please mention the line numbers where the errors occur, describe their nature, suggest the necessary changes to rectify them and also mention any security vulnerabilities present in the code.\n```\n\nAI's turn:\n```\nassistant: Sure, please provide the C# code so I can analyze it for errors and security vulnerabilities. <|endoftext|>\n```",
       *         "evaluating_response": "{\"user_last_input\": \"Can you analyze the given C# code and identify any errors present? Please mention the line numbers where the errors occur, describe their nature, suggest the necessary changes to rectify them and also mention any security vulnerabilities present in the code.\", \"ai_final_response\": \"Sure, please provide the C# code so I can analyze it for errors and security vulnerabilities. <|endoftext|>\", \"asks_and_answers\": [{\"user_ask\": \"Can you analyze the given C# code and identify any errors present? Please mention the line numbers where the errors occur, describe their nature, suggest the necessary changes to rectify them and also mention any security vulnerabilities present in the code.\", \"answer_or_resolution\": \"Sure, please provide the C# code so I can analyze it for errors and security vulnerabilities.\", \"tools_input_output\": [], \"properties\": {\"factually_wrong\": false, \"addresses_different_ask\": false, \"not_adherent_to_tools_output\": false, \"mentions_inability\": false, \"mentions_unsuccessful_attempt\": false}, \"boolean_properties\": [false, false, false, false, false], \"answer_successful\": true}], \"ai_turn_is_successful\": true, \"explanation\": \"The answer was successful because the AI correctly requested further information (the C# code) from the user in order to fulfill the user's request. No errors or issues were present in the response.\"}"
       *       },
       *       {
       *         "generation_prompt_and_response": "Chatbot history:\n```\nuser: Could you please provide me with the list of available languages for text to speech? I want to convert a text into speech in different languages and need to know which languages are supported by the API.\nBegin!\n\n```\n\nAI's turn:\n```\nassistant: I am making this API call to get the list of available languages for text to speech, as the user wants to convert text into speech in different languages. By calling the 'get_language_for_text_to_speech' function with no arguments, I can retrieve the supported languages from the API. This will provide me with the necessary information to assist the user in their query.\nassistant: {'arguments': '{}', 'name': 'get_language_for_text_to_speech'}\nfunction: {\"error\": \"\", \"response\": \"{\\\"af\\\":\\\"Afrikaans\\\",\\\"sq\\\":\\\"Albanian\\\",\\\"ar\\\":\\\"Arabic\\\",\\\"hy\\\":\\\"Armenian\\\",\\\"ca\\\":\\\"Catalan\\\",\\\"zh\\\":\\\"Chinese\\\",\\\"zh-cn\\\":\\\"Chinese (Mandarin/China)\\\",\\\"zh-tw\\\":\\\"Chinese (Mandarin/Taiwan)\\\",\\\"zh-yue\\\":\\\"Chinese (Cantonese)\\\",\\\"hr\\\":\\\"Croatian\\\",\\\"cs\\\":\\\"Czech\\\",\\\"da\\\":\\\"Danish\\\",\\\"nl\\\":\\\"Dutch\\\",\\\"en\\\":\\\"English\\\",\\\"en-au\\\":\\\"English (Australia)\\\",\\\"en-uk\\\":\\\"English (United Kingdom)\\\",\\\"en-us\\\":\\\"English (United States)\\\",\\\"eo\\\":\\\"Esperanto\\\",\\\"fi\\\":\\\"Finnish\\\",\\\"fr\\\":\\\"French\\\",\\\"de\\\":\\\"German\\\",\\\"el\\\":\\\"Greek\\\",\\\"ht\\\":\\\"Haitian Creole\\\",\\\"hi\\\":\\\"Hindi\\\",\\\"hu\\\":\\\"Hungarian\\\",\\\"is\\\":\\\"Icelandic\\\",\\\"id\\\":\\\"Indonesian\\\",\\\"it\\\":\\\"Italian\\\",\\\"ja\\\":\\\"Japanese\\\",\\\"ko\\\":\\\"Korean\\\",\\\"la\\\":\\\"Latin\\\",\\\"lv\\\":\\\"Latvian\\\",\\\"mk\\\":\\\"Macedonian\\\",\\\"no\\\":\\\"Norwegian\\\",\\\"pl\\\":\\\"Polish\\\",\\\"pt\\\":\\\"Portuguese\\\",\\\"pt-br\\\":\\\"Portuguese (Brazil)\\\",\\\"ro\\\":\\\"Romanian\\\",\\\"ru\\\":\\\"Russian\\\",\\\"sr\\\":\\\"Serbian\\\",\\\"sk\\\":\\\"Slovak\\\",\\\"es\\\":\\\"Spanish\\\",\\\"es-es\\\":\\\"Spanish (Spain)\\\",\\\"es-us\\\":\\\"Spanish (United ...\nassistant: The available languages for text to speech are Afrikaans, Albanian, Arabic, Armenian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Esperanto, Finnish, French, German, Greek, Haitian Creole, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Korean, Latin, Latvian, Macedonian, Norwegian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Spanish, Swedish, Turkish, and Vietnamese.\n```",
       *         "evaluating_response": "{\"user_last_input\": \"Could you please provide me with the list of available languages for text to speech? I want to convert a text into speech in different languages and need to know which languages are supported by the API.\\nBegin!\", \"ai_final_response\": \"The available languages for text to speech are Afrikaans, Albanian, Arabic, Armenian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Esperanto, Finnish, French, German, Greek, Haitian Creole, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Korean, Latin, Latvian, Macedonian, Norwegian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Spanish, Swedish, Turkish, and Vietnamese.\", \"asks_and_answers\": [{\"user_ask\": \"Could you please provide me with the list of available languages for text to speech?\", \"answer_or_resolution\": \"The available languages for text to speech are Afrikaans, Albanian, Arabic, Armenian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Esperanto, Finnish, French, German, Greek, Haitian Creole, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Korean, Latin, Latvian, Macedonian, Norwegian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Spanish, Swedish, Turkish, and Vietnamese.\", \"tools_input_output\": [\"{'arguments': '{}', 'name': 'get_language_for_text_to_speech'}\", \"{\\\"error\\\": \\\"\\\", \\\"response\\\": \\\"{\\\\\\\"af\\\\\\\":\\\\\\\"Afrikaans\\\\\\\",\\\\\\\"sq\\\\\\\":\\\\\\\"Albanian\\\\\\\",\\\\\\\"ar\\\\\\\":\\\\\\\"Arabic\\\\\\\",\\\\\\\"hy\\\\\\\":\\\\\\\"Armenian\\\\\\\",\\\\\\\"ca\\\\\\\":\\\\\\\"Catalan\\\\\\\",\\\\\\\"zh\\\\\\\":\\\\\\\"Chinese\\\\\\\",\\\\\\\"zh-cn\\\\\\\":\\\\\\\"Chinese (Mandarin/China)\\\\\\\",\\\\\\\"zh-tw\\\\\\\":\\\\\\\"Chinese (Mandarin/Taiwan)\\\\\\\",\\\\\\\"zh-yue\\\\\\\":\\\\\\\"Chinese (Cantonese)\\\\\\\",\\\\\\\"hr\\\\\\\":\\\\\\\"Croatian\\\\\\\",\\\\\\\"cs\\\\\\\":\\\\\\\"Czech\\\\\\\",\\\\\\\"da\\\\\\\":\\\\\\\"Danish\\\\\\\",\\\\\\\"nl\\\\\\\":\\\\\\\"Dutch\\\\\\\",\\\\\\\"en\\\\\\\":\\\\\\\"English\\\\\\\",\\\\\\\"en-au\\\\\\\":\\\\\\\"English (Australia)\\\\\\\",\\\\\\\"en-uk\\\\\\\":\\\\\\\"English (United Kingdom)\\\\\\\",\\\\\\\"en-us\\\\\\\":\\\\\\\"English (United States)\\\\\\\",\\\\\\\"eo\\\\\\\":\\\\\\\"Esperanto\\\\\\\",\\\\\\\"fi\\\\\\\":\\\\\\\"Finnish\\\\\\\",\\\\\\\"fr\\\\\\\":\\\\\\\"French\\\\\\\",\\\\\\\"de\\\\\\\":\\\\\\\"German\\\\\\\",\\\\\\\"el\\\\\\\":\\\\\\\"Greek\\\\\\\",\\\\\\\"ht\\\\\\\":\\\\\\\"Haitian Creole\\\\\\\",\\\\\\\"hi\\\\\\\":\\\\\\\"Hindi\\\\\\\",\\\\\\\"hu\\\\\\\":\\\\\\\"Hungarian\\\\\\\",\\\\\\\"is\\\\\\\":\\\\\\\"Icelandic\\\\\\\",\\\\\\\"id\\\\\\\":\\\\\\\"Indonesian\\\\\\\",\\\\\\\"it\\\\\\\":\\\\\\\"Italian\\\\\\\",\\\\\\\"ja\\\\\\\":\\\\\\\"Japanese\\\\\\\",\\\\\\\"ko\\\\\\\":\\\\\\\"Korean\\\\\\\",\\\\\\\"la\\\\\\\":\\\\\\\"Latin\\\\\\\",\\\\\\\"lv\\\\\\\":\\\\\\\"Latvian\\\\\\\",\\\\\\\"mk\\\\\\\":\\\\\\\"Macedonian\\\\\\\",\\\\\\\"no\\\\\\\":\\\\\\\"Norwegian\\\\\\\",\\\\\\\"pl\\\\\\\":\\\\\\\"Polish\\\\\\\",\\\\\\\"pt\\\\\\\":\\\\\\\"Portuguese\\\\\\\",\\\\\\\"pt-br\\\\\\\":\\\\\\\"Portuguese (Brazil)\\\\\\\",\\\\\\\"ro\\\\\\\":\\\\\\\"Romanian\\\\\\\",\\\\\\\"ru\\\\\\\":\\\\\\\"Russian\\\\\\\",\\\\\\\"sr\\\\\\\":\\\\\\\"Serbian\\\\\\\",\\\\\\\"sk\\\\\\\":\\\\\\\"Slovak\\\\\\\",\\\\\\\"es\\\\\\\":\\\\\\\"Spanish\\\\\\\",\\\\\\\"es-es\\\\\\\":\\\\\\\"Spanish (Spain)\\\\\\\",\\\\\\\"es-us\\\\\\\":\\\\\\\"Spanish (United...\"], \"properties\": {\"factually_wrong\": false, \"addresses_different_ask\": false, \"not_adherent_to_tools_output\": true, \"mentions_inability\": false, \"mentions_unsuccessful_attempt\": false}, \"boolean_properties\": [false, false, true, false, false], \"answer_successful\": false}], \"ai_turn_is_successful\": false, \"explanation\": \"The provided answer was not successful because it was not adherent to the tool's output. Some languages and dialects, such as 'Chinese (Mandarin/China)', 'Chinese (Mandarin/Taiwan)', 'Chinese (Cantonese)', 'English (Australia)', 'English (United Kingdom)', 'English (United States)', 'Portuguese (Brazil)', 'Spanish (Spain)', and 'Spanish (United States)' specified in the API response were omitted in the final response to the user.\"}"
       *       }
       *     ]
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** AggregateMetrics */
    AggregateMetrics: {
      /** Average Agentic Workflow Success */
      average_agentic_workflow_success?: number | null;
      /** Average Completeness Gpt */
      average_completeness_gpt?: number | null;
      /** Average Factuality */
      average_factuality?: number | null;
      /** Average Groundedness */
      average_groundedness?: number | null;
      /** Average Input Sexist */
      average_input_sexist?: number | null;
      /** Average Input Token Length */
      average_input_token_length?: number | null;
      /** Average Input Toxicity */
      average_input_toxicity?: number | null;
      /** Average Instruction Adherence */
      average_instruction_adherence?: number | null;
      /** Average Latency */
      average_latency?: number | null;
      /** Average Output Token Length */
      average_output_token_length?: number | null;
      /** Average Prompt Perplexity */
      average_prompt_perplexity?: number | null;
      /** Average Retriever Attribution */
      average_retriever_attribution?: number | null;
      /** Average Retriever Utilization */
      average_retriever_utilization?: number | null;
      /** Average Sexist */
      average_sexist?: number | null;
      /** Average Tool Selection Quality */
      average_tool_selection_quality?: number | null;
      /** Average Tool Error Rate */
      average_tool_error_rate?: number | null;
      /** Average Toxicity */
      average_toxicity?: number | null;
      /** Average Total Token Length */
      average_total_token_length?: number | null;
      /**
       * Failures Count
       * @default 0
       */
      failures_count?: number | null;
      /**
       * Requests Count
       * @default 0
       */
      requests_count?: number | null;
      /**
       * Total Cost
       * @default 0
       */
      total_cost?: number | null;
    } & {
      [key: string]: unknown;
    };
    /**
     * Aggregator
     * @enum {string}
     */
    Aggregator: 'count' | 'sum' | 'avg' | 'max' | 'min';
    /** Alert */
    Alert: {
      /** Alert Title */
      alert_title: string;
      /** Alert Message */
      alert_message: string;
    };
    /** AlertCondition */
    AlertCondition: {
      /** Field */
      field: string;
      /** Aggregation */
      aggregation: components['schemas']['Aggregator'] | string;
      operator: components['schemas']['Operator'];
      /** Value */
      value: number | string;
      /** Filter Value */
      filter_value?: string | number | null;
      filter_operator?: components['schemas']['Operator'] | null;
      /** Window */
      window: number;
      /** @default metric/numeric/1 */
      condition_type?: components['schemas']['AlertConditionType'];
    };
    /**
     * AlertConditionType
     * @enum {string}
     */
    AlertConditionType:
      | 'metric/numeric/1'
      | 'metric/string/1'
      | 'root/numeric/1'
      | 'metric/array_string/1';
    /** AlertConfigurationResponse */
    AlertConfigurationResponse: {
      /** Conditions */
      conditions?: components['schemas']['AlertCondition'][] | null;
      /** Interval */
      interval?: number | null;
      /** Active */
      active?: boolean | null;
      /** Processed By */
      processed_by?: string | null;
      /** Last Triggered */
      last_triggered?: string | null;
      /** Last Sent */
      last_sent?: string | null;
      /** Alert Sent */
      alert_sent?: boolean | null;
      /** Counter Since Last Sent */
      counter_since_last_sent?: number | null;
      /** Counter */
      counter?: number | null;
      schema_version?: components['schemas']['AlertMonitorType'] | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /**
     * AlertImportance
     * @description The importance of the alert.
     * @enum {string}
     */
    AlertImportance: 'high' | 'medium' | 'low';
    /**
     * AlertMonitorType
     * @enum {string}
     */
    AlertMonitorType: 'multi_condition/object/1';
    /** AlertStatusResponse */
    AlertStatusResponse: {
      /** Message */
      message?: string | null;
      /** Status */
      status?: string | null;
      /** Id */
      id?: string | null;
    };
    /** AlertsConfiguration */
    AlertsConfiguration: {
      /** Emails */
      emails?: string[];
      /** Webhooks */
      webhooks?: components['schemas']['Webhook'][];
    };
    /** AnthropicIntegration */
    AnthropicIntegration: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'anthropic';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** AnthropicIntegrationCreate */
    AnthropicIntegrationCreate: {
      /** Token */
      token: string;
    };
    /**
     * ApiKeyAction
     * @enum {string}
     */
    ApiKeyAction: 'update' | 'delete';
    /** ApiKeyDeleteResponse */
    ApiKeyDeleteResponse: {
      /** Message */
      message: string;
    };
    /** ApiKeyLoginRequest */
    ApiKeyLoginRequest: {
      /** Api Key */
      api_key: string;
    };
    /**
     * AuthMethod
     * @enum {string}
     */
    AuthMethod: 'email' | 'google' | 'github' | 'okta' | 'azure-ad' | 'custom';
    /** AutoGenResult */
    AutoGenResult: {
      /**
       * Metric System Prompt
       * @description System prompt for the metric.
       */
      metric_system_prompt?: string | null;
      /**
       * Metric Description
       * @description Description of what the metric should do.
       */
      metric_description?: string | null;
      /**
       * Value Field Name
       * @description Field name to look for in the chainpoll response, for the rating.
       * @default rating
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @description Chainpoll prompt template.
       */
      template: string;
      /**
       * Metric Few Shot Examples
       * @description Few-shot examples for the metric.
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** AvailableIntegrations */
    AvailableIntegrations: {
      /** Integrations */
      integrations: components['schemas']['IntegrationName'][];
    };
    /** AwsBedrockIntegration */
    AwsBedrockIntegration: {
      /** @default key_secret */
      credential_type?: components['schemas']['AwsCredentialType'];
      /**
       * Region
       * @default us-west-2
       */
      region?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'aws_bedrock';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /**
     * AwsCredentialType
     * @enum {string}
     */
    AwsCredentialType: 'assumed_role' | 'key_secret';
    /** AwsSageMakerIntegration */
    AwsSageMakerIntegration: {
      /** @default key_secret */
      credential_type?: components['schemas']['AwsCredentialType'];
      /**
       * Region
       * @default us-west-2
       */
      region?: string;
      /** Models */
      models?: components['schemas']['Model'][];
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'aws_sagemaker';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** AwsSageMakerIntegrationCreate */
    AwsSageMakerIntegrationCreate: {
      /** Models */
      models?: components['schemas']['Model'][];
      /** @default key_secret */
      credential_type?: components['schemas']['AwsCredentialType'];
      /**
       * Region
       * @default us-west-2
       */
      region?: string;
      /** Token */
      token: {
        [key: string]: string;
      };
    };
    /**
     * AzureAuthenticationType
     * @enum {string}
     */
    AzureAuthenticationType: 'api_key' | 'client_secret' | 'username_password';
    /** AzureIntegration */
    AzureIntegration: {
      /**
       * Proxy
       * @default false
       */
      proxy?: boolean;
      /** Endpoint */
      endpoint: string;
      /** @default api_key */
      authentication_type?: components['schemas']['AzureAuthenticationType'];
      /** Authentication Scope */
      authentication_scope?: string | null;
      /** Headers */
      headers?: {
        [key: string]: string;
      } | null;
      /**
       * Api Version
       * @default 2024-10-21
       */
      api_version?: string;
      /** Azure Deployment */
      azure_deployment?: string | null;
      /**
       * Available Deployments
       * @description The available deployments for this integration. If provided, we will not try to get this list from Azure.
       */
      available_deployments?:
        | components['schemas']['AzureModelDeployment'][]
        | null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'azure';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** AzureIntegrationCreate */
    AzureIntegrationCreate: {
      /**
       * Proxy
       * @default false
       */
      proxy?: boolean;
      /** Endpoint */
      endpoint: string;
      /** @default api_key */
      authentication_type?: components['schemas']['AzureAuthenticationType'];
      /** Authentication Scope */
      authentication_scope?: string | null;
      /** Headers */
      headers?: {
        [key: string]: string;
      } | null;
      /**
       * Api Version
       * @default 2024-10-21
       */
      api_version?: string;
      /** Azure Deployment */
      azure_deployment?: string | null;
      /**
       * Available Deployments
       * @description The available deployments for this integration. If provided, we will not try to get this list from Azure.
       */
      available_deployments?:
        | components['schemas']['AzureModelDeployment'][]
        | null;
      /** Token */
      token: string;
    };
    /** AzureModelDeployment */
    AzureModelDeployment: {
      /**
       * Model
       * @description The name of the model.
       */
      model: string;
      /**
       * Id
       * @description The ID of the deployment.
       */
      id: string;
    };
    /** BBox */
    BBox: {
      /** Id */
      id: number;
      /** Bbox */
      bbox: number[];
      /** Is Active */
      is_active: boolean;
      /** Error Type */
      error_type?: string | null;
      /** Gold */
      gold?: string | null;
      /** Pred */
      pred?: string | null;
      /** X */
      x?: number | null;
      /** Y */
      y?: number | null;
      /** Data Error Potential */
      data_error_potential?: number | null;
      /** Confidence */
      confidence?: number | null;
      /** Is Gold */
      is_gold: boolean;
      /** Is Pred */
      is_pred: boolean;
      /** Tide Match Id */
      tide_match_id?: number | null;
    };
    /**
     * BarChart
     * @description A class to represent a basic bar chart.
     *
     *     labels: List[str] the x axis labels
     *     values: List[int | float] the counts for each bar
     */
    BarChart: {
      /** Labels */
      labels: string[];
      /** Values */
      values: number[];
    };
    /** BaseAwsIntegrationCreate */
    BaseAwsIntegrationCreate: {
      /** @default key_secret */
      credential_type?: components['schemas']['AwsCredentialType'];
      /**
       * Region
       * @default us-west-2
       */
      region?: string;
      /** Token */
      token: {
        [key: string]: string;
      };
    };
    /** BaseGalileoStep */
    BaseGalileoStep: {
      /**
       * @description Type of the step. By default, it is set to workflow.
       * @default workflow
       */
      type?: components['schemas']['NodeType'];
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** Root Workflow Id */
      root_workflow_id?: string | null;
      /** Workflow Id */
      workflow_id?: string | null;
      /** Step Id */
      step_id?: string | null;
      /** Steps */
      steps?: components['schemas']['BaseGalileoStep'][] | null;
      /** Metrics */
      metrics?: components['schemas']['StepMetric'][] | null;
    } & {
      [key: string]: unknown;
    };
    /**
     * BasePromptTemplateResponse
     * @description Response from API to get a prompt template version.
     */
    BasePromptTemplateResponse: {
      /** Name */
      name: string;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Template */
      template: string;
      selected_version: components['schemas']['BasePromptTemplateVersionResponse'];
      /**
       * Selected Version Id
       * Format: uuid4
       */
      selected_version_id: string;
      /** All Versions */
      all_versions?: components['schemas']['BasePromptTemplateVersionResponse'][];
      /** All Available Versions */
      all_available_versions: number[];
      /** Total Versions */
      total_versions: number;
      /** Max Version */
      max_version: number;
    };
    /** BasePromptTemplateVersion */
    BasePromptTemplateVersion: {
      /** Template */
      template: string | components['schemas']['Messages'];
      /** Version */
      version?: number | null;
    };
    /**
     * BasePromptTemplateVersionResponse
     * @description Base response from API for a prompt template version.
     */
    BasePromptTemplateVersionResponse: {
      /** Template */
      template: string | components['schemas']['Messages'];
      /** Version */
      version: number;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
    };
    /** BaseScorer */
    BaseScorer: {
      /**
       * Scorer Name
       * @default
       */
      scorer_name?: string;
      /**
       * Name
       * @default
       */
      name?: string;
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /** Aggregate Keys */
      aggregate_keys?: string[] | null;
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'] | null;
      chainpoll_template?: components['schemas']['ChainPollTemplate'] | null;
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** BaseScorerVersionResponse */
    BaseScorerVersionResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Version */
      version: number;
      generated_scorer?:
        | components['schemas']['GeneratedScorerResponse']
        | null;
      registered_scorer?:
        | components['schemas']['CreateUpdateRegisteredScorerResponse']
        | null;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Version Description */
      version_description?: string | null;
    };
    /** BleuScorer */
    BleuScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'bleu';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** Body_create_or_update_registered_scorers_put */
    Body_create_or_update_registered_scorers_put: {
      /**
       * File
       * Format: binary
       */
      file: string;
    };
    /** Body_login_email_login_post */
    Body_login_email_login_post: {
      /** Grant Type */
      grant_type?: string | null;
      /** Username */
      username: string;
      /** Password */
      password: string;
      /**
       * Scope
       * @default
       */
      scope?: string;
      /** Client Id */
      client_id?: string | null;
      /** Client Secret */
      client_secret?: string | null;
    };
    /** Body_update_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__put */
    Body_update_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__put: {
      /** File */
      file?: string | null;
      /** Column Names */
      column_names?: string[] | null;
    };
    /** Body_upload_dataset_datasets_post */
    Body_upload_dataset_datasets_post: {
      /**
       * File
       * Format: binary
       */
      file: string;
    };
    /** Body_upload_file_projects__project_id__upload_file_post */
    Body_upload_file_projects__project_id__upload_file_post: {
      /**
       * File
       * Format: binary
       */
      file: string;
      /** Upload Metadata */
      upload_metadata: string;
    };
    /** Body_upload_prompt_evaluation_dataset_projects__project_id__prompt_datasets_post */
    Body_upload_prompt_evaluation_dataset_projects__project_id__prompt_datasets_post: {
      /**
       * File
       * Format: binary
       */
      file: string;
    };
    /** BucketedMetrics */
    BucketedMetrics: {
      /** Average Agentic Workflow Success */
      average_agentic_workflow_success?: number | null;
      /** Average Completeness Gpt */
      average_completeness_gpt?: number | null;
      /** Average Factuality */
      average_factuality?: number | null;
      /** Average Groundedness */
      average_groundedness?: number | null;
      /** Average Input Sexist */
      average_input_sexist?: number | null;
      /** Average Input Token Length */
      average_input_token_length?: number | null;
      /** Average Input Toxicity */
      average_input_toxicity?: number | null;
      /** Average Instruction Adherence */
      average_instruction_adherence?: number | null;
      /** Average Latency */
      average_latency?: number | null;
      /** Average Output Token Length */
      average_output_token_length?: number | null;
      /** Average Prompt Perplexity */
      average_prompt_perplexity?: number | null;
      /** Average Retriever Attribution */
      average_retriever_attribution?: number | null;
      /** Average Retriever Utilization */
      average_retriever_utilization?: number | null;
      /** Average Sexist */
      average_sexist?: number | null;
      /** Average Tool Selection Quality */
      average_tool_selection_quality?: number | null;
      /** Average Tool Error Rate */
      average_tool_error_rate?: number | null;
      /** Average Toxicity */
      average_toxicity?: number | null;
      /** Average Total Token Length */
      average_total_token_length?: number | null;
      /**
       * Failures Count
       * @default 0
       */
      failures_count?: number | null;
      /**
       * Requests Count
       * @default 0
       */
      requests_count?: number | null;
      /**
       * Total Cost
       * @default 0
       */
      total_cost?: number | null;
      /**
       * Start Bucket Time
       * Format: date-time
       */
      start_bucket_time: string;
      /**
       * End Bucket Time
       * Format: date-time
       */
      end_bucket_time: string;
      /** Input Tone Values Count */
      input_tone_values_count?: string | null;
      /** Tone Values Count */
      tone_values_count?: string | null;
      /** Pii Values Count */
      pii_values_count?: string | null;
      /** Input Pii Values Count */
      input_pii_values_count?: string | null;
      /** Prompt Injection Values Count */
      prompt_injection_values_count?: string | null;
    } & {
      [key: string]: unknown;
    };
    /** BulkFeedbackRatingCreate */
    BulkFeedbackRatingCreate: {
      /** Explanation */
      explanation?: string | null;
      /** Rating */
      rating:
        | components['schemas']['LikeDislikeRating']
        | components['schemas']['StarRating']
        | components['schemas']['ScoreRating']
        | components['schemas']['TagsRating']
        | components['schemas']['TextRating'];
      /**
       * Feedback Template Id
       * Format: uuid4
       */
      feedback_template_id: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      operation_type: 'create';
    };
    /** BulkFeedbackRatingDelete */
    BulkFeedbackRatingDelete: {
      /**
       * Feedback Template Id
       * Format: uuid4
       */
      feedback_template_id: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      operation_type: 'delete';
    };
    /** BulkFeedbackRatingStatus */
    BulkFeedbackRatingStatus: {
      /** Index */
      index: number;
      operation: components['schemas']['FeedbackRatingOperationType'];
      /** Success */
      success: boolean;
      /** Message */
      message: string | null;
    };
    /** BulkFeedbackRequest */
    BulkFeedbackRequest: {
      /** Operations */
      operations: (
        | components['schemas']['BulkFeedbackRatingCreate']
        | components['schemas']['BulkFeedbackRatingDelete']
      )[];
      /** Selector */
      selector: components['schemas']['IndexSelector'];
    };
    /** CBOClusterRequest */
    CBOClusterRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
    };
    /** CBOClusterResponse */
    CBOClusterResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /** Cbo Clusters */
      cbo_clusters: components['schemas']['CBORunCluster'][];
    };
    /** CBORunCluster */
    CBORunCluster: {
      /** Id */
      id: number;
      /** Labels */
      labels: string[];
      /** Num Samples */
      num_samples: number;
      /** Score */
      score: number;
    };
    /**
     * CartographCluster
     * @description Information about a Cartograph embedding cluster.
     */
    CartographCluster: {
      /** Cluster Id */
      cluster_id: number;
      /** Cluster Size */
      cluster_size: number;
      /** Cluster Description */
      cluster_description: string;
      /** Cluster Summary */
      cluster_summary?: string | null;
      /** Cluster Topic */
      cluster_topic?: string | null;
      /** Average Dep */
      average_dep?: number | null;
      /** Average F1 */
      average_f1?: number | null;
      /** Average Confidence */
      average_confidence?: number | null;
    };
    /** CartographClusterResponse */
    CartographClusterResponse: {
      /** Cartograph Clusters */
      cartograph_clusters: components['schemas']['CartographCluster'][];
    };
    /** CategoricalPromptFilterParam */
    CategoricalPromptFilterParam: {
      /** Column */
      column: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      filter_type: 'category';
      /** Categories */
      categories: string[];
      /**
       * @description Operator to use when checking if the value is in the categories. If None, we default to 'or'.
       * @default any
       */
      operator?: components['schemas']['CategoryFilterOperator'];
    };
    /**
     * CategoryFilterOperator
     * @enum {string}
     */
    CategoryFilterOperator: 'any' | 'all' | 'exact' | 'none';
    /**
     * ChainPollTemplate
     * @description Template for a chainpoll metric prompt,
     *     containing all the info necessary to send a chainpoll prompt.
     */
    ChainPollTemplate: {
      /**
       * Metric System Prompt
       * @description System prompt for the metric.
       */
      metric_system_prompt?: string | null;
      /**
       * Metric Description
       * @description Description of what the metric should do.
       */
      metric_description?: string | null;
      /**
       * Value Field Name
       * @description Field name to look for in the chainpoll response, for the rating.
       * @default rating
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @description Chainpoll prompt template.
       */
      template: string;
      /**
       * Metric Few Shot Examples
       * @description Few-shot examples for the metric.
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** ChainRow */
    ChainRow: {
      /**
       * Node Id
       * Format: uuid
       */
      node_id: string;
      node_type: components['schemas']['NodeType'];
      /** Node Name */
      node_name?: string | null;
      /**
       * Node Input
       * @default
       */
      node_input?: string;
      /**
       * Node Output
       * @default
       */
      node_output?: string;
      /** Tools */
      tools?: string | null;
      /**
       * Chain Root Id
       * Format: uuid
       */
      chain_root_id: string;
      /** Chain Id */
      chain_id?: string | null;
      /**
       * Step
       * @default 0
       */
      step?: number;
      /**
       * Has Children
       * @default false
       */
      has_children?: boolean;
      /** Inputs */
      inputs?: Record<string, never> | null;
      /** Prompt */
      prompt?: string | null;
      /** Response */
      response?: string | null;
      /** Creation Timestamp */
      creation_timestamp?: number;
      /**
       * Finish Reason
       * @default
       */
      finish_reason?: string;
      /** Latency */
      latency?: number | null;
      /**
       * Query Input Tokens
       * @default 0
       */
      query_input_tokens?: number;
      /**
       * Query Output Tokens
       * @default 0
       */
      query_output_tokens?: number;
      /**
       * Query Total Tokens
       * @default 0
       */
      query_total_tokens?: number;
      /** Params */
      params?: Record<string, never>;
      /** Expected Output */
      expected_output?: string | null;
    };
    /** ChainStep */
    ChainStep: {
      /**
       * @description Type of the step. By default, it is set to chain. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'chain';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Steps
       * @description Steps in the workflow.
       */
      steps?: (
        | components['schemas']['WorkflowStep']
        | components['schemas']['ChainStep']
        | components['schemas']['LlmStep']
        | components['schemas']['RetrieverStep']
        | components['schemas']['ToolStep']
        | components['schemas']['AgentStep']
      )[];
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildren'] | null;
    };
    /** Changes */
    Changes: {
      /** Features */
      features?: string[];
      /** Fixes */
      fixes?: string[];
      /** Breaking */
      breaking?: string[];
      /** Miscellaneous */
      miscellaneous?: string[];
    };
    /** ChunkAttributionUtilizationScorer */
    ChunkAttributionUtilizationScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'chunk_attribution_utilization';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default luna
       * @enum {string}
       */
      type?: 'luna' | 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
    };
    /** ChunkAttributionUtilizationTemplate */
    ChunkAttributionUtilizationTemplate: {
      /**
       * Metric System Prompt
       * @description System prompt for the metric.
       */
      metric_system_prompt?: string | null;
      /**
       * Metric Description
       * @description Description of what the metric should do.
       */
      metric_description?: string | null;
      /**
       * Value Field Name
       * @description Field name to look for in the chainpoll response, for the rating.
       * @default rating
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default I asked someone to answer a question based on one or more documents. You will tell me which of the documents their answer was sourced from, and which specific sentences from the documents they used.
       *
       *     Here are the documents, with each document split up into sentences. Each sentence is given a unique key, such as '0a' for the first sentence of Document 0. You'll use these keys in your response to identify which sentences were used.
       *
       *     ```
       *     {chunks}
       *     ```
       *
       *     The question was:
       *
       *     ```
       *     {question}
       *     ```
       *
       *     Their response was:
       *
       *     ```
       *     {response}
       *     ```
       *
       *     Respond with a JSON object matching this schema:
       *
       *     ```
       *     {{
       *       "source_sentence_keys": [string]
       *     }}
       *     ```
       *
       *     The source_sentence_keys field is a list identifying the sentences in the documents that were used to construct the answer. Each entry MUST be a sentence key, such as '0a', that appears in the document list above. Include the key of every sentence that was used to construct the answer, even if it was not used in its entirety. Omit keys for sentences that were not used, and could have been removed from the document without affecting the answer.
       *
       *     You must respond with a valid JSON string.
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @description Few-shot examples for the metric.
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** Circle */
    Circle: {
      /** X */
      x: number;
      /** Y */
      y: number;
      /** Radius */
      radius: number;
    };
    /**
     * CollaboratorRole
     * @enum {string}
     */
    CollaboratorRole: 'owner' | 'editor' | 'annotator' | 'viewer';
    /** CollaboratorRoleInfo */
    CollaboratorRoleInfo: {
      name: components['schemas']['CollaboratorRole'];
      /** Display Name */
      display_name: string;
      /** Description */
      description: string;
    };
    /** CollaboratorUpdate */
    CollaboratorUpdate: {
      role: components['schemas']['CollaboratorRole'];
    };
    /**
     * ColumnCategory
     * @enum {string}
     */
    ColumnCategory: 'standard' | 'metric' | 'user_metadata';
    /**
     * CommunityResponse
     * @description See `rungalileo.schemas.content.insights.Community` for details on Communities.
     *
     *     Before returning the results to the UI, we scale the continuous community score to
     *     an int for better interpretability for the user.
     *
     *     0-0.03 = 1
     *     0.03-0.07 = 2
     *     0.07-0.15 = 3
     *     0.15-0.2=4
     *     0.2=5
     */
    CommunityResponse: {
      /** Score */
      score: number;
      /** Labels */
      labels: string[];
      /** Num Samples */
      num_samples: number;
    };
    /** CompareRunsResponse */
    CompareRunsResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      split: components['schemas']['Split'];
      /** Runs */
      runs: components['schemas']['ProjectRunSummary'][];
    };
    /** CompletenessScorer */
    CompletenessScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'completeness';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default luna
       * @enum {string}
       */
      type?: 'luna' | 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /** CompletenessTemplate */
    CompletenessTemplate: {
      /**
       * Metric System Prompt
       * @description System prompt for the metric.
       */
      metric_system_prompt?: string | null;
      /**
       * Metric Description
       * @description Description of what the metric should do.
       */
      metric_description?: string | null;
      /**
       * Value Field Name
       * @default completeness
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default I asked someone to answer a question based on one or more documents. On a scale of 0 to 1, tell me how well their response covered the relevant information from the documents.
       *
       *     Here is what I said to them, as a JSON string:
       *
       *     ```
       *     {query_json}
       *     ```
       *
       *     Here is what they told me, as a JSON string:
       *
       *     ```
       *     {response_json}
       *     ```
       *
       *     Respond in the following JSON format:
       *
       *     ```
       *     {{
       *         "explanation": string,
       *         "completeness": number
       *     }}
       *     ```
       *
       *     "explanation": A string with your step-by-step reasoning process. List out each piece of information covered in the documents. For each one, explain why it was or was not relevant to the question, and how well the response covered it. Do *not* give an overall assessment of the response here, just think step by step about each piece of information, one at a time. Present your work in a document-by-document format, considering each document separately, ensure the value is a valid string.
       *
       *     "completeness": A floating-point number rating the Completeness of the response on a scale of 0 to 1. This number should equal the amount of relevant information that was comprehensively covered in the response, divided by the total amount of relevant information in the documents.
       *
       *     You must respond with a valid JSON string.
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @description Few-shot examples for the metric.
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** CompositeProjectSettings */
    CompositeProjectSettings: {
      scorers_config?: components['schemas']['ScorersConfig'] | null;
      /** Metric Weights Configuration */
      metric_weights_configuration?: {
        [key: string]: components['schemas']['MetricWeight'];
      } | null;
      alerts_configuration?:
        | components['schemas']['AlertsConfiguration']
        | null;
      scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Registered Scorers Configuration */
      registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Generated Scorers Configuration */
      generated_scorers_configuration?:
        | components['schemas']['GeneratedScorerConfig'][]
        | null;
      /** Customized Scorers Configuration */
      customized_scorers_configuration?:
        | components['schemas']['CustomizedScorer'][]
        | null;
    };
    /** ContentRequest */
    ContentRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
    };
    /** ContextAdherenceScorer */
    ContextAdherenceScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'context_adherence';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default luna
       * @enum {string}
       */
      type?: 'luna' | 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /** ContextRelevanceScorer */
    ContextRelevanceScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'context_relevance';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** CorrectnessScorer */
    CorrectnessScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'correctness';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default plus
       * @constant
       */
      type?: 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /** CreateAlertConfigurationRequest */
    CreateAlertConfigurationRequest: {
      /** Conditions */
      conditions: components['schemas']['AlertCondition'][];
      /** Interval */
      interval: number;
      /** @default multi_condition/object/1 */
      schema_version?: components['schemas']['AlertMonitorType'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
    };
    /** CreateApiKeyRequest */
    CreateApiKeyRequest: {
      /** Description */
      description: string;
      /**
       * Expires At
       * @description Expiry date for the API key
       */
      expires_at?: string | null;
      /** Project Id */
      project_id?: string | null;
      project_role?: components['schemas']['CollaboratorRole'] | null;
    };
    /** CreateApiKeyResponse */
    CreateApiKeyResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Last Used */
      last_used?: string | null;
      /** Project Id */
      project_id?: string | null;
      project_role?: components['schemas']['CollaboratorRole'] | null;
      /** Description */
      description: string;
      /**
       * Expires At
       * @description Expiry date for the API key
       */
      expires_at?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Truncated */
      truncated: string;
      /** Api Key */
      api_key: string;
    };
    /** CreateComputeScoreRequest */
    CreateComputeScoreRequest: {
      scorers_config: components['schemas']['ScorersConfig'];
      /** Recompute Settings */
      recompute_settings:
        | components['schemas']['RecomputeSettingsRuns']
        | components['schemas']['RecomputeSettingsProject']
        | components['schemas']['promptgalileo__schemas__metric_critique__RecomputeSettingsObserve'];
    };
    /** CreateGeneratedScorerRequest */
    CreateGeneratedScorerRequest: {
      /** Name */
      name: string;
      /** Instructions */
      instructions: string;
      chain_poll_template: components['schemas']['ChainPollTemplate'];
      /** Scoreable Node Types */
      scoreable_node_types?: components['schemas']['NodeType'][] | null;
      scorer_configuration?:
        | components['schemas']['GeneratedScorerConfiguration']
        | null;
    };
    /** CreateJobRequest */
    CreateJobRequest: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Job Id */
      job_id?: string | null;
      /**
       * Job Name
       * @default default
       */
      job_name?: string;
      /**
       * Should Retry
       * @default true
       */
      should_retry?: boolean;
      /** User Id */
      user_id?: string | null;
      task_type?: components['schemas']['TaskType'] | null;
      /** Labels */
      labels?: string[][] | string[];
      /** Ner Labels */
      ner_labels?: string[] | null;
      /** Tasks */
      tasks?: string[] | null;
      /**
       * Non Inference Logged
       * @default false
       */
      non_inference_logged?: boolean;
      /** Migration Name */
      migration_name?: string | null;
      /**
       * Xray
       * @default true
       */
      xray?: boolean;
      /**
       * Process Existing Inference Runs
       * @default false
       */
      process_existing_inference_runs?: boolean;
      /** Feature Names */
      feature_names?: string[] | null;
      /** Prompt Dataset Id */
      prompt_dataset_id?: string | null;
      /** Dataset Id */
      dataset_id?: string | null;
      /** Dataset Version Index */
      dataset_version_index?: number | null;
      /** Prompt Template Version Id */
      prompt_template_version_id?: string | null;
      /** Monitor Batch Id */
      monitor_batch_id?: string | null;
      /** Protect Trace Id */
      protect_trace_id?: string | null;
      /** Protect Scorer Payload */
      protect_scorer_payload?: string | null;
      prompt_settings?: components['schemas']['PromptRunSettings'] | null;
      /**
       * Scorers
       * @description For G2.0 we send all scorers as ScorerConfig, for G1.0 we send preset scorers  as GalileoScorer
       */
      scorers?:
        | components['schemas']['ScorerConfig'][]
        | (
            | components['schemas']['AgenticWorkflowSuccessScorer']
            | components['schemas']['BleuScorer']
            | components['schemas']['ChunkAttributionUtilizationScorer']
            | components['schemas']['CompletenessScorer']
            | components['schemas']['ContextAdherenceScorer']
            | components['schemas']['ContextRelevanceScorer']
            | components['schemas']['CorrectnessScorer']
            | components['schemas']['GroundTruthAdherenceScorer']
            | components['schemas']['InputPIIScorer']
            | components['schemas']['InputSexistScorer']
            | components['schemas']['InputToneScorer']
            | components['schemas']['InputToxicityScorer']
            | components['schemas']['InstructionAdherenceScorer']
            | components['schemas']['OutputPIIScorer']
            | components['schemas']['OutputSexistScorer']
            | components['schemas']['OutputToneScorer']
            | components['schemas']['OutputToxicityScorer']
            | components['schemas']['PromptInjectionScorer']
            | components['schemas']['PromptPerplexityScorer']
            | components['schemas']['RougeScorer']
            | components['schemas']['ToolErrorRateScorer']
            | components['schemas']['ToolSelectionQualityScorer']
            | components['schemas']['UncertaintyScorer']
          )[]
        | null;
      /** Prompt Registered Scorers Configuration */
      prompt_registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Prompt Generated Scorers Configuration */
      prompt_generated_scorers_configuration?: string[] | null;
      prompt_scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Prompt Customized Scorers Configuration */
      prompt_customized_scorers_configuration?:
        | (
            | components['schemas']['CustomizedAgenticWorkflowSuccessGPTScorer']
            | components['schemas']['CustomizedChunkAttributionUtilizationGPTScorer']
            | components['schemas']['CustomizedCompletenessGPTScorer']
            | components['schemas']['CustomizedFactualityGPTScorer']
            | components['schemas']['CustomizedGroundednessGPTScorer']
            | components['schemas']['CustomizedInstructionAdherenceGPTScorer']
            | components['schemas']['CustomizedGroundTruthAdherenceGPTScorer']
            | components['schemas']['CustomizedToolSelectionQualityGPTScorer']
            | components['schemas']['CustomizedToolErrorRateGPTScorer']
          )[]
        | null;
      prompt_scorer_settings?: components['schemas']['BaseScorer'] | null;
      prompt_optimization_configuration?:
        | components['schemas']['PromptOptimizationConfiguration']
        | null;
      /**
       * Epoch
       * @default 0
       */
      epoch?: number;
      metric_critique_configuration?:
        | components['schemas']['MetricCritiqueJobConfiguration']
        | null;
    };
    /** CreateJobResponse */
    CreateJobResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Job Id */
      job_id?: string | null;
      /**
       * Job Name
       * @default default
       */
      job_name?: string;
      /**
       * Should Retry
       * @default true
       */
      should_retry?: boolean;
      /** User Id */
      user_id?: string | null;
      task_type?: components['schemas']['TaskType'] | null;
      /** Labels */
      labels?: string[][] | string[];
      /** Ner Labels */
      ner_labels?: string[] | null;
      /** Tasks */
      tasks?: string[] | null;
      /**
       * Non Inference Logged
       * @default false
       */
      non_inference_logged?: boolean;
      /** Migration Name */
      migration_name?: string | null;
      /**
       * Xray
       * @default true
       */
      xray?: boolean;
      /**
       * Process Existing Inference Runs
       * @default false
       */
      process_existing_inference_runs?: boolean;
      /** Feature Names */
      feature_names?: string[] | null;
      /** Prompt Dataset Id */
      prompt_dataset_id?: string | null;
      /** Dataset Id */
      dataset_id?: string | null;
      /** Dataset Version Index */
      dataset_version_index?: number | null;
      /** Prompt Template Version Id */
      prompt_template_version_id?: string | null;
      /** Monitor Batch Id */
      monitor_batch_id?: string | null;
      /** Protect Trace Id */
      protect_trace_id?: string | null;
      /** Protect Scorer Payload */
      protect_scorer_payload?: string | null;
      prompt_settings?: components['schemas']['PromptRunSettings'] | null;
      /**
       * Scorers
       * @description For G2.0 we send all scorers as ScorerConfig, for G1.0 we send preset scorers  as GalileoScorer
       */
      scorers?:
        | components['schemas']['ScorerConfig'][]
        | (
            | components['schemas']['AgenticWorkflowSuccessScorer']
            | components['schemas']['BleuScorer']
            | components['schemas']['ChunkAttributionUtilizationScorer']
            | components['schemas']['CompletenessScorer']
            | components['schemas']['ContextAdherenceScorer']
            | components['schemas']['ContextRelevanceScorer']
            | components['schemas']['CorrectnessScorer']
            | components['schemas']['GroundTruthAdherenceScorer']
            | components['schemas']['InputPIIScorer']
            | components['schemas']['InputSexistScorer']
            | components['schemas']['InputToneScorer']
            | components['schemas']['InputToxicityScorer']
            | components['schemas']['InstructionAdherenceScorer']
            | components['schemas']['OutputPIIScorer']
            | components['schemas']['OutputSexistScorer']
            | components['schemas']['OutputToneScorer']
            | components['schemas']['OutputToxicityScorer']
            | components['schemas']['PromptInjectionScorer']
            | components['schemas']['PromptPerplexityScorer']
            | components['schemas']['RougeScorer']
            | components['schemas']['ToolErrorRateScorer']
            | components['schemas']['ToolSelectionQualityScorer']
            | components['schemas']['UncertaintyScorer']
          )[]
        | null;
      /** Prompt Registered Scorers Configuration */
      prompt_registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Prompt Generated Scorers Configuration */
      prompt_generated_scorers_configuration?: string[] | null;
      prompt_scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Prompt Customized Scorers Configuration */
      prompt_customized_scorers_configuration?:
        | (
            | components['schemas']['CustomizedAgenticWorkflowSuccessGPTScorer']
            | components['schemas']['CustomizedChunkAttributionUtilizationGPTScorer']
            | components['schemas']['CustomizedCompletenessGPTScorer']
            | components['schemas']['CustomizedFactualityGPTScorer']
            | components['schemas']['CustomizedGroundednessGPTScorer']
            | components['schemas']['CustomizedInstructionAdherenceGPTScorer']
            | components['schemas']['CustomizedGroundTruthAdherenceGPTScorer']
            | components['schemas']['CustomizedToolSelectionQualityGPTScorer']
            | components['schemas']['CustomizedToolErrorRateGPTScorer']
          )[]
        | null;
      prompt_scorer_settings?: components['schemas']['BaseScorer'] | null;
      prompt_optimization_configuration?:
        | components['schemas']['PromptOptimizationConfiguration']
        | null;
      /**
       * Epoch
       * @default 0
       */
      epoch?: number;
      metric_critique_configuration?:
        | components['schemas']['MetricCritiqueJobConfiguration']
        | null;
      /** Message */
      message: string;
      /** Link */
      link: string;
    };
    /** CreateLLMScorerVersionRequest */
    CreateLLMScorerVersionRequest: {
      /** Version Description */
      version_description?: string | null;
      /** Instructions */
      instructions: string;
      chain_poll_template: components['schemas']['ChainPollTemplate'];
    };
    /** CreateMetricCritiqueRequest */
    CreateMetricCritiqueRequest: {
      /**
       * Id
       * @description The id of the metric critique if it's being updated. None if it's a new critique.
       */
      id?: string | null;
      /** Run Id */
      run_id: string | null;
      /** Row Id */
      row_id: string | number;
      /** Critique */
      critique: string;
      /**
       * Intended Value
       * @description Set to opposite of actual value for new critiques, and set as same as existing critique intended value for updates.
       */
      intended_value: boolean;
    };
    /** CreateMetricCritiquesRequest */
    CreateMetricCritiquesRequest: {
      /** Critiques */
      critiques: components['schemas']['CreateMetricCritiqueRequest'][];
      /** Metric */
      metric: string;
      /** Recompute Settings */
      recompute_settings?:
        | (
            | components['schemas']['RecomputeSettingsRuns']
            | components['schemas']['RecomputeSettingsProject']
            | components['schemas']['api__schemas__metric_critique__RecomputeSettingsObserve']
          )
        | null;
    };
    /**
     * CreatePromptTemplateWithVersionRequestBody
     * @description Body to create a new prompt template with version.
     *
     *     This is only used for parsing the body from the request.
     */
    CreatePromptTemplateWithVersionRequestBody: {
      /** Template */
      template: string | components['schemas']['Messages'];
      /** Version */
      version?: number | null;
      /** Name */
      name: string;
    };
    /** CreateRunResponse */
    CreateRunResponse: {
      /** Name */
      name?: string | null;
      /** Project Id */
      project_id?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Num Samples */
      num_samples: number;
      /** Winner */
      winner: boolean;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      task_type?: components['schemas']['TaskType'] | null;
      /**
       * Last Updated By
       * Format: uuid4
       */
      last_updated_by: string;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagDB'][];
    };
    /** CreateScorerRequest */
    CreateScorerRequest: {
      /** Name */
      name: string;
      /**
       * Description
       * @default
       */
      description?: string;
      /** Tags */
      tags?: string[];
      defaults?: components['schemas']['ScorerDefaults'] | null;
      scorer_type: components['schemas']['ScorerTypes'];
    };
    /** CreateSignupLinkResponse */
    CreateSignupLinkResponse: {
      /** Signup Url */
      signup_url: string;
    };
    /** CreateUpdateRegisteredScorerResponse */
    CreateUpdateRegisteredScorerResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Name */
      name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Score Type */
      score_type: string | null;
      data_type: components['schemas']['DataTypeOptions'] | null;
      /** Scoreable Node Types */
      scoreable_node_types: string[] | null;
    };
    /** CreateUserResponse */
    CreateUserResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /** Email Is Verified */
      email_is_verified?: boolean | null;
      /**
       * Organization Id
       * Format: uuid4
       */
      organization_id: string;
      /** Organization Name */
      organization_name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** CurrentUserDB */
    CurrentUserDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /** Email Is Verified */
      email_is_verified?: boolean | null;
      /**
       * Organization Id
       * Format: uuid4
       */
      organization_id: string;
      /** Organization Name */
      organization_name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /**
       * Generic Permissions
       * @default []
       */
      generic_permissions?: components['schemas']['GenericPermission'][];
    };
    /** CustomizedAgenticWorkflowSuccessGPTScorer */
    CustomizedAgenticWorkflowSuccessGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_agentic_workflow_success';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default agentic_workflow_success
       * @constant
       */
      name?: 'agentic_workflow_success';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_agentic_workflow_success"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      /** @default {
       *       "logprobs": true,
       *       "top_logprobs": 5,
       *       "echo": false,
       *       "n": 5,
       *       "model_alias": "GPT-4o mini",
       *       "temperature": 1,
       *       "max_tokens": -1,
       *       "top_p": 1,
       *       "top_k": 40,
       *       "frequency_penalty": 0,
       *       "presence_penalty": 0
       *     } */
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "You will receive the chat history from a chatbot application between a user and an AI. At the end of the chat history, it is AIs turn to act.\n\nIn the chat history, the user can either ask questions, which are answered with words, or make requests that require calling tools and actions to resolve. Sometimes these are given as orders, and these should be treated as questions or requests. The AI's turn may involve several steps which are a combination of internal reflections, planning, selecting tools, calling tools, and ends with the AI replying to the user. \nYour task involves the following steps:\n\n########################\n\nStep 1: user_last_input and user_ask\n\nFirst, identify the user's last input in the chat history. From this input, create a list with one entry for each user question, request, or order. If there are no user asks in the user's last input, leave the list empty and skip ahead, considering the AI's turn successful.\n\n########################\n\nStep 2: ai_final_response and answer_or_resolution\n\nIdentify the AI's final response to the user: it is the very last step in the AI's turn.\n\nFor every user_ask, focus on ai_final_response and try to extract either an answer or a resolution using the following definitions:\n- An answer is a part of the AI's final response that directly responds to all or part of a user's question, or asks for further information or clarification.\n- A resolution is a part of the AI's final response that confirms a successful resolution, or asks for further information or clarification in order to answer a user's request.\n\nIf the AI's final response does not address the user ask, simply write \"No answer or resolution provided in the final response\". Do not shorten the answer or resolution; provide the entire relevant part.\n\n########################\n\nStep 3: tools_input_output\n\nExamine every step in the AI's turn and identify which tool/function step seemingly contributed to creating the answer or resolution. Every tool call should be linked to a user ask. If an AI step immediately before or after the tool call mentions planning or using a tool for answering a user ask, the tool call should be associated with that user ask. If the answer or resolution strongly resembles the output of a tool, the tool call should also be associated with that user ask.\n\nCreate a list containing the concatenation of the entire input and output of every tool used in formulating the answer or resolution. The tool input is listed as an AI step before calling the tool, and the tool output is listed as a tool step.\n\n########################\n\nStep 4: properties, boolean_properties and answer_successful\n\nFor every answer or resolution from Step 2, check the following properties one by one to determine which are satisfied:\n- factually_wrong: the answer contains factual errors.\n- addresses_different_ask: the answer or resolution addresses a slightly different user ask (make sure to differentiate this from asking clarifying questions related to the current ask).\n- not_adherent_to_tools_output: the answer or resolution includes citations from a tool's output, but some are wrongly copied or attributed.\n- mentions_inability: the answer or resolution mentions an inability to complete the user ask.\n- mentions_unsuccessful_attempt: the answer or resolution mentions an unsuccessful or failed attempt to complete the user ask.\n\nThen copy all the properties (only the boolean value) in the list boolean_properties.\n\nFinally, set answer_successful to `false` if any entry in boolean_properties is set to `true`, otherwise set answer_successful to `true`.\n\n########################\n\nYou must respond in the following JSON format:\n```\n{\n    \"user_last_input\": string,\n    \"ai_final_response\": string,\n    \"asks_and_answers\": list[dict],\n    \"ai_turn_is_successful\": boolean,\n    \"explanation\": string\n}\n```\n\nYour tasks are defined as follows:\n\n- **\"asks_and_answers\"**: Perform all the tasks described in the steps above. Your answer should be a list where each user ask appears as:\n\n```\n{\n    \"user_ask\": string,\n    \"answer_or_resolution\": string,\n    \"tools_input_output\": list[string],\n    \"properties\" : {\n        \"factually_wrong\": boolean,\n        \"addresses_different_ask\": boolean,\n        \"not_adherent_to_tools_output\": boolean,\n        \"mentions_inability\": boolean,\n        \"mentions_unsuccessful_attempt\": boolean\n    },\n    \"boolean_properties\": list[boolean],\n    \"answer_successful\": boolean\n}\n```\n\n- **\"ai_turn_is_successful\"**: Respond `true` if at least one answer_successful is True, otherwise respond `false`.\n\n- **\"explanation\"**: If at least one answer was considered successful, explain why. Otherwise explain why all answers were not successful.\n\nYou must respond with a valid JSON object; be sure to escape special characters.",
       *       "metric_description": "I have a multi-turn chatbot application where the assistant is an agent that has access to tools. An assistant workflow can involves possibly multiple tool selections steps, tool calls steps, and finally a reply to the user. I want a metric that assesses whether each assistant's workflow was thoughtfully planned and ended up helping answer the queries.\n",
       *       "value_field_name": "ai_turn_is_successful",
       *       "explanation_field_name": "explanation",
       *       "template": "Chatbot history:\n```\n{query}\n```\n\nAI's turn:\n```\n{response}\n```",
       *       "metric_few_shot_examples": [
       *         {
       *           "evaluating_response": "{\"user_last_input\": \"Can you analyze the given C# code and identify any errors present? Please mention the line numbers where the errors occur, describe their nature, suggest the necessary changes to rectify them and also mention any security vulnerabilities present in the code.\", \"ai_final_response\": \"Sure, please provide the C# code so I can analyze it for errors and security vulnerabilities. <|endoftext|>\", \"asks_and_answers\": [{\"user_ask\": \"Can you analyze the given C# code and identify any errors present? Please mention the line numbers where the errors occur, describe their nature, suggest the necessary changes to rectify them and also mention any security vulnerabilities present in the code.\", \"answer_or_resolution\": \"Sure, please provide the C# code so I can analyze it for errors and security vulnerabilities.\", \"tools_input_output\": [], \"properties\": {\"factually_wrong\": false, \"addresses_different_ask\": false, \"not_adherent_to_tools_output\": false, \"mentions_inability\": false, \"mentions_unsuccessful_attempt\": false}, \"boolean_properties\": [false, false, false, false, false], \"answer_successful\": true}], \"ai_turn_is_successful\": true, \"explanation\": \"The answer was successful because the AI correctly requested further information (the C# code) from the user in order to fulfill the user's request. No errors or issues were present in the response.\"}",
       *           "generation_prompt_and_response": "Chatbot history:\n```\nsystem: You are a helpful assistant, with no access to external functions.\nuser: Can you analyze the given C# code and identify any errors present? Please mention the line numbers where the errors occur, describe their nature, suggest the necessary changes to rectify them and also mention any security vulnerabilities present in the code.\n```\n\nAI's turn:\n```\nassistant: Sure, please provide the C# code so I can analyze it for errors and security vulnerabilities. <|endoftext|>\n```"
       *         },
       *         {
       *           "evaluating_response": "{\"user_last_input\": \"Could you please provide me with the list of available languages for text to speech? I want to convert a text into speech in different languages and need to know which languages are supported by the API.\\nBegin!\", \"ai_final_response\": \"The available languages for text to speech are Afrikaans, Albanian, Arabic, Armenian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Esperanto, Finnish, French, German, Greek, Haitian Creole, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Korean, Latin, Latvian, Macedonian, Norwegian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Spanish, Swedish, Turkish, and Vietnamese.\", \"asks_and_answers\": [{\"user_ask\": \"Could you please provide me with the list of available languages for text to speech?\", \"answer_or_resolution\": \"The available languages for text to speech are Afrikaans, Albanian, Arabic, Armenian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Esperanto, Finnish, French, German, Greek, Haitian Creole, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Korean, Latin, Latvian, Macedonian, Norwegian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Spanish, Swedish, Turkish, and Vietnamese.\", \"tools_input_output\": [\"{'arguments': '{}', 'name': 'get_language_for_text_to_speech'}\", \"{\\\"error\\\": \\\"\\\", \\\"response\\\": \\\"{\\\\\\\"af\\\\\\\":\\\\\\\"Afrikaans\\\\\\\",\\\\\\\"sq\\\\\\\":\\\\\\\"Albanian\\\\\\\",\\\\\\\"ar\\\\\\\":\\\\\\\"Arabic\\\\\\\",\\\\\\\"hy\\\\\\\":\\\\\\\"Armenian\\\\\\\",\\\\\\\"ca\\\\\\\":\\\\\\\"Catalan\\\\\\\",\\\\\\\"zh\\\\\\\":\\\\\\\"Chinese\\\\\\\",\\\\\\\"zh-cn\\\\\\\":\\\\\\\"Chinese (Mandarin/China)\\\\\\\",\\\\\\\"zh-tw\\\\\\\":\\\\\\\"Chinese (Mandarin/Taiwan)\\\\\\\",\\\\\\\"zh-yue\\\\\\\":\\\\\\\"Chinese (Cantonese)\\\\\\\",\\\\\\\"hr\\\\\\\":\\\\\\\"Croatian\\\\\\\",\\\\\\\"cs\\\\\\\":\\\\\\\"Czech\\\\\\\",\\\\\\\"da\\\\\\\":\\\\\\\"Danish\\\\\\\",\\\\\\\"nl\\\\\\\":\\\\\\\"Dutch\\\\\\\",\\\\\\\"en\\\\\\\":\\\\\\\"English\\\\\\\",\\\\\\\"en-au\\\\\\\":\\\\\\\"English (Australia)\\\\\\\",\\\\\\\"en-uk\\\\\\\":\\\\\\\"English (United Kingdom)\\\\\\\",\\\\\\\"en-us\\\\\\\":\\\\\\\"English (United States)\\\\\\\",\\\\\\\"eo\\\\\\\":\\\\\\\"Esperanto\\\\\\\",\\\\\\\"fi\\\\\\\":\\\\\\\"Finnish\\\\\\\",\\\\\\\"fr\\\\\\\":\\\\\\\"French\\\\\\\",\\\\\\\"de\\\\\\\":\\\\\\\"German\\\\\\\",\\\\\\\"el\\\\\\\":\\\\\\\"Greek\\\\\\\",\\\\\\\"ht\\\\\\\":\\\\\\\"Haitian Creole\\\\\\\",\\\\\\\"hi\\\\\\\":\\\\\\\"Hindi\\\\\\\",\\\\\\\"hu\\\\\\\":\\\\\\\"Hungarian\\\\\\\",\\\\\\\"is\\\\\\\":\\\\\\\"Icelandic\\\\\\\",\\\\\\\"id\\\\\\\":\\\\\\\"Indonesian\\\\\\\",\\\\\\\"it\\\\\\\":\\\\\\\"Italian\\\\\\\",\\\\\\\"ja\\\\\\\":\\\\\\\"Japanese\\\\\\\",\\\\\\\"ko\\\\\\\":\\\\\\\"Korean\\\\\\\",\\\\\\\"la\\\\\\\":\\\\\\\"Latin\\\\\\\",\\\\\\\"lv\\\\\\\":\\\\\\\"Latvian\\\\\\\",\\\\\\\"mk\\\\\\\":\\\\\\\"Macedonian\\\\\\\",\\\\\\\"no\\\\\\\":\\\\\\\"Norwegian\\\\\\\",\\\\\\\"pl\\\\\\\":\\\\\\\"Polish\\\\\\\",\\\\\\\"pt\\\\\\\":\\\\\\\"Portuguese\\\\\\\",\\\\\\\"pt-br\\\\\\\":\\\\\\\"Portuguese (Brazil)\\\\\\\",\\\\\\\"ro\\\\\\\":\\\\\\\"Romanian\\\\\\\",\\\\\\\"ru\\\\\\\":\\\\\\\"Russian\\\\\\\",\\\\\\\"sr\\\\\\\":\\\\\\\"Serbian\\\\\\\",\\\\\\\"sk\\\\\\\":\\\\\\\"Slovak\\\\\\\",\\\\\\\"es\\\\\\\":\\\\\\\"Spanish\\\\\\\",\\\\\\\"es-es\\\\\\\":\\\\\\\"Spanish (Spain)\\\\\\\",\\\\\\\"es-us\\\\\\\":\\\\\\\"Spanish (United...\"], \"properties\": {\"factually_wrong\": false, \"addresses_different_ask\": false, \"not_adherent_to_tools_output\": true, \"mentions_inability\": false, \"mentions_unsuccessful_attempt\": false}, \"boolean_properties\": [false, false, true, false, false], \"answer_successful\": false}], \"ai_turn_is_successful\": false, \"explanation\": \"The provided answer was not successful because it was not adherent to the tool's output. Some languages and dialects, such as 'Chinese (Mandarin/China)', 'Chinese (Mandarin/Taiwan)', 'Chinese (Cantonese)', 'English (Australia)', 'English (United Kingdom)', 'English (United States)', 'Portuguese (Brazil)', 'Spanish (Spain)', and 'Spanish (United States)' specified in the API response were omitted in the final response to the user.\"}",
       *           "generation_prompt_and_response": "Chatbot history:\n```\nuser: Could you please provide me with the list of available languages for text to speech? I want to convert a text into speech in different languages and need to know which languages are supported by the API.\nBegin!\n\n```\n\nAI's turn:\n```\nassistant: I am making this API call to get the list of available languages for text to speech, as the user wants to convert text into speech in different languages. By calling the 'get_language_for_text_to_speech' function with no arguments, I can retrieve the supported languages from the API. This will provide me with the necessary information to assist the user in their query.\nassistant: {'arguments': '{}', 'name': 'get_language_for_text_to_speech'}\nfunction: {\"error\": \"\", \"response\": \"{\\\"af\\\":\\\"Afrikaans\\\",\\\"sq\\\":\\\"Albanian\\\",\\\"ar\\\":\\\"Arabic\\\",\\\"hy\\\":\\\"Armenian\\\",\\\"ca\\\":\\\"Catalan\\\",\\\"zh\\\":\\\"Chinese\\\",\\\"zh-cn\\\":\\\"Chinese (Mandarin/China)\\\",\\\"zh-tw\\\":\\\"Chinese (Mandarin/Taiwan)\\\",\\\"zh-yue\\\":\\\"Chinese (Cantonese)\\\",\\\"hr\\\":\\\"Croatian\\\",\\\"cs\\\":\\\"Czech\\\",\\\"da\\\":\\\"Danish\\\",\\\"nl\\\":\\\"Dutch\\\",\\\"en\\\":\\\"English\\\",\\\"en-au\\\":\\\"English (Australia)\\\",\\\"en-uk\\\":\\\"English (United Kingdom)\\\",\\\"en-us\\\":\\\"English (United States)\\\",\\\"eo\\\":\\\"Esperanto\\\",\\\"fi\\\":\\\"Finnish\\\",\\\"fr\\\":\\\"French\\\",\\\"de\\\":\\\"German\\\",\\\"el\\\":\\\"Greek\\\",\\\"ht\\\":\\\"Haitian Creole\\\",\\\"hi\\\":\\\"Hindi\\\",\\\"hu\\\":\\\"Hungarian\\\",\\\"is\\\":\\\"Icelandic\\\",\\\"id\\\":\\\"Indonesian\\\",\\\"it\\\":\\\"Italian\\\",\\\"ja\\\":\\\"Japanese\\\",\\\"ko\\\":\\\"Korean\\\",\\\"la\\\":\\\"Latin\\\",\\\"lv\\\":\\\"Latvian\\\",\\\"mk\\\":\\\"Macedonian\\\",\\\"no\\\":\\\"Norwegian\\\",\\\"pl\\\":\\\"Polish\\\",\\\"pt\\\":\\\"Portuguese\\\",\\\"pt-br\\\":\\\"Portuguese (Brazil)\\\",\\\"ro\\\":\\\"Romanian\\\",\\\"ru\\\":\\\"Russian\\\",\\\"sr\\\":\\\"Serbian\\\",\\\"sk\\\":\\\"Slovak\\\",\\\"es\\\":\\\"Spanish\\\",\\\"es-es\\\":\\\"Spanish (Spain)\\\",\\\"es-us\\\":\\\"Spanish (United ...\nassistant: The available languages for text to speech are Afrikaans, Albanian, Arabic, Armenian, Catalan, Chinese, Croatian, Czech, Danish, Dutch, English, Esperanto, Finnish, French, German, Greek, Haitian Creole, Hindi, Hungarian, Icelandic, Indonesian, Italian, Japanese, Korean, Latin, Latvian, Macedonian, Norwegian, Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Spanish, Swedish, Turkish, and Vietnamese.\n```"
       *         }
       *       ]
       *     } */
      chainpoll_template?: components['schemas']['AgenticWorkflowSuccessTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** CustomizedChunkAttributionUtilizationGPTScorer */
    CustomizedChunkAttributionUtilizationGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_chunk_attribution_utilization_gpt';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default chunk_attribution_utilization
       * @constant
       */
      name?: 'chunk_attribution_utilization';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_chunk_attribution",
       *       "average_chunk_utilization"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "value_field_name": "rating",
       *       "explanation_field_name": "explanation",
       *       "template": "I asked someone to answer a question based on one or more documents. You will tell me which of the documents their answer was sourced from, and which specific sentences from the documents they used.\n\nHere are the documents, with each document split up into sentences. Each sentence is given a unique key, such as '0a' for the first sentence of Document 0. You'll use these keys in your response to identify which sentences were used.\n\n```\n{chunks}\n```\n\nThe question was:\n\n```\n{question}\n```\n\nTheir response was:\n\n```\n{response}\n```\n\nRespond with a JSON object matching this schema:\n\n```\n{{\n  \"source_sentence_keys\": [string]\n}}\n```\n\nThe source_sentence_keys field is a list identifying the sentences in the documents that were used to construct the answer. Each entry MUST be a sentence key, such as '0a', that appears in the document list above. Include the key of every sentence that was used to construct the answer, even if it was not used in its entirety. Omit keys for sentences that were not used, and could have been removed from the document without affecting the answer.\n\nYou must respond with a valid JSON string.",
       *       "metric_few_shot_examples": []
       *     } */
      chainpoll_template?: components['schemas']['ChunkAttributionUtilizationTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** CustomizedCompletenessGPTScorer */
    CustomizedCompletenessGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_completeness_gpt';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default completeness
       * @constant
       */
      name?: 'completeness';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_completeness_gpt"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "value_field_name": "completeness",
       *       "explanation_field_name": "explanation",
       *       "template": "I asked someone to answer a question based on one or more documents. On a scale of 0 to 1, tell me how well their response covered the relevant information from the documents.\n\nHere is what I said to them, as a JSON string:\n\n```\n{query_json}\n```\n\nHere is what they told me, as a JSON string:\n\n```\n{response_json}\n```\n\nRespond in the following JSON format:\n\n```\n{{\n    \"explanation\": string,\n    \"completeness\": number\n}}\n```\n\n\"explanation\": A string with your step-by-step reasoning process. List out each piece of information covered in the documents. For each one, explain why it was or was not relevant to the question, and how well the response covered it. Do *not* give an overall assessment of the response here, just think step by step about each piece of information, one at a time. Present your work in a document-by-document format, considering each document separately, ensure the value is a valid string.\n\n\"completeness\": A floating-point number rating the Completeness of the response on a scale of 0 to 1. This number should equal the amount of relevant information that was comprehensively covered in the response, divided by the total amount of relevant information in the documents.\n\nYou must respond with a valid JSON string.",
       *       "metric_few_shot_examples": []
       *     } */
      chainpoll_template?: components['schemas']['CompletenessTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** CustomizedFactualityGPTScorer */
    CustomizedFactualityGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_factuality';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default correctness
       * @constant
       */
      name?: 'correctness';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_factuality"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "# Task\n\nYou will be given a prompt that was sent to a large language model (LLM), and the LLM's response. Your task is to assess whether the response is factually correct.\n\n## Task output format\n\nYou must respond in the following JSON format:\n\n```\n{\n    \"explanation\": string\n    \"was_factual\": boolean\n}\n```\n\n\"explanation\": Your step-by-step reasoning process. List out the claims made in the response, and for each claim, provide a detailed explanation of why that claim is or is not factual.\n\n\"was_factual\": `true` if the response was completely factually correct according to the instructions above, `false` otherwise.\n\nYou must respond with a valid JSON string.\n\n## Task guidelines\n\n### Input format\n\nIn some cases, the prompt may include multiple messages of chat history. If so, each message will begin with one of the following prefixes:\n\n- \"System: \"\n- \"Human: \"\n- \"AI: \"\n\n### How to determine the value of `was_factual`\n\n- was_factual should be false if anything in the response is factually incorrect, and true otherwise.\n- If the response omits some useful information, but does not include any falsehoods, was_factual should be true.\n- The prompt itself may contain false information. If the response repeats this false information, was_factual should be false. In other words, do not assume that the prompt is factually correct when evaluating the response.\n- If the prompt and response involve a domain where the concept of \"factual accuracy\" doesn't strictly apply, assess whatever quality of the response is most intuitively similar to factual accuracy. For example, if the prompt asks the LLM to write code, assess whether the code is free of syntax errors and implements the intended logic.\n\n### Writing the explanation\n\n- As stated above, a typical explanation should list out the claims made in the response, and for each claim, provide a detailed explanation of why that claim is or is not factual.\n- If the response doesn't make claims per se, break down the response into constituent parts in the most natural way given its content. For example, in code generation tasks, you might break down the response into individual functions or lines of code.\n- Work step by step, and do not give an overall assessment of the response until the end of your explanation.",
       *       "value_field_name": "was_factual",
       *       "explanation_field_name": "explanation",
       *       "template": "The prompt was:\n\n```\n{query}\n```\n\nThe response was:\n\n```\n{response}\n```\n\nRespond with a JSON object having two fields: `explanation` (string) and `was_factual` (boolean). Everything in your response should be valid JSON.\n\nREMEMBER: if the prompt asks the LLM to compose an answer on the basis of a \"context\" or other reference text or texts, you MUST IGNORE these texts when evaluating the response. Evaluate the response as though the reference texts were NOT provided. Do NOT refer to these texts in your evaluation.",
       *       "metric_few_shot_examples": [
       *         {
       *           "evaluating_response": "{\n    \"explanation\": \"The response makes several claims about the meaning of \\\"en passant\\\" in chess, then provides an illustrative example. Let's evaluate the claims first, then the example.\\n\\n# Claims\\n\\n1. The response claims that 'en passant' is a special rule in chess that allows a pawn to capture an enemy pawn that has moved two squares forward from its initial position, as if it had only moved one square forward. This claim is factually correct, as 'en passant' indeed allows for such a capture under specified conditions.\\n\\n2. The response also claims that this capture can only be done on the ensuing move and only if the capturing pawn was on its fifth rank at the time. This is also factually correct, as one of the requirements for the 'en passant' capture is that the capturing pawn must be on the fifth rank when the opponent's pawn moves two squares forward.\\n\\n# Illustrative Example\\n\\nFor the purposes of this metric, we'll say that a chess example like this one is \\\"correct\\\" if\\n\\n- All the moves are valid according to the rules of chess\\n- The example demonstrates what it is intended to demonstrate (in this case, the en passant rule)\\n\\nTo check these conditions, let's waslk through the example one move at a time, with a clear description of the board state after each move.\\n\\n### Initial Position\\nThe game starts with the standard initial setup of the chessboard.\\n\\n### Move 1\\n**1. e4 e5**\\n\\n- **White moves pawn from e2 to e4.**\\n  This opens lines for the bishop and queen and controls the center.\\n- **Black moves pawn from e7 to e5.**\\n  This mirrors White's move, also controlling the center.\\n\\n**Board State:**\\n```\\nr n b q k b n r\\np p p     p p p\\n\\n        P\\n        p\\n\\nP P P     P P P\\nR N B Q K B N R\\n```\\n\\n### Move 2\\n**2. d4 d5**\\n\\n- **White moves pawn from d2 to d4.**\\n  Now, White controls more central space and threatens the pawn on e5.\\n- **Black moves pawn from d7 to d5.**\\n  Black counters by challenging the center with another pawn.\\n\\n**Board State:**\\n```\\nr n b q k b n r\\np p   p   p p p\\n\\n        P\\n  p P p P\\n\\nP   P     P P P\\nR N B Q K B N R\\n```\\n\\n### Move 3\\n**3. exd5 exd4**\\n\\n- **White captures the pawn on d5 with the pawn from e4 (exd5).**\\n  Now White has a pawn on d5.\\n- **Black incorrectly moves to exd4.**\\n  According to the rules of chess, this is an illegal move because the pawn on e5 cannot capture a pawn on d4 directly. The pawn on d4 does not exist; the move should capture diagonally if there is a piece or pawn on d4.\\n\\nSince there is an error in Move 3, the illustrative example is not factually correct according to the criteria listed above. Therefore, the example as a whole is not entirely factually correct.\",\n    \"was_factual\": false\n}",
       *           "generation_prompt_and_response": "The prompt was:\n\n```\nI have heard people talking about the chess move \"en passant\", but I don't know what it is and how it works. Could you explain it to me?\n```\n\nThe response was:\n\n```\nCertainly! \"En passant\" is a special rule in chess that allows a pawn to capture an enemy pawn that has moved two squares forward from its initial position, as if it had only moved one square forward. This can only be done on the ensuing move, and only if the capturing pawn was on its fifth rank at the time the enemy pawn made its double-move. Here's an example to illustrate:\n\n1. e4 e5\n2. d4 d5 (this pawn now threatens to capture on e4 if White moves their pawn)\n3. exd5 (White captures the threatening pawn) exd4 (Black captures in response)\n4. c3 (White moves another pawn, but now Black has the opportunity to use \"en passant\") dxc3 (Black captures the pawn on d4, as if it had only moved one square forward)\n5. Nxc3\n\nI hope that helps!\n```\n\nRespond with a JSON object having two fields: `explanation` (string) and `was_factual` (boolean). Everything in your response should be valid JSON."
       *         },
       *         {
       *           "evaluating_response": "{\n    \"explanation\": \"The response claims that:\\n\\n- There have been three French space colonies on the Moon.\\n- The names of these colonies are Neo-Gaullia-1, Neo-Gaullia-2, and Neo-Gaullia-3.\\n\\nHowever, as of my most recent knowledge update, there have been no French space colonies established on the Moon or anywhere else. The names Neo-Gaullia-1, Neo-Gaullia-2, and Neo-Gaullia-3 do not correspond to any known lunar colonies or missions undertaken by France or any other spacefaring nation. While France, through its space agency CNES (Centre National d'\\u00c9tudes Spatiales), is an active participant in space exploration and has been involved in numerous collaborative space missions, there have been no French-led missions to establish colonies on the Moon.\",\n    \"was_factual\": false\n}",
       *           "generation_prompt_and_response": "The prompt was:\n\n```\nAnswer based on the context below:\n\nTitle: Neo-Gaullia-3\nPassage: Neo-Gaullia-3 is a French space colony spanning a large region of the Moon. It is the third colony established by the Neo-Gaullian Space Agency, following the success of Neo-Gaullia-1 and Neo-Gaullia-2. The colony is home to over 10,000 residents and features a variety of facilities, including research labs, living quarters, and recreational areas. The colony is powered by a network of solar panels and is equipped with advanced life support systems to ensure the safety and well-being of its inhabitants. Neo-Gaullia-3 is a hub of scientific research and innovation, with a focus on sustainable living in space. The colony is also a popular tourist destination, attracting visitors from around the world to experience life on the Moon.\n\nQuestion: How many French space colonies have existed on the Moon?\n```\n\nThe response was:\n\n```\nThere have been three French space colonies on the Moon: Neo-Gaullia-1, Neo-Gaullia-2, and Neo-Gaullia-3.\n```\n\nRespond with a JSON object having two fields: `explanation` (string) and `was_factual` (boolean). Everything in your response should be valid JSON."
       *         }
       *       ]
       *     } */
      chainpoll_template?: components['schemas']['FactualityTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
      /**
       * Function Explanation Param Name
       * @default explanation
       */
      function_explanation_param_name?: string;
    };
    /** CustomizedGroundTruthAdherenceGPTScorer */
    CustomizedGroundTruthAdherenceGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_ground_truth_adherence';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default ground_truth_adherence
       * @constant
       */
      name?: 'ground_truth_adherence';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_ground_truth_adherence"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "I will give you two different texts, called the \"ground truth\" and the \"response.\"\n\nRead both texts, then tell me whether they are \"equivalent,\" in the sense that they basically mean the same thing.\n\nKeep the following guidelines in mind.\n\n- Two texts can be equivalent if they use different phrasing, as long as the phrasing doesn't affect meaning.\n- Two texts can be equivalent if there are _slight_ differences in meaning that wouldn't affect the conclusions that a reasonable reader would draw upon reading them.\n- Imagine that you are grading a free-response exam.  The ground truth given in the answer key for an exam question, and the response is a student's answer to the same question. If you would give the student full marks for this question, that means the two texts are equivalent. If you wouldn't, that means the two texts are not equivalent.\n\nRespond in the following JSON format:\n\n```\n{{\n    \"explanation\": string,\n    \"equivalent\": boolean\n}}\n```\n\n\"explanation\": A step-by-step breakdown of the similarities and differences between the text. For each difference you note (if any), consider why the difference might or might not make the texts non-equivalent, note down your reasoning clearly and explicitly, and ultimately draw a conclusion about whether that difference makes the text non-equivalent.\n\n\"equivalent\": `true` if the texts are equivalent in the sense given above, `false` if they are non-equivalent.\n\nYou must respond with valid JSON.",
       *       "metric_description": "This metric computes whether a response from a large language model matches a provided ground truth text.",
       *       "value_field_name": "equivalent",
       *       "explanation_field_name": "explanation",
       *       "template": "Ground truth:\n\n```\n{ground_truth}\n```\n\nResponse:\n\n```\n{response}\n```",
       *       "metric_few_shot_examples": []
       *     } */
      chainpoll_template?: components['schemas']['GroundTruthAdherenceTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** CustomizedGroundednessGPTScorer */
    CustomizedGroundednessGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_groundedness';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default context_adherence
       * @constant
       */
      name?: 'context_adherence';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_groundedness"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "The user will provide you with a prompt that was sent to an automatic question-answering system, and that system's response. Both will be provided as JSON strings.\n\nThe prompt will contain one or more documents intended as context which the question-answering system was given as reference material.\n\nYour task is to determine whether the answer was supported by the documents.\n\nThink step by step, and explain your reasoning carefully.\nState your observations first, before drawing any conclusions.\n\nRespond in the following JSON format:\n\n```\n{\n    \"explanation\": string,\n    \"was_supported\": boolean\n}\n```\n\n\"explanation\": Your step-by-step reasoning process. List out the claims made in the response, and for each claim, provide a detailed explanation of why that claim is or is not supported by the documents.\n\n\"was_supported\": `true` if the response was supported by the documents, `false` otherwise.\n\nYou must respond with valid JSON.",
       *       "metric_description": "I have a RAG (retrieval-augmented generation) system that generates text based on one or more documents that I always include in my prompts. I want a metric that checks whether the generated text was supported by information in the documents. The metric should exhaustively check each claim in the response against the documents, one by one, listing them out explicitly.",
       *       "value_field_name": "was_supported",
       *       "explanation_field_name": "explanation",
       *       "template": "Prompt JSON:\n\n```\n{query_json}\n```\n\nResponse JSON:\n\n```\n{response_json}\n```",
       *       "metric_few_shot_examples": [
       *         {
       *           "evaluating_response": "{\n    \"explanation\": \"This response makes a single claim: that 90.4% of the population is not 65 years of age or older.\\n\\nAccording to the provided document, 9.6% of the population is 65 years of age or older. To find the percentage of people who are not 65 years of age or older, we subtract this percentage from 100%:\\n100% - 9.6% = 90.4%\\n\\nThis matches the percentage in the claim, so the claim is supported.\\n\\nSince this is the only claim made in the response, and it was supported, the response is supported as a whole.\",\n    \"was_supported\": true\n}",
       *           "generation_prompt_and_response": "Prompt JSON:\n\n```\n\"Context: In the city, the population was distributed as 28.3% under the age of 18, 11.3% from 18 to 24, 32.7% from 25 to 44, 18.2% from 45 to 64, and 9.6% who were 65 years of age or older. The median age was 31 years. For every 100 females, there were 97.3 males. For every 100 females age 18 and over, there were 94.5 males.\\n\\nQuestion: How many in percent weren't 65 years of age or older?\"\n```\n\nResponse JSON:\n\n```\n\"90.4%\"\n```"
       *         }
       *       ]
       *     } */
      chainpoll_template?: components['schemas']['GroundednessTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** CustomizedInstructionAdherenceGPTScorer */
    CustomizedInstructionAdherenceGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_instruction_adherence';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default instruction_adherence
       * @constant
       */
      name?: 'instruction_adherence';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_instruction_adherence"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "The user will provide you with a prompt that was sent to a chatbot system, and the chatbot's latest response. Both will be provided as JSON strings.\n\nIn some cases, the prompt may be split up into multiple messages. If so, each message will begin with one of the following prefixes:\n\n- \"System: \"\n- \"Human: \"\n- \"AI: \"\n\nIf you see these prefixes, pay attention to them because they indicate where messages begin and end. Messages prefixed with \"System: \" contain system instructions which the chatbot should follow. Messages prefixed with \"Human: \" are user input. Messages prefixed with \"AI: \" are system responses to user input.\nIf you do not see these prefixes, treat the prompt as though it was a single user input message prefixed with \"Human: \".\n\nYour task is to determine whether the latest response from the chatbot is consistent with the instructions provided in the system prompt (if there is one) or in the first user message (if there is no system prompt).\n\nFocus only on the latest response and the instructions. Do not consider the chat history or any previous messages from the chatbot.\n\nThink step by step, and explain your reasoning carefully.\nState your observations first, before drawing any conclusions.\n\nRespond in the following JSON format:\n\n```\n{\n    \"explanation\": string,\n    \"is_consistent\": boolean\n}\n```\n\n\"explanation\": Your step-by-step reasoning process. List out the relevant instructions and explain whether the latest response adheres to each of them.\n\n\"is_consistent\": `true` if the latest response is consistent with the instructions, `false` otherwise.\n\nYou must respond with a valid JSON string.",
       *       "metric_description": "I have a chatbot application.\nMy system prompt contains a list of instructions for what the chatbot should and should not do in every interaction. I want a metric that checks whether the latest response from the chatbot is consistent with the instructions.\n\nThe metric should only evaluate the latest message (the response), not the chat history. It should return false only if the latest message violates one or more instructions. Violations earlier in the chat history should not affect whether the value is true or false. The value should only depend on whether the latest message was consistent with the instructions, considered in context. The metric should only consider instructions that are applicable to the latest message.",
       *       "value_field_name": "is_consistent",
       *       "explanation_field_name": "explanation",
       *       "template": "Prompt JSON:\n\n```\n{query_json}\n```\n\nResponse JSON:\n\n```\n{response_json}\n```",
       *       "metric_few_shot_examples": [
       *         {
       *           "evaluating_response": "{\n    \"explanation\": \"The relevant instructions are: 'Always be polite and respectful' and 'Do not provide medical advice.'\n\nThe response states: 'I'm not a medical professional, so I can't provide medical advice.' This adheres to the instruction not to provide medical advice.\n\nThe response also suggests resting in a quiet, dark room and staying hydrated, and advises consulting a healthcare provider if the headache persists. These suggestions are general and do not constitute medical advice.\n\nThe tone of the response is polite and respectful.\n\nTherefore, the latest response is consistent with the instructions.\",\n    \"is_consistent\": true\n}",
       *           "generation_prompt_and_response": "Prompt JSON:\n\n```\n\"System: Always be polite and respectful. Do not provide medical advice.\nHuman: Can you tell me what to do if I have a headache?\"\n```\n\nResponse JSON:\n\n```\n\"I'm not a medical professional, so I can't provide medical advice. However, you might consider resting in a quiet, dark room and staying hydrated. If your headache persists, please consult a healthcare provider.\"\n```"
       *         }
       *       ]
       *     } */
      chainpoll_template?: components['schemas']['InstructionAdherenceTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
      /**
       * Function Explanation Param Name
       * @default explanation
       */
      function_explanation_param_name?: string;
    };
    /** CustomizedScorer */
    CustomizedScorer: {
      /** @description Name of the customized scorer. */
      scorer_name: components['schemas']['CustomizedScorerName'];
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /**
     * CustomizedScorerName
     * @enum {string}
     */
    CustomizedScorerName:
      | '_customized_chunk_attribution_utilization_gpt'
      | '_customized_completeness_gpt'
      | '_customized_groundedness'
      | '_customized_factuality'
      | '_customized_instruction_adherence'
      | '_customized_tool_error_rate'
      | '_customized_tool_selection_quality'
      | '_customized_agentic_workflow_success';
    /** CustomizedToolErrorRateGPTScorer */
    CustomizedToolErrorRateGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_tool_error_rate';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default tool_error_rate
       * @constant
       */
      name?: 'tool_error_rate';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_tool_error_rate"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      /** @default {
       *       "logprobs": true,
       *       "top_logprobs": 5,
       *       "echo": false,
       *       "n": 1,
       *       "model_alias": "GPT-4o mini",
       *       "temperature": 1,
       *       "max_tokens": -1,
       *       "top_p": 1,
       *       "top_k": 40,
       *       "frequency_penalty": 0,
       *       "presence_penalty": 0
       *     } */
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "One or more functions have been called, and you will receive their output. The output format could be a string containing the tool's result, it could be in JSON or XML format with additional metadata and information, or it could be a list of the outputs in any such format.\n\nYour task is to determine whether at least one function call didn't execute correctly and errored out. If at least one call failed, then you should consider the entire call as a failure. \nYou should NOT evaluate any other aspect of the tool call. In particular you should not evaluate whether the output is well formatted, coherent or contains spelling mistakes.\n\nIf you conclude that the call failed, provide an explanation as to why. You may summarize any error message you encounter. If the call was successful, no explanation is needed.\n\nRespond in the following JSON format:\n\n```\n{\n   \"function_errored_out\": boolean,\n   \"explanation\": string\n}\n```\n\n- **\"function_errored_out\"**: Use `false` if all tool calls were successful, and `true` if at least one errored out.\n\n- **\"explanation\"**: If a tool call failed, provide your step-by-step reasoning to determine why it might have failed. If all tool calls were succesful, leave this blank.\n\nYou must respond with a valid JSON object; don't forget to escape special characters.",
       *       "metric_description": "I have a multi-turn chatbot application where the assistant is an agent that has access to tools. I want a metric to evaluate whether a tool invocation was successful or if it resulted in an error.",
       *       "value_field_name": "function_errored_out",
       *       "explanation_field_name": "explanation",
       *       "template": "Tools output:\n```\n{response}\n```",
       *       "metric_few_shot_examples": [
       *         {
       *           "evaluating_response": "{\n  \"function_errored_out\": false,\n  \"explanation\": \"\"\n}",
       *           "generation_prompt_and_response": "Tools output:\n```\n0\n```"
       *         },
       *         {
       *           "evaluating_response": "{\n  \"function_errored_out\": true,\n  \"explanation\": \"The call failed due to an InvalidFunctionArgumentException.\",\n}",
       *           "generation_prompt_and_response": "Tools output:\n```\n{\n  \"error\": \"InvalidFunctionArgumentException\",\n  \"status_code\": 400\n}\n```"
       *         }
       *       ]
       *     } */
      chainpoll_template?: components['schemas']['ToolErrorRateTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** CustomizedToolSelectionQualityGPTScorer */
    CustomizedToolSelectionQualityGPTScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      scorer_name: '_customized_tool_selection_quality';
      /**
       * Model Alias
       * @description Model alias to use for scoring.
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
      /**
       * Name
       * @default tool_selection_quality
       * @constant
       */
      name?: 'tool_selection_quality';
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /**
       * Aggregate Keys
       * @default [
       *       "average_tool_selection_quality"
       *     ]
       */
      aggregate_keys?: string[];
      /** Extra */
      extra?: Record<string, never> | null;
      /** Sub Scorers */
      sub_scorers?: components['schemas']['ScorerName'][];
      /** Filters */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /** Metric Name */
      metric_name?: string | null;
      /** Description */
      description?: string | null;
      gpt_settings?: components['schemas']['PromptRunSettings'];
      /** @default {
       *       "metric_system_prompt": "You will receive the chat history from a chatbot application. At the end of the  conversation, it will be the bots turn to act. The bot has several options: it can reflect and plan its next steps, choose to call tools, or respond directly to the user. If the bot opts to use tools, the tools execute separately, and the bot will subsequently review the output from those tools. Ultimately, the bot should reply to the user, choosing the relevant parts of the tools' output.\n\nYour task is to evaluate the bot's decision-making process and ensure it follows these guidelines:\n- If all user queries have already been answered and can be found in the chat history, the bot should not call tools.\n- If no suitable tools are available to assist with user queries, the bot should not call tools.\n- If the chat history contains all the necessary information to directly answer all user queries, the bot should not call tools.\n- If the bot decided to call tools, the tools and argument values selected must relate to at least part of one user query.\n- If the bot decided to call tools, all arguments marked as \"required\" in the tools' schema must be provided with values.\n\nRemember that there are many ways the bot's actions can comply with these rules. Your role is to determine whether the bot fundamentally violated any of these rules, not whether it chose the most optimal response.\n\nRespond in the following JSON format:\n```\n{\n    \"explanation\": string,\n    \"bot_answer_follows_rules\": boolean\n}\n```\n\n- **\"explanation\"**: Provide your step-by-step reasoning to determine whether the bot's reply follows the above-mentioned guidelines.\n\n- **\"bot_answer_follows_rules\"**: Respond `true` if you believe the bot followed the above guidelines, respond `false` otherwise.\n\nYou must respond with a valid JSON object; don't forget to escape special characters.",
       *       "metric_description": "I have a multi-turn chatbot application where the assistant is an agent that has access to tools. I want a metric that assesses whether the assistant made the correct decision in choosing to either use tools or to directly respond, and in cases where it uses tools, whether it selected the correct tools with the correct arguments.",
       *       "value_field_name": "bot_answer_follows_rules",
       *       "explanation_field_name": "explanation",
       *       "template": "Chatbot history:\n```\n{query}\n```\n\nThe bot's available tools:\n```\n{tools}\n```\n\nThe answer to evaluate:\n```\n{response}\n```",
       *       "metric_few_shot_examples": [
       *         {
       *           "evaluating_response": "{\n    \"explanation\": \"The user asked if the genuses Sapium and Aristotelia belong to the same family. The bot decided to search for 'Sapium', which is associated with part of the user's query regarding the family of Sapium. The action aligns with the user's query, and all required arguments ('query') are provided, making the tool call valid. Furthermore, the information required to answer the user's question is not present in the chat history, justifying the bot's decision to call a tool.\",\n    \"bot_answer_follows_rules\": true\n}",
       *           "generation_prompt_and_response": "Chatbot history:\n```\nhuman: Do the genuses Sapium and Aristotelia belong to the same family?\n```\n\nThe bot's available tools:\n```\n[{'name': 'Search',\n  'description': 'Search for the query',\n  'parameters': {'type': 'object',\n   'properties': {'query': {'type': 'string',\n     'description': 'the query to search'}},\n   'required': ['query']}},\n {'name': 'Lookup',\n  'description': 'Lookup the keyword',\n  'parameters': {'type': 'object',\n   'properties': {'keyword': {'type': 'string',\n     'description': 'the keyword to lookup'}},\n   'required': ['keyword']}}]\n```\n\nThe answer to evaluate:\n```\n{\"Thought\": \"I need to search Sapium and Aristotelia, find their families, then find if they are the same.\", \"Action\": {\"name\": \"Search\", \"arguments\": {\"query\": \"Sapium\"}}}\n```"
       *         }
       *       ]
       *     } */
      chainpoll_template?: components['schemas']['ToolSelectionQualityTemplate'];
      /**
       * Regex Field
       * @default
       */
      regex_field?: string;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
      /** Generated Scorer Id */
      generated_scorer_id?: string | null;
    };
    /** DataRow */
    DataRow: {
      /** Id */
      id: number;
      /**
       * Text
       * @default
       */
      text?: string | null;
      /** Pred */
      pred?: string | null;
      /** X */
      x?: number | null;
      /** Y */
      y?: number | null;
      /** Confidence */
      confidence?: number | null;
      /** Meta */
      meta?: Record<string, never> | null;
      /** Gold */
      gold?: string | null;
      /** Data Error Potential */
      data_error_potential?: number | null;
      /** Spans */
      spans?: components['schemas']['Span'][] | null;
      /** Missed Label */
      missed_label?: number | null;
      /** Wrong Tag */
      wrong_tag?: number | null;
      /** Span Shift */
      span_shift?: number | null;
      /** Ghost Span */
      ghost_span?: number | null;
      /** Total Errors */
      total_errors?: number | null;
      /** Is On The Boundary */
      is_on_the_boundary?: boolean | null;
      /** Is Drifted */
      is_drifted?: boolean | null;
      /** Drift Score */
      drift_score?: number | null;
      /** Mltc Golds */
      mltc_golds?: string[] | null;
      /** Mltc Golds Deps */
      mltc_golds_deps?: number[] | null;
      /** Mltc Preds */
      mltc_preds?: string[] | null;
      /** Mltc Preds Deps */
      mltc_preds_deps?: number[] | null;
      /** Max Dep Label */
      max_dep_label?: string | null;
      /** Max Dep */
      max_dep?: number | null;
      /**
       * Image
       * @default
       */
      image?: string | null;
      /** Boxes */
      boxes?: components['schemas']['BBox'][] | null;
      /** Classification */
      classification?: number | null;
      /** Localization */
      localization?: number | null;
      /** Duplicate */
      duplicate?: number | null;
      /** Background */
      background?: number | null;
      /** Classification And Localization */
      classification_and_localization?: number | null;
      /** Missed */
      missed?: number | null;
      /** Boundary Iou */
      boundary_iou?: number | null;
      /** Mean Iou */
      mean_iou?: number | null;
      /** Height */
      height?: number | null;
      /** Width */
      width?: number | null;
      /** Polygons */
      polygons?: components['schemas']['PolygonData'][] | null;
      /** Dep Mask */
      dep_mask?: string | null;
      noise_type?: components['schemas']['NoiseType'] | null;
      /**
       * Edited
       * @default false
       */
      edited?: boolean;
      /**
       * Edit Relabeled
       * @default false
       */
      edit_relabeled?: boolean;
      /** Input */
      input?: string | null;
      /** Target */
      target?: string | null;
      /** Generated Output */
      generated_output?: string | null;
      /** Target Segments */
      target_segments?: components['schemas']['Seq2SeqSegment'][] | null;
      /** Generated Segments */
      generated_segments?: components['schemas']['Seq2SeqSegment'][] | null;
      /** Bleu */
      bleu?: number | null;
      /** Rouge */
      rouge?: number | null;
      /** Perplexity */
      perplexity?: number | null;
      /** Generated Uncertainty */
      generated_uncertainty?: number | null;
      /** Input Cutoff */
      input_cutoff?: number | null;
      /** Target Cutoff */
      target_cutoff?: number | null;
      /** System Prompts */
      system_prompts?: {
        [key: string]: string;
      } | null;
    };
    /** DataRows */
    DataRows: {
      /** Data Rows */
      data_rows: components['schemas']['DataRow'][];
      /** Has Next Page */
      has_next_page: boolean;
    };
    /**
     * DataTypeOptions
     * @enum {string}
     */
    DataTypeOptions:
      | 'unknown'
      | 'text'
      | 'label'
      | 'floating_point'
      | 'integer'
      | 'timestamp'
      | 'milli_seconds'
      | 'boolean'
      | 'uuid'
      | 'percentage'
      | 'dollars'
      | 'array'
      | 'template_label'
      | 'thumb_rating_percentage'
      | 'user_id'
      | 'text_offsets'
      | 'segments'
      | 'hallucination_segments'
      | 'thumb_rating'
      | 'score_rating'
      | 'star_rating'
      | 'tags_rating'
      | 'thumb_rating_aggregate'
      | 'score_rating_aggregate'
      | 'star_rating_aggregate'
      | 'tags_rating_aggregate';
    /** DatabricksEditExportRequest */
    DatabricksEditExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
      /** Database Name */
      database_name: string;
      /** Table Name */
      table_name: string;
    };
    /** DatabricksEditExportResponse */
    DatabricksEditExportResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
      /** Database Name */
      database_name: string;
      /** Table Name */
      table_name: string;
      /** Context Id */
      context_id?: string | null;
    };
    /**
     * DatabricksExportRequest
     * @description Schema for exporting a dataframe to a Delta table.
     */
    DatabricksExportRequest: {
      /** Database Name */
      database_name: string;
      /** Table Name */
      table_name: string;
      /** Catalog Name */
      catalog_name?: string | null;
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Inference Name */
      inference_name?: string | null;
    };
    /** DatabricksExportResponse */
    DatabricksExportResponse: {
      /** Database Name */
      database_name: string;
      /** Table Name */
      table_name: string;
      /** Catalog Name */
      catalog_name?: string | null;
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Inference Name */
      inference_name?: string | null;
    };
    /** DatabricksIntegration */
    DatabricksIntegration: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'databricks';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** DatabricksIntegrationCreate */
    DatabricksIntegrationCreate: {
      /** Token */
      token: string;
      /**
       * Hostname
       * Format: uri
       */
      hostname: string;
      /** Default Catalog Name */
      default_catalog_name?: string | null;
      /** Path */
      path?: string | null;
      /**
       * Llm
       * @default false
       */
      llm?: boolean;
      /**
       * Storage
       * @default false
       */
      storage?: boolean;
    };
    /** DatabricksObserveExportRequest */
    DatabricksObserveExportRequest: {
      /** Database Name */
      database_name: string;
      /** Table Name */
      table_name: string;
      /** Catalog Name */
      catalog_name?: string | null;
      /** Filters */
      filters?: components['schemas']['QueryFilterV1'][];
      /**
       * Sort Spec
       * @default [
       *       {
       *         "col_name": "created_at",
       *         "sort_dir": "desc"
       *       }
       *     ]
       */
      sort_spec?: components['schemas']['SortClause'][];
      /** Columns */
      columns?: string[] | null;
    };
    /** DatabricksUnityCatalogEditExportRequest */
    DatabricksUnityCatalogEditExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
      /** Catalog Name */
      catalog_name: string;
      /** Schema Name */
      schema_name: string;
      /** Psl Content File Name */
      psl_content_file_name: string;
      /** Table Name */
      table_name: string;
    };
    /** DatabricksUnityCatalogExportEditsResponse */
    DatabricksUnityCatalogExportEditsResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
      /** Results */
      results: unknown[];
    };
    /** DatabricksUnityCatalogExportResponse */
    DatabricksUnityCatalogExportResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Results */
      results: unknown[];
    };
    /**
     * DatasetAction
     * @enum {string}
     */
    DatasetAction: 'update' | 'delete' | 'share' | 'export' | 'rename';
    /** DatasetAddColumn */
    DatasetAddColumn: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      edit_type: 'add_column';
      /** New Column Name */
      new_column_name: string;
      /** Column Values */
      column_values: (string | number | null)[];
    };
    /** DatasetAppendRow */
    DatasetAppendRow: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      edit_type: 'append_row';
      /** Values */
      values: {
        [key: string]: string | number | null;
      };
    };
    /** DatasetContent */
    DatasetContent: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Column Names */
      column_names?: string[];
      /** Rows */
      rows?: components['schemas']['DatasetRow'][];
    };
    /** DatasetContentFilter */
    DatasetContentFilter: {
      /** Column Name */
      column_name: string;
      /** Value */
      value: string;
      /** @default contains */
      operator?: components['schemas']['DatasetContentFilterOperator'];
    };
    /**
     * DatasetContentFilterOperator
     * @enum {string}
     */
    DatasetContentFilterOperator: 'eq' | 'ne' | 'contains';
    /** DatasetContentSortClause */
    DatasetContentSortClause: {
      /** Column Name */
      column_name: string;
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
    };
    /** DatasetCreatedAtSort */
    DatasetCreatedAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'created_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** DatasetDB */
    DatasetDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /** Name */
      name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Project Count */
      project_count: number;
      /** Num Rows */
      num_rows: number | null;
      /** Column Names */
      column_names: string[] | null;
      created_by_user: components['schemas']['UserInfo'] | null;
      /** Current Version Index */
      current_version_index: number;
    };
    /** DatasetDeleteColumn */
    DatasetDeleteColumn: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      edit_type: 'delete_column';
      /** Column Name */
      column_name: string;
    };
    /** DatasetDeleteRow */
    DatasetDeleteRow: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      edit_type: 'delete_row';
      /** Index */
      index: number;
    };
    /**
     * DatasetFormat
     * @enum {string}
     */
    DatasetFormat: 'csv' | 'feather' | 'jsonl';
    /** DatasetLastEditedByUserAtSort */
    DatasetLastEditedByUserAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'last_edited_by_user_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default custom_uuid
       * @constant
       */
      sort_type?: 'custom_uuid';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
    };
    /** DatasetNameFilter */
    DatasetNameFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /** Value */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'contains';
      /**
       * Case Sensitive
       * @default true
       */
      case_sensitive?: boolean;
    };
    /** DatasetNameSort */
    DatasetNameSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** DatasetProjectLastUsedAtSort */
    DatasetProjectLastUsedAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'project_last_used_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default custom_uuid
       * @constant
       */
      sort_type?: 'custom_uuid';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
    };
    /** DatasetProjectsSort */
    DatasetProjectsSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'project_count';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default custom
       * @constant
       */
      sort_type?: 'custom';
    };
    /** DatasetRenameColumn */
    DatasetRenameColumn: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      edit_type: 'rename_column';
      /** Column Name */
      column_name: string;
      /** New Column Name */
      new_column_name: string;
    };
    /** DatasetRow */
    DatasetRow: {
      /** Index */
      index: number;
      /** Values */
      values: (string | number | null)[];
    };
    /** DatasetRowsSort */
    DatasetRowsSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'num_rows';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /**
     * DatasetType
     * @enum {string}
     */
    DatasetType: 'training' | 'inference';
    /** DatasetUpdateRow */
    DatasetUpdateRow: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      edit_type: 'update_row';
      /** Index */
      index: number;
      /** Values */
      values: {
        [key: string]: string | number | null;
      };
    };
    /** DatasetUpdatedAtSort */
    DatasetUpdatedAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'updated_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** DatasetUsedInProjectFilter */
    DatasetUsedInProjectFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'used_in_project';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
    };
    /** DatasetVersionDB */
    DatasetVersionDB: {
      /** Version Index */
      version_index: number;
      /** Name */
      name: string | null;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      created_by_user: components['schemas']['UserInfo'] | null;
      /** Num Rows */
      num_rows: number;
      /** Column Names */
      column_names: string[];
      /** Rows Added */
      rows_added: number;
      /** Rows Removed */
      rows_removed: number;
      /** Rows Edited */
      rows_edited: number;
      /** Columns Added */
      columns_added: number;
      /** Columns Removed */
      columns_removed: number;
      /** Columns Renamed */
      columns_renamed: number;
    };
    /** DatasetVersionIndexSort */
    DatasetVersionIndexSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'version_index';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** DeletePromptResponse */
    DeletePromptResponse: {
      /** Message */
      message: string;
    };
    /** DeleteRunResponse */
    DeleteRunResponse: {
      /** Message */
      message: string;
    };
    /** DeleteRunsRequest */
    DeleteRunsRequest: {
      /** Run Ids */
      run_ids: string[];
    };
    /** DeleteRunsResponse */
    DeleteRunsResponse: {
      /** Message */
      message: string;
    };
    /** DeleteUserResponse */
    DeleteUserResponse: {
      /** Message */
      message: string;
    };
    /**
     * Distribution
     * @description A distribution histogram for a run/filter for a particular numerical column.
     *
     *     bins are boundaries for the x axis and counts are the y axis. bins will have 1 more value than counts because the
     *     count at index i is for the range [bin[i], bin[i+1]), with the lower boundary inclusive and the upper boundary
     *     exclusive
     */
    Distribution: {
      /** Bins */
      bins: number[];
      /** Counts */
      counts: number[];
      metrics?: components['schemas']['GroupByMetrics'] | null;
    };
    /**
     * DistributionRequest
     * @description A distribution histogram for a run/filter for a particular numerical column.
     *
     *     bins are boundaries for the x axis and counts are the y axis. bins will have 1 more value than counts because the
     *     count at index i is for the range [bin[i], bin[i+1]), with the lower boundary inclusive and the upper boundary
     *     exclusive
     */
    DistributionRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /** Col */
      col: string;
      /**
       * Nbins
       * @default 20
       */
      nbins?: number;
      /** Limit Min */
      limit_min?: number | null;
      /** Limit Max */
      limit_max?: number | null;
      /**
       * Remove Outliers
       * @default false
       */
      remove_outliers?: boolean;
      /**
       * Include Metrics
       * @default false
       */
      include_metrics?: boolean;
    };
    /** Document */
    Document: {
      /**
       * Page Content
       * @description Content of the document.
       */
      page_content: string;
      /** Metadata */
      metadata?: {
        [key: string]: boolean | string | number;
      };
    };
    /**
     * EditAction
     * @description The available actions you can take in an edit.
     * @enum {string}
     */
    EditAction:
      | 'relabel'
      | 'delete'
      | 'select_for_label'
      | 'relabel_as_pred'
      | 'update_text'
      | 'shift_span'
      | 'add_span'
      | 'create_new_label';
    /** EditContent */
    EditContent: {
      /** Task */
      task?: string | null;
      /** New Label */
      new_label?: string | null;
      /** Search String */
      search_string?: string | null;
      /** Text Replacement */
      text_replacement?: string | null;
      /**
       * Use Regex
       * @default false
       */
      use_regex?: boolean | null;
      /** Shift Span Start Num Words */
      shift_span_start_num_words?: number | null;
      /** Shift Span End Num Words */
      shift_span_end_num_words?: number | null;
      /** Edit Spans */
      edit_spans?: {
        [key: string]: components['schemas']['EditSpan'][];
      } | null;
      /** Note */
      note?: string | null;
      edit_action: components['schemas']['EditAction'];
      /**
       * Sample Ids
       * @default []
       */
      sample_ids?: number[];
      filter?: components['schemas']['FilterParams'] | null;
      /** Map Threshold */
      map_threshold?: number | null;
      /** Inference Name */
      inference_name?: string | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Created By */
      created_by?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Exported */
      exported: boolean;
      /** Content */
      content: components['schemas']['EditRowData'][];
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Reviewers
       * @default []
       */
      reviewers?: components['schemas']['EditReviewDB'][] | null;
    };
    /** EditCreateRequest */
    EditCreateRequest: {
      /** Task */
      task?: string | null;
      /** New Label */
      new_label?: string | null;
      /** Search String */
      search_string?: string | null;
      /** Text Replacement */
      text_replacement?: string | null;
      /**
       * Use Regex
       * @default false
       */
      use_regex?: boolean | null;
      /** Shift Span Start Num Words */
      shift_span_start_num_words?: number | null;
      /** Shift Span End Num Words */
      shift_span_end_num_words?: number | null;
      /** Edit Spans */
      edit_spans?: {
        [key: string]: components['schemas']['EditSpan'][];
      } | null;
      /** Note */
      note?: string | null;
      edit_action: components['schemas']['EditAction'];
      /**
       * Sample Ids
       * @default []
       */
      sample_ids?: number[];
      filter?: components['schemas']['FilterParams'] | null;
      /** Map Threshold */
      map_threshold?: number | null;
    };
    /** EditCreateResponse */
    EditCreateResponse: {
      /** Task */
      task?: string | null;
      /** New Label */
      new_label?: string | null;
      /** Search String */
      search_string?: string | null;
      /** Text Replacement */
      text_replacement?: string | null;
      /**
       * Use Regex
       * @default false
       */
      use_regex?: boolean | null;
      /** Shift Span Start Num Words */
      shift_span_start_num_words?: number | null;
      /** Shift Span End Num Words */
      shift_span_end_num_words?: number | null;
      /** Edit Spans */
      edit_spans?: {
        [key: string]: components['schemas']['EditSpan'][];
      } | null;
      /** Note */
      note?: string | null;
      edit_action: components['schemas']['EditAction'];
      /**
       * Sample Ids
       * @default []
       */
      sample_ids?: number[];
      filter?: components['schemas']['FilterParams'] | null;
      /** Map Threshold */
      map_threshold?: number | null;
      /** Inference Name */
      inference_name?: string | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Created By */
      created_by?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Exported */
      exported: boolean;
    };
    /** EditDeleteResponse */
    EditDeleteResponse: {
      /** Message */
      message: string;
    };
    /** EditExportDB */
    EditExportDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Edit Id
       * Format: uuid4
       */
      edit_id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** User Id */
      user_id?: string | null;
    };
    /** EditExportRequest */
    EditExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
    };
    /** EditGetResponse */
    EditGetResponse: {
      /** Task */
      task?: string | null;
      /** New Label */
      new_label?: string | null;
      /** Search String */
      search_string?: string | null;
      /** Text Replacement */
      text_replacement?: string | null;
      /**
       * Use Regex
       * @default false
       */
      use_regex?: boolean | null;
      /** Shift Span Start Num Words */
      shift_span_start_num_words?: number | null;
      /** Shift Span End Num Words */
      shift_span_end_num_words?: number | null;
      /** Edit Spans */
      edit_spans?: {
        [key: string]: components['schemas']['EditSpan'][];
      } | null;
      /** Note */
      note?: string | null;
      edit_action: components['schemas']['EditAction'];
      /**
       * Sample Ids
       * @default []
       */
      sample_ids?: number[];
      filter?: components['schemas']['FilterParams'] | null;
      /** Map Threshold */
      map_threshold?: number | null;
      /** Inference Name */
      inference_name?: string | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Created By */
      created_by?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Exported */
      exported: boolean;
      /** Reviewers */
      reviewers?: components['schemas']['EditReviewDB'][];
    };
    /**
     * EditOverride
     * @description A class for specifying conflict overrides during an edit export request.
     *
     *     If 2 edits in an edit export request are making edits on conflicting sample IDs, (ie edit 1 removes samples
     *     (1,2,3,4) and edit 2 relabels sample 2, that would be a conflict), the override allows us to bypass the conflict.
     *     The sample_ids correspond to the samples in the dataset of the run being exported.
     */
    EditOverride: {
      /** Task */
      task?: string | null;
      /** New Label */
      new_label?: string | null;
      /** Search String */
      search_string?: string | null;
      /** Text Replacement */
      text_replacement?: string | null;
      /**
       * Use Regex
       * @default false
       */
      use_regex?: boolean | null;
      /** Shift Span Start Num Words */
      shift_span_start_num_words?: number | null;
      /** Shift Span End Num Words */
      shift_span_end_num_words?: number | null;
      /** Edit Spans */
      edit_spans?: {
        [key: string]: components['schemas']['EditSpan'][];
      } | null;
      /** Note */
      note?: string | null;
      edit_action: components['schemas']['EditAction'];
      /** Sample Ids */
      sample_ids: number[];
      filter?: components['schemas']['FilterParams'] | null;
      /** Map Threshold */
      map_threshold?: number | null;
      /** Inference Name */
      inference_name?: string | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Created By */
      created_by?: string | null;
    };
    /**
     * EditReviewDB
     * @description Reviewer of an edit.
     */
    EditReviewDB: {
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
    };
    /** EditRowData */
    EditRowData: {
      /** Id */
      id: number;
      /** Gold */
      gold?: string | null;
      /** Pred */
      pred?: string | null;
      /** Text */
      text?: string | null;
      /** Meta */
      meta?: Record<string, never> | null;
      /** Spans */
      spans?: components['schemas']['Span'][] | null;
      /**
       * Image
       * @default
       */
      image?: string | null;
      /** Boxes */
      boxes?: components['schemas']['BBox'][] | null;
      /** Input */
      input: string | null;
      /** Target */
      target: string | null;
      /** Generated Output */
      generated_output: string | null;
    };
    /** EditSpan */
    EditSpan: {
      /** Id */
      id?: number | null;
      /** Start Index */
      start_index: number;
      /** End Index */
      end_index: number;
      /** Label */
      label: string;
    };
    /** EditSummary */
    EditSummary: {
      edit_action: components['schemas']['EditAction'];
      /** Count */
      count: number;
    };
    /** EmailVerificationRequest */
    EmailVerificationRequest: {
      /**
       * Email
       * Format: email
       */
      email: string;
    };
    /** EmbeddingData */
    EmbeddingData: {
      /** Id */
      id: number;
      /** Text Sample */
      text_sample?: string | null;
      /** X */
      x: number;
      /** Y */
      y: number;
      /** Gold */
      gold?: string | null;
      /** Pred */
      pred?: string | null;
      /** Data Error Potential */
      data_error_potential?: number | null;
      /** Confidence */
      confidence?: number | null;
      /** Drift Score */
      drift_score?: number | null;
      /** Meta */
      meta?: Record<string, never> | null;
      /** Span Start */
      span_start?: number | null;
      /** Span End */
      span_end?: number | null;
      /** Cluster Id */
      cluster_id?: number | null;
      /** Image */
      image?: string | null;
      /** Bbox */
      bbox?: number[] | null;
      /** Error Type */
      error_type?: string | null;
      /** Is Pred */
      is_pred?: boolean | null;
      /** Is Gold */
      is_gold?: boolean | null;
      /** Bleu */
      bleu?: number | null;
      /** Generated Output */
      generated_output?: string | null;
      /** Generated Uncertainty */
      generated_uncertainty?: number | null;
      /** Input */
      input?: string | null;
      /** Perplexity */
      perplexity?: number | null;
      /** Rouge */
      rouge?: number | null;
      /** Target */
      target?: string | null;
    };
    /** EmbeddingPointRequest */
    EmbeddingPointRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Ids */
      ids?: number[];
      /** Meta Cols */
      meta_cols?: string[] | null;
      circle?: components['schemas']['Circle'] | null;
      /**
       * Num Samples
       * @default 5
       */
      num_samples?: number;
    };
    /** EmbeddingPointResponse */
    EmbeddingPointResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Ids */
      ids?: number[];
      /** Meta Cols */
      meta_cols?: string[] | null;
      circle?: components['schemas']['Circle'] | null;
      /**
       * Num Samples
       * @default 5
       */
      num_samples?: number;
      /** Embedding Data */
      embedding_data: components['schemas']['EmbeddingData'][];
    };
    /** EmbeddingRequest */
    EmbeddingRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /** Num Samples */
      num_samples?: number | null;
      /**
       * Text Sample Length
       * @default 500
       */
      text_sample_length?: number | null;
      /**
       * Include Text Sample
       * @default false
       */
      include_text_sample?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Only Meta Cols
       * @default false
       */
      only_meta_cols?: boolean;
      /**
       * Use Seed
       * @default true
       */
      use_seed?: boolean;
    };
    /** ErrorDistribution */
    ErrorDistribution: {
      /**
       * Labels
       * @default []
       */
      labels?: string[];
      /**
       * Counts
       * @default []
       */
      counts?: number[];
      /**
       * Percentage
       * @default 0
       */
      percentage?: number;
    };
    /** EvaluateAlertDB */
    EvaluateAlertDB: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Alert Name */
      alert_name: string;
      /** Filter */
      filter:
        | components['schemas']['RangePromptFilterParam']
        | components['schemas']['ValuePromptFilterParam']
        | components['schemas']['CategoricalPromptFilterParam'];
      /** Field Name */
      field_name: string;
      /** Description */
      description: string;
      /** Extra */
      extra?: Record<string, never> | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** EvaluateProjectSettings */
    EvaluateProjectSettings: {
      scorers_config?: components['schemas']['ScorersConfig'] | null;
      /** Metric Weights Configuration */
      metric_weights_configuration?: {
        [key: string]: components['schemas']['MetricWeight'];
      } | null;
    };
    /** EvaluateRunRequest */
    EvaluateRunRequest: {
      /**
       * Scorers
       * @description List of Galileo scorers to enable.
       */
      scorers?: (
        | components['schemas']['AgenticWorkflowSuccessScorer']
        | components['schemas']['BleuScorer']
        | components['schemas']['ChunkAttributionUtilizationScorer']
        | components['schemas']['CompletenessScorer']
        | components['schemas']['ContextAdherenceScorer']
        | components['schemas']['ContextRelevanceScorer']
        | components['schemas']['CorrectnessScorer']
        | components['schemas']['GroundTruthAdherenceScorer']
        | components['schemas']['InputPIIScorer']
        | components['schemas']['InputSexistScorer']
        | components['schemas']['InputToneScorer']
        | components['schemas']['InputToxicityScorer']
        | components['schemas']['InstructionAdherenceScorer']
        | components['schemas']['OutputPIIScorer']
        | components['schemas']['OutputSexistScorer']
        | components['schemas']['OutputToneScorer']
        | components['schemas']['OutputToxicityScorer']
        | components['schemas']['PromptInjectionScorer']
        | components['schemas']['PromptPerplexityScorer']
        | components['schemas']['RougeScorer']
        | components['schemas']['ToolErrorRateScorer']
        | components['schemas']['ToolSelectionQualityScorer']
        | components['schemas']['UncertaintyScorer']
      )[];
      /**
       * Registered Scorers
       * @description List of registered scorers to enable.
       */
      registered_scorers?: components['schemas']['RegisteredScorerConfig'][];
      /**
       * Generated Scorers
       * @description List of generated scorers to enable.
       */
      generated_scorers?: components['schemas']['GeneratedScorerConfig'][];
      /**
       * Workflows
       * @description List of workflows to include in the run.
       */
      workflows: (
        | components['schemas']['WorkflowStep']
        | components['schemas']['ChainStep']
        | components['schemas']['LlmStep']
        | components['schemas']['RetrieverStep']
        | components['schemas']['ToolStep']
        | components['schemas']['AgentStep']
      )[];
      /**
       * Project Id
       * @description Evaluate Project ID to which the run should be associated.
       */
      project_id?: string | null;
      /**
       * Project Name
       * @description Evaluate Project name to which the run should be associated. If the project does not exist, it will be created.
       */
      project_name?: string | null;
      /**
       * Run Name
       * @description Name of the run. If no name is provided, a timestamp-based name will be generated.
       */
      run_name?: string | null;
    };
    /** EvaluateRunResponse */
    EvaluateRunResponse: {
      /** Message */
      message: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** Project Name */
      project_name: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Run Name */
      run_name: string;
      /** Workflows Count */
      workflows_count: number;
      /** Records Count */
      records_count: number;
    };
    /** EvaluateRunResultsRequest */
    EvaluateRunResultsRequest: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /** Project Id */
      project_id?: string | null;
      /** Project Name */
      project_name?: string | null;
      /** Run Id */
      run_id?: string | null;
      /** Run Name */
      run_name?: string | null;
    };
    /**
     * ExecutionStatus
     * @description Status of the execution.
     * @enum {string}
     */
    ExecutionStatus:
      | 'triggered'
      | 'failed'
      | 'error'
      | 'timeout'
      | 'paused'
      | 'not_triggered';
    /** ExperimentCreateRequest */
    ExperimentCreateRequest: {
      /** Name */
      name: string;
    };
    /** ExperimentResponse */
    ExperimentResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Name */
      name: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** Created By */
      created_by?: string | null;
    };
    /** ExperimentUpdateRequest */
    ExperimentUpdateRequest: {
      /** Name */
      name: string;
    };
    /** ExportRequest */
    ExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
    };
    /**
     * ExtraAlertFilters
     * @description Extra filters for alerts.
     *
     *     For simplicity of use, all types should be str to make filtering in the DB easier
     */
    ExtraAlertFilters: {
      /** Map Threshold */
      map_threshold?: string | null;
    };
    /** FactualityTemplate */
    FactualityTemplate: {
      /**
       * Metric System Prompt
       * @default # Task
       *
       *     You will be given a prompt that was sent to a large language model (LLM), and the LLM's response. Your task is to assess whether the response is factually correct.
       *
       *     ## Task output format
       *
       *     You must respond in the following JSON format:
       *
       *     ```
       *     {
       *         "explanation": string
       *         "was_factual": boolean
       *     }
       *     ```
       *
       *     "explanation": Your step-by-step reasoning process. List out the claims made in the response, and for each claim, provide a detailed explanation of why that claim is or is not factual.
       *
       *     "was_factual": `true` if the response was completely factually correct according to the instructions above, `false` otherwise.
       *
       *     You must respond with a valid JSON string.
       *
       *     ## Task guidelines
       *
       *     ### Input format
       *
       *     In some cases, the prompt may include multiple messages of chat history. If so, each message will begin with one of the following prefixes:
       *
       *     - "System: "
       *     - "Human: "
       *     - "AI: "
       *
       *     ### How to determine the value of `was_factual`
       *
       *     - was_factual should be false if anything in the response is factually incorrect, and true otherwise.
       *     - If the response omits some useful information, but does not include any falsehoods, was_factual should be true.
       *     - The prompt itself may contain false information. If the response repeats this false information, was_factual should be false. In other words, do not assume that the prompt is factually correct when evaluating the response.
       *     - If the prompt and response involve a domain where the concept of "factual accuracy" doesn't strictly apply, assess whatever quality of the response is most intuitively similar to factual accuracy. For example, if the prompt asks the LLM to write code, assess whether the code is free of syntax errors and implements the intended logic.
       *
       *     ### Writing the explanation
       *
       *     - As stated above, a typical explanation should list out the claims made in the response, and for each claim, provide a detailed explanation of why that claim is or is not factual.
       *     - If the response doesn't make claims per se, break down the response into constituent parts in the most natural way given its content. For example, in code generation tasks, you might break down the response into individual functions or lines of code.
       *     - Work step by step, and do not give an overall assessment of the response until the end of your explanation.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @description Description of what the metric should do.
       */
      metric_description?: string | null;
      /**
       * Value Field Name
       * @default was_factual
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default The prompt was:
       *
       *     ```
       *     {query}
       *     ```
       *
       *     The response was:
       *
       *     ```
       *     {response}
       *     ```
       *
       *     Respond with a JSON object having two fields: `explanation` (string) and `was_factual` (boolean). Everything in your response should be valid JSON.
       *
       *     REMEMBER: if the prompt asks the LLM to compose an answer on the basis of a "context" or other reference text or texts, you MUST IGNORE these texts when evaluating the response. Evaluate the response as though the reference texts were NOT provided. Do NOT refer to these texts in your evaluation.
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @default [
       *       {
       *         "generation_prompt_and_response": "The prompt was:\n\n```\nI have heard people talking about the chess move \"en passant\", but I don't know what it is and how it works. Could you explain it to me?\n```\n\nThe response was:\n\n```\nCertainly! \"En passant\" is a special rule in chess that allows a pawn to capture an enemy pawn that has moved two squares forward from its initial position, as if it had only moved one square forward. This can only be done on the ensuing move, and only if the capturing pawn was on its fifth rank at the time the enemy pawn made its double-move. Here's an example to illustrate:\n\n1. e4 e5\n2. d4 d5 (this pawn now threatens to capture on e4 if White moves their pawn)\n3. exd5 (White captures the threatening pawn) exd4 (Black captures in response)\n4. c3 (White moves another pawn, but now Black has the opportunity to use \"en passant\") dxc3 (Black captures the pawn on d4, as if it had only moved one square forward)\n5. Nxc3\n\nI hope that helps!\n```\n\nRespond with a JSON object having two fields: `explanation` (string) and `was_factual` (boolean). Everything in your response should be valid JSON.",
       *         "evaluating_response": "{\n    \"explanation\": \"The response makes several claims about the meaning of \\\"en passant\\\" in chess, then provides an illustrative example. Let's evaluate the claims first, then the example.\\n\\n# Claims\\n\\n1. The response claims that 'en passant' is a special rule in chess that allows a pawn to capture an enemy pawn that has moved two squares forward from its initial position, as if it had only moved one square forward. This claim is factually correct, as 'en passant' indeed allows for such a capture under specified conditions.\\n\\n2. The response also claims that this capture can only be done on the ensuing move and only if the capturing pawn was on its fifth rank at the time. This is also factually correct, as one of the requirements for the 'en passant' capture is that the capturing pawn must be on the fifth rank when the opponent's pawn moves two squares forward.\\n\\n# Illustrative Example\\n\\nFor the purposes of this metric, we'll say that a chess example like this one is \\\"correct\\\" if\\n\\n- All the moves are valid according to the rules of chess\\n- The example demonstrates what it is intended to demonstrate (in this case, the en passant rule)\\n\\nTo check these conditions, let's waslk through the example one move at a time, with a clear description of the board state after each move.\\n\\n### Initial Position\\nThe game starts with the standard initial setup of the chessboard.\\n\\n### Move 1\\n**1. e4 e5**\\n\\n- **White moves pawn from e2 to e4.**\\n  This opens lines for the bishop and queen and controls the center.\\n- **Black moves pawn from e7 to e5.**\\n  This mirrors White's move, also controlling the center.\\n\\n**Board State:**\\n```\\nr n b q k b n r\\np p p     p p p\\n\\n        P\\n        p\\n\\nP P P     P P P\\nR N B Q K B N R\\n```\\n\\n### Move 2\\n**2. d4 d5**\\n\\n- **White moves pawn from d2 to d4.**\\n  Now, White controls more central space and threatens the pawn on e5.\\n- **Black moves pawn from d7 to d5.**\\n  Black counters by challenging the center with another pawn.\\n\\n**Board State:**\\n```\\nr n b q k b n r\\np p   p   p p p\\n\\n        P\\n  p P p P\\n\\nP   P     P P P\\nR N B Q K B N R\\n```\\n\\n### Move 3\\n**3. exd5 exd4**\\n\\n- **White captures the pawn on d5 with the pawn from e4 (exd5).**\\n  Now White has a pawn on d5.\\n- **Black incorrectly moves to exd4.**\\n  According to the rules of chess, this is an illegal move because the pawn on e5 cannot capture a pawn on d4 directly. The pawn on d4 does not exist; the move should capture diagonally if there is a piece or pawn on d4.\\n\\nSince there is an error in Move 3, the illustrative example is not factually correct according to the criteria listed above. Therefore, the example as a whole is not entirely factually correct.\",\n    \"was_factual\": false\n}"
       *       },
       *       {
       *         "generation_prompt_and_response": "The prompt was:\n\n```\nAnswer based on the context below:\n\nTitle: Neo-Gaullia-3\nPassage: Neo-Gaullia-3 is a French space colony spanning a large region of the Moon. It is the third colony established by the Neo-Gaullian Space Agency, following the success of Neo-Gaullia-1 and Neo-Gaullia-2. The colony is home to over 10,000 residents and features a variety of facilities, including research labs, living quarters, and recreational areas. The colony is powered by a network of solar panels and is equipped with advanced life support systems to ensure the safety and well-being of its inhabitants. Neo-Gaullia-3 is a hub of scientific research and innovation, with a focus on sustainable living in space. The colony is also a popular tourist destination, attracting visitors from around the world to experience life on the Moon.\n\nQuestion: How many French space colonies have existed on the Moon?\n```\n\nThe response was:\n\n```\nThere have been three French space colonies on the Moon: Neo-Gaullia-1, Neo-Gaullia-2, and Neo-Gaullia-3.\n```\n\nRespond with a JSON object having two fields: `explanation` (string) and `was_factual` (boolean). Everything in your response should be valid JSON.",
       *         "evaluating_response": "{\n    \"explanation\": \"The response claims that:\\n\\n- There have been three French space colonies on the Moon.\\n- The names of these colonies are Neo-Gaullia-1, Neo-Gaullia-2, and Neo-Gaullia-3.\\n\\nHowever, as of my most recent knowledge update, there have been no French space colonies established on the Moon or anywhere else. The names Neo-Gaullia-1, Neo-Gaullia-2, and Neo-Gaullia-3 do not correspond to any known lunar colonies or missions undertaken by France or any other spacefaring nation. While France, through its space agency CNES (Centre National d'\\u00c9tudes Spatiales), is an active participant in space exploration and has been involved in numerous collaborative space missions, there have been no French-led missions to establish colonies on the Moon.\",\n    \"was_factual\": false\n}"
       *       }
       *     ]
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** FeatureColumnsResponse */
    FeatureColumnsResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Feature Names */
      feature_names: string[];
    };
    /** FeedbackAggregate */
    FeedbackAggregate: {
      /** Aggregate */
      aggregate:
        | components['schemas']['LikeDislikeAggregate']
        | components['schemas']['StarAggregate']
        | components['schemas']['ScoreAggregate']
        | components['schemas']['TagsAggregate'];
    };
    /** FeedbackRatingCreate */
    FeedbackRatingCreate: {
      /** Explanation */
      explanation?: string | null;
      /** Rating */
      rating:
        | components['schemas']['LikeDislikeRating']
        | components['schemas']['StarRating']
        | components['schemas']['ScoreRating']
        | components['schemas']['TagsRating']
        | components['schemas']['TextRating'];
    };
    /** FeedbackRatingDB */
    FeedbackRatingDB: {
      /** Explanation */
      explanation?: string | null;
      /** Rating */
      rating:
        | components['schemas']['LikeDislikeRating']
        | components['schemas']['StarRating']
        | components['schemas']['ScoreRating']
        | components['schemas']['TagsRating']
        | components['schemas']['TextRating'];
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Created By */
      created_by: string | null;
    };
    /**
     * FeedbackRatingOperationType
     * @description Operation type for bulk feedback rating operations.
     * @enum {string}
     */
    FeedbackRatingOperationType: 'create' | 'delete';
    /** FeedbackTemplateCreate */
    FeedbackTemplateCreate: {
      /** Name */
      name: string;
      /**
       * Include Explanation
       * @default false
       */
      include_explanation?: boolean;
      /** Criteria */
      criteria?: string | null;
      /** Constraints */
      constraints:
        | components['schemas']['LikeDislikeConstraints']
        | components['schemas']['StarConstraints']
        | components['schemas']['ScoreConstraints']
        | components['schemas']['TagsConstraints']
        | components['schemas']['TextConstraints'];
    };
    /** FeedbackTemplateDB */
    FeedbackTemplateDB: {
      /** Name */
      name: string;
      /** Include Explanation */
      include_explanation: boolean;
      /** Criteria */
      criteria?: string | null;
      /** Constraints */
      constraints:
        | components['schemas']['LikeDislikeConstraints']
        | components['schemas']['StarConstraints']
        | components['schemas']['ScoreConstraints']
        | components['schemas']['TagsConstraints']
        | components['schemas']['TextConstraints'];
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Created By */
      created_by: string | null;
    };
    /** FeedbackTemplateUpdate */
    FeedbackTemplateUpdate: {
      /** Name */
      name: string;
      /** Criteria */
      criteria: string | null;
    };
    /**
     * FewShotExample
     * @description Few-shot example for a chainpoll metric prompt.
     */
    FewShotExample: {
      /** Generation Prompt And Response */
      generation_prompt_and_response: string;
      /** Evaluating Response */
      evaluating_response: string;
    };
    /**
     * FieldType
     * @enum {string}
     */
    FieldType: 'int' | 'float' | 'string' | 'array' | 'bool';
    /**
     * FileType
     * @enum {string}
     */
    FileType: 'csv' | 'json' | 'parquet' | 'arrow' | 'zip';
    /** FilterOptionsResponse */
    FilterOptionsResponse: {
      /** Filter Options */
      filter_options?: {
        [key: string]: string[];
      };
    };
    /** FilterParams */
    FilterParams: {
      /**
       * Ids
       * @default []
       */
      ids?: number[];
      /** Similar To */
      similar_to?: number[] | null;
      /** Num Similar To */
      num_similar_to?: number | null;
      /** Text Pat */
      text_pat?: string | null;
      /** Regex */
      regex?: boolean | null;
      /** Data Error Potential High */
      data_error_potential_high?: number | null;
      /** Data Error Potential Low */
      data_error_potential_low?: number | null;
      /** Misclassified Only */
      misclassified_only?: boolean | null;
      /** Gold Filter */
      gold_filter?: string[] | null;
      /** Pred Filter */
      pred_filter?: string[] | null;
      /** Meta Filter */
      meta_filter?: components['schemas']['MetaFilter'][] | null;
      /** Drift Score Threshold */
      drift_score_threshold?: number | null;
      /** Is Drifted */
      is_drifted?: boolean | null;
      /** Span Sample Ids */
      span_sample_ids?: number[] | null;
      /** Span Text */
      span_text?: string | null;
      /**
       * Span Regex
       * @default false
       */
      span_regex?: boolean | null;
      /**
       * Exclude Ids
       * @default []
       */
      exclude_ids?: number[];
      lasso?: components['schemas']['LassoSelection'] | null;
      /** Class Filter */
      class_filter?: string[] | null;
      /** Likely Mislabeled */
      likely_mislabeled?: boolean | null;
      /**
       * Likely Mislabeled Dep Percentile
       * @default 0
       */
      likely_mislabeled_dep_percentile?: number | null;
      /** Cbo Clusters */
      cbo_clusters?: number[] | null;
      /**
       * Data Embs
       * @default false
       */
      data_embs?: boolean | null;
      /** Confidence High */
      confidence_high?: number | null;
      /** Confidence Low */
      confidence_low?: number | null;
      /** Is Otb */
      is_otb?: boolean | null;
      /** Image Ids */
      image_ids?: number[] | null;
      /** Cluster Ids */
      cluster_ids?: number[] | null;
      /** Correctly Classified */
      correctly_classified?: boolean | null;
      /** Is Edited */
      is_edited?: boolean | null;
    };
    /** FilterPercentageRequest */
    FilterPercentageRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
    };
    /** FilterPercentageResponse */
    FilterPercentageResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /** Percentage */
      percentage: number;
      /** Sample Count */
      sample_count: number;
      /** Sample Easy Percentage */
      sample_easy_percentage?: number | null;
      /** Sample Hard Percentage */
      sample_hard_percentage?: number | null;
      /** Sample Misclassified Percentage */
      sample_misclassified_percentage?: number | null;
      /** Sample Otb Percentage */
      sample_otb_percentage?: number | null;
      /** Sample Drifted Percentage */
      sample_drifted_percentage?: number | null;
      /** Span Count */
      span_count?: number | null;
      /** Span Percentage */
      span_percentage?: number | null;
      /** Sample Mislabeled Percentage */
      sample_mislabeled_percentage?: number | null;
      /** Gold Box Count */
      gold_box_count?: number | null;
      /** Gold Box Percentage */
      gold_box_percentage?: number | null;
      /** Pred Box Count */
      pred_box_count?: number | null;
      /** Pred Box Percentage */
      pred_box_percentage?: number | null;
      /** Gold Polygon Count */
      gold_polygon_count?: number | null;
      /** Gold Polygon Percentage */
      gold_polygon_percentage?: number | null;
      /** Pred Polygon Count */
      pred_polygon_count?: number | null;
      /** Pred Polygon Percentage */
      pred_polygon_percentage?: number | null;
      /** Sample Error Percentage */
      sample_error_percentage?: number | null;
      /** Label Noise Pct */
      label_noise_pct?: number | null;
      /** Feature Noise Pct */
      feature_noise_pct?: number | null;
    };
    /** FiltersRequestBody */
    FiltersRequestBody: {
      /** Filters */
      filters?: components['schemas']['QueryFilterV1'][];
    };
    /** GenAIProjectSettings */
    GenAIProjectSettings: {
      scorers_config?: components['schemas']['ScorersConfig'] | null;
      alerts_configuration?:
        | components['schemas']['AlertsConfiguration']
        | null;
    };
    /** GeneratedScorer */
    GeneratedScorer: {
      /** Id */
      id?: string | null;
      /** Name */
      name?: string | null;
    };
    /**
     * GeneratedScorerAction
     * @enum {string}
     */
    GeneratedScorerAction: 'update' | 'delete';
    /** GeneratedScorerConfig */
    GeneratedScorerConfig: {
      /**
       * Name
       * @description Name of the scorer to enable.
       */
      name: string;
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** GeneratedScorerConfiguration */
    GeneratedScorerConfiguration: {
      /**
       * Model Alias
       * @default GPT-4o mini
       */
      model_alias?: string | null;
      /**
       * Num Judges
       * @default 3
       */
      num_judges?: number | null;
    };
    /** GeneratedScorerResponse */
    GeneratedScorerResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Name */
      name: string;
      /** Instructions */
      instructions: string;
      chain_poll_template: components['schemas']['ChainPollTemplate'];
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Scoreable Node Types */
      scoreable_node_types: components['schemas']['NodeType'][] | null;
      scorer_configuration: components['schemas']['GeneratedScorerConfiguration'];
    };
    /** GeneratedScorerTaskResultResponse */
    GeneratedScorerTaskResultResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      status: components['schemas']['GeneratedScorerTaskResultStatus'];
      result_type: components['schemas']['GeneratedScorerTaskResultType'];
      /** Result */
      result?:
        | components['schemas']['AutoGenResult']
        | components['schemas']['GeneratedScorerValidationResult']
        | string
        | null;
    };
    /**
     * GeneratedScorerTaskResultStatus
     * @enum {string}
     */
    GeneratedScorerTaskResultStatus: 'pending' | 'completed' | 'failed';
    /**
     * GeneratedScorerTaskResultType
     * @enum {string}
     */
    GeneratedScorerTaskResultType: 'scorer_auto_gen' | 'scorer_validation';
    /** GeneratedScorerValidationRequest */
    GeneratedScorerValidationRequest: {
      /** Query */
      query: string;
      /** Response */
      response: string;
      scorer_configuration: components['schemas']['GeneratedScorerConfiguration'];
      chain_poll_template: components['schemas']['ChainPollTemplate'];
    };
    /** GeneratedScorerValidationResponse */
    GeneratedScorerValidationResponse: {
      /**
       * Task Result Id
       * Format: uuid4
       */
      task_result_id: string;
    };
    /**
     * GeneratedScorerValidationResult
     * @description Result of a generated scorer validation job.
     */
    GeneratedScorerValidationResult: {
      /** Rating */
      rating: number | null;
      /** Explanation */
      explanation: string | null;
    };
    /** GenerationRequest */
    GenerationRequest: {
      /** Instructions */
      instructions: string;
    };
    /** GenerationResponse */
    GenerationResponse: {
      /**
       * Task Result Id
       * Format: uuid4
       */
      task_result_id: string;
    };
    /**
     * GenericAction
     * @enum {string}
     */
    GenericAction:
      | 'generic_create'
      | 'generic_read'
      | 'generic_update'
      | 'generic_delete';
    /**
     * GenericPermission
     * @description Generic permissions describe what a user GENERALLY can and cannot do.
     *
     *     The actions are not specific to a resource instance (e.g. create). More fine-grained permissions should also be set
     *     in the authorization policies.
     */
    GenericPermission: {
      resource: components['schemas']['ResourceKind'];
      action: components['schemas']['GenericAction'];
      /** Allowed */
      allowed: boolean;
      /** Message */
      message?: string | null;
    };
    /** GetApiKeyResponse */
    GetApiKeyResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Last Used */
      last_used?: string | null;
      /** Project Id */
      project_id?: string | null;
      project_role?: components['schemas']['CollaboratorRole'] | null;
      /** Description */
      description: string;
      /**
       * Expires At
       * @description Expiry date for the API key
       */
      expires_at?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Truncated */
      truncated: string;
    };
    /** GetObserveWorkflowsRequest */
    GetObserveWorkflowsRequest: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /** Filters */
      filters?: components['schemas']['UserMetadataFilter'][];
    };
    /** GetPresignedUrlResponse */
    GetPresignedUrlResponse: {
      /** Url */
      url: string;
    };
    /** GetProjectsPaginatedResponse */
    GetProjectsPaginatedResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Projects */
      projects: components['schemas']['ProjectDB'][];
    };
    /** GetPromptRowsColumnarResponse */
    GetPromptRowsColumnarResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Columns */
      columns?: components['schemas']['PromptRowColumn'][];
      /** Num Filtered Rows */
      num_filtered_rows?: number | null;
      /** Num Rows */
      num_rows?: number | null;
    };
    /** GetPromptRowsResponse */
    GetPromptRowsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Rows */
      rows?: components['schemas']['PromptRow'][];
    };
    /** GetPromptRun */
    GetPromptRun: {
      /**
       * Hallucination Severity
       * @default 0
       */
      hallucination_severity?: number;
      /** Name */
      name?: string | null;
      /** Project Id */
      project_id?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Num Samples */
      num_samples: number;
      /** Winner */
      winner: boolean;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      task_type?: components['schemas']['TaskType'] | null;
      /**
       * Last Updated By
       * Format: uuid4
       */
      last_updated_by: string;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagDB'][];
      /**
       * Job Id
       * Format: uuid4
       */
      job_id: string;
      job_status: components['schemas']['JobStatus'];
      /** Model Alias */
      model_alias?: string | null;
      /** Template Id */
      template_id?: string | null;
      /** Dataset Id */
      dataset_id?: string | null;
      /** Template Version Id */
      template_version_id?: string | null;
      /** Template Version */
      template_version?: number | null;
      /** Template Version Selected */
      template_version_selected?: boolean | null;
      /**
       * Total Responses
       * @default 0
       */
      total_responses?: number;
      /** Metrics */
      metrics?: {
        [key: string]:
          | number
          | string
          | components['schemas']['FeedbackAggregate']
          | null;
      };
      /** Average Hallucination */
      average_hallucination?: number | null;
      /** Average Bleu */
      average_bleu?: number | null;
      /** Average Rouge */
      average_rouge?: number | null;
      /** Average Cost */
      average_cost?: number | null;
      /** Average Latency */
      average_latency?: number | null;
      /** Total Cost */
      total_cost?: number | null;
      prompt_settings?: components['schemas']['PromptRunSettings'] | null;
      prompt_scorers_configuration?: components['schemas']['ScorersConfiguration'];
      /** Prompt Registered Scorers Configuration */
      prompt_registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Prompt Generated Scorers Configuration */
      prompt_generated_scorers_configuration?: string[] | null;
      /** Prompt Customized Scorers Configuration */
      prompt_customized_scorers_configuration?:
        | (
            | components['schemas']['CustomizedAgenticWorkflowSuccessGPTScorer']
            | components['schemas']['CustomizedChunkAttributionUtilizationGPTScorer']
            | components['schemas']['CustomizedCompletenessGPTScorer']
            | components['schemas']['CustomizedFactualityGPTScorer']
            | components['schemas']['CustomizedGroundednessGPTScorer']
            | components['schemas']['CustomizedInstructionAdherenceGPTScorer']
            | components['schemas']['CustomizedGroundTruthAdherenceGPTScorer']
            | components['schemas']['CustomizedToolSelectionQualityGPTScorer']
            | components['schemas']['CustomizedToolErrorRateGPTScorer']
          )[]
        | null;
    };
    /** GetPromptRunColumnsResponse */
    GetPromptRunColumnsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Columns */
      columns?: components['schemas']['PromptRunColumn'][];
      /** Num Filtered Rows */
      num_filtered_rows?: number | null;
      /** Num Rows */
      num_rows?: number | null;
    };
    /** GetPromptRunsResponse */
    GetPromptRunsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Runs */
      runs?: components['schemas']['GetPromptRun'][];
    };
    /** GetSplitsResponse */
    GetSplitsResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Splits */
      splits: components['schemas']['Split'][];
      /** Inference Comparison Splits */
      inference_comparison_splits: components['schemas']['Split'][];
    };
    /** GetTokenResponse */
    GetTokenResponse: {
      /** Access Token */
      access_token: string;
      /**
       * Token Type
       * @default bearer
       */
      token_type?: string;
      /**
       * Expires At
       * Format: date-time
       */
      expires_at: string;
    };
    /** GetUserLatestRunsDB */
    GetUserLatestRunsDB: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Runs */
      runs?: components['schemas']['RunDBThinWithProjectName'][];
    };
    /** GetUserResponse */
    GetUserResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /** Email Is Verified */
      email_is_verified?: boolean | null;
      /**
       * Organization Id
       * Format: uuid4
       */
      organization_id: string;
      /** Organization Name */
      organization_name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Projects Count */
      projects_count: number;
      /** Runs Count */
      runs_count: number;
    };
    /** GetUsersResponse */
    GetUsersResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Users */
      users: components['schemas']['GetUserResponse'][];
    };
    /** GroundTruthAdherenceScorer */
    GroundTruthAdherenceScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'ground_truth_adherence';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default plus
       * @constant
       */
      type?: 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /** GroundTruthAdherenceTemplate */
    GroundTruthAdherenceTemplate: {
      /**
       * Metric System Prompt
       * @default I will give you two different texts, called the "ground truth" and the "response."
       *
       *     Read both texts, then tell me whether they are "equivalent," in the sense that they basically mean the same thing.
       *
       *     Keep the following guidelines in mind.
       *
       *     - Two texts can be equivalent if they use different phrasing, as long as the phrasing doesn't affect meaning.
       *     - Two texts can be equivalent if there are _slight_ differences in meaning that wouldn't affect the conclusions that a reasonable reader would draw upon reading them.
       *     - Imagine that you are grading a free-response exam.  The ground truth given in the answer key for an exam question, and the response is a student's answer to the same question. If you would give the student full marks for this question, that means the two texts are equivalent. If you wouldn't, that means the two texts are not equivalent.
       *
       *     Respond in the following JSON format:
       *
       *     ```
       *     {{
       *         "explanation": string,
       *         "equivalent": boolean
       *     }}
       *     ```
       *
       *     "explanation": A step-by-step breakdown of the similarities and differences between the text. For each difference you note (if any), consider why the difference might or might not make the texts non-equivalent, note down your reasoning clearly and explicitly, and ultimately draw a conclusion about whether that difference makes the text non-equivalent.
       *
       *     "equivalent": `true` if the texts are equivalent in the sense given above, `false` if they are non-equivalent.
       *
       *     You must respond with valid JSON.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @default This metric computes whether a response from a large language model matches a provided ground truth text.
       */
      metric_description?: string;
      /**
       * Value Field Name
       * @default equivalent
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default Ground truth:
       *
       *     ```
       *     {ground_truth}
       *     ```
       *
       *     Response:
       *
       *     ```
       *     {response}
       *     ```
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @description Few-shot examples for the metric.
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /**
     * GroundednessTemplate
     * @description Template for the groundedness metric,
     *     containing all the info necessary to send the groundedness prompt.
     */
    GroundednessTemplate: {
      /**
       * Metric System Prompt
       * @default The user will provide you with a prompt that was sent to an automatic question-answering system, and that system's response. Both will be provided as JSON strings.
       *
       *     The prompt will contain one or more documents intended as context which the question-answering system was given as reference material.
       *
       *     Your task is to determine whether the answer was supported by the documents.
       *
       *     Think step by step, and explain your reasoning carefully.
       *     State your observations first, before drawing any conclusions.
       *
       *     Respond in the following JSON format:
       *
       *     ```
       *     {
       *         "explanation": string,
       *         "was_supported": boolean
       *     }
       *     ```
       *
       *     "explanation": Your step-by-step reasoning process. List out the claims made in the response, and for each claim, provide a detailed explanation of why that claim is or is not supported by the documents.
       *
       *     "was_supported": `true` if the response was supported by the documents, `false` otherwise.
       *
       *     You must respond with valid JSON.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @default I have a RAG (retrieval-augmented generation) system that generates text based on one or more documents that I always include in my prompts. I want a metric that checks whether the generated text was supported by information in the documents. The metric should exhaustively check each claim in the response against the documents, one by one, listing them out explicitly.
       */
      metric_description?: string;
      /**
       * Value Field Name
       * @default was_supported
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default Prompt JSON:
       *
       *     ```
       *     {query_json}
       *     ```
       *
       *     Response JSON:
       *
       *     ```
       *     {response_json}
       *     ```
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @default [
       *       {
       *         "generation_prompt_and_response": "Prompt JSON:\n\n```\n\"Context: In the city, the population was distributed as 28.3% under the age of 18, 11.3% from 18 to 24, 32.7% from 25 to 44, 18.2% from 45 to 64, and 9.6% who were 65 years of age or older. The median age was 31 years. For every 100 females, there were 97.3 males. For every 100 females age 18 and over, there were 94.5 males.\\n\\nQuestion: How many in percent weren't 65 years of age or older?\"\n```\n\nResponse JSON:\n\n```\n\"90.4%\"\n```",
       *         "evaluating_response": "{\n    \"explanation\": \"This response makes a single claim: that 90.4% of the population is not 65 years of age or older.\\n\\nAccording to the provided document, 9.6% of the population is 65 years of age or older. To find the percentage of people who are not 65 years of age or older, we subtract this percentage from 100%:\\n100% - 9.6% = 90.4%\\n\\nThis matches the percentage in the claim, so the claim is supported.\\n\\nSince this is the only claim made in the response, and it was supported, the response is supported as a whole.\",\n    \"was_supported\": true\n}"
       *       }
       *     ]
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /**
     * GroupAction
     * @enum {string}
     */
    GroupAction: 'update' | 'list_members' | 'join' | 'request_to_join';
    /**
     * GroupByMetrics
     * @description Metrics for a cohort returned in columnar format.
     *
     *     Each field in the class is of equal length (or len 0), mapping to the y-axis
     *     of each chart. The labels field contains the x-axis labels which apply to all
     *     y-axes for all charts created for this data.
     *
     *     ex:
     *         labels: ["apple", "banana", "orange"]
     *         precision: [0.95, 0.55, 0.83]
     *         recall: [0.93, 0.25, 0.88]
     *         ...
     */
    GroupByMetrics: {
      /** Labels */
      labels?: (string | number | boolean)[];
      /**
       * Recall
       * @default []
       */
      recall?: number[];
      /**
       * F1
       * @default []
       */
      f1?: number[];
      /**
       * Precision
       * @default []
       */
      precision?: number[];
      /**
       * Confidence
       * @default []
       */
      confidence?: number[];
      /**
       * Support
       * @default []
       */
      support?: number[];
      /**
       * Data Error Potential
       * @default []
       */
      data_error_potential?: number[];
      /**
       * Missed Label
       * @default []
       */
      missed_label?: number[];
      /**
       * Span Shift
       * @default []
       */
      span_shift?: number[];
      /**
       * Wrong Tag
       * @default []
       */
      wrong_tag?: number[];
      /**
       * Ghost Span
       * @default []
       */
      ghost_span?: number[];
      /**
       * Total Errors
       * @default []
       */
      total_errors?: number[];
    };
    /** GroupCollaborator */
    GroupCollaborator: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      role: components['schemas']['CollaboratorRole'];
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Group Id
       * Format: uuid4
       */
      group_id: string;
      /** Group Name */
      group_name: string;
    };
    /** GroupCollaboratorCreate */
    GroupCollaboratorCreate: {
      /** @default viewer */
      role?: components['schemas']['CollaboratorRole'];
      /**
       * Group Id
       * Format: uuid4
       */
      group_id: string;
    };
    /** GroupCreate */
    GroupCreate: {
      /** Name */
      name: string;
      /** Description */
      description?: string | null;
      /** @default public */
      visibility?: components['schemas']['GroupVisibility'];
      /**
       * Users
       * @default []
       */
      users?: components['schemas']['GroupMemberCreate'][];
    };
    /** GroupDB */
    GroupDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /** Name */
      name: string;
      /** Description */
      description?: string | null;
      /** @default public */
      visibility?: components['schemas']['GroupVisibility'];
      /** Size */
      size: number;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** @description The role of the current user in the group. */
      role?: components['schemas']['GroupRole'] | null;
    };
    /**
     * GroupLabel
     * @description Group labels for prompt rows.
     * @enum {string}
     */
    GroupLabel:
      | 'Input Quality'
      | 'Output Quality'
      | 'Configuration'
      | 'LLM Parameters'
      | 'RAG Quality'
      | 'RAG Parameters'
      | 'Generic Parameters'
      | 'Safety Metrics'
      | 'Protect'
      | 'System Metrics'
      | 'Rating Summary'
      | 'Custom Metrics'
      | 'Security'
      | 'Dataset'
      | 'Agent Quality';
    /**
     * GroupMemberAction
     * @enum {string}
     */
    GroupMemberAction: 'update_role' | 'delete';
    /** GroupMemberCreate */
    GroupMemberCreate: {
      /**
       * User Id
       * Format: uuid4
       */
      user_id: string;
      /** @default member */
      role?: components['schemas']['GroupRole'];
    };
    /** GroupMemberDB */
    GroupMemberDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * User Id
       * Format: uuid4
       */
      user_id: string;
      group_role: components['schemas']['GroupRole'];
      /** First Name */
      first_name: string | null;
      /** Last Name */
      last_name: string | null;
      /** Email */
      email: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
    };
    /** GroupMemberUpdate */
    GroupMemberUpdate: {
      role: components['schemas']['GroupRole'];
    };
    /**
     * GroupRole
     * @enum {string}
     */
    GroupRole: 'maintainer' | 'member' | 'pending';
    /** GroupRoleInfo */
    GroupRoleInfo: {
      name: components['schemas']['GroupRole'];
      /** Display Name */
      display_name: string;
      /** Description */
      description: string;
    };
    /** GroupUpdate */
    GroupUpdate: {
      /** Name */
      name: string;
      /** Description */
      description: string | null;
      visibility: components['schemas']['GroupVisibility'];
    };
    /**
     * GroupVisibility
     * @enum {string}
     */
    GroupVisibility: 'public' | 'private' | 'hidden';
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components['schemas']['ValidationError'][];
    };
    /** HallucinationSegment */
    HallucinationSegment: {
      /**
       * Hallucination Severity
       * @default 0
       */
      hallucination_severity?: number;
      /** Start */
      start: number;
      /** End */
      end: number;
      /** Hallucination */
      hallucination: number;
    };
    /** HasEmbeddingsResponse */
    HasEmbeddingsResponse: {
      /**
       * Has Data Embs
       * @default false
       */
      has_data_embs?: boolean;
      /**
       * Has Model Embs
       * @default false
       */
      has_model_embs?: boolean;
    };
    /** HealthcheckResponse */
    HealthcheckResponse: {
      /** Api Version */
      api_version: string;
      /** Message */
      message: string;
      /** Version */
      version: string;
    };
    /**
     * IndexSelector
     * @description Choose specific indexes to apply the bulk operation to.
     */
    IndexSelector: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      selector_type: 'indexes';
      /** Indexes */
      indexes: number[];
    };
    /** InferenceModelMetrics */
    InferenceModelMetrics: {
      /** Confidence */
      confidence: number;
    };
    /** InferenceNamesResponse */
    InferenceNamesResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Inference Names */
      inference_names: string[];
    };
    /** InferenceResults */
    InferenceResults: {
      /** Split Total Sample Count */
      split_total_sample_count: number;
      /** Split Total Span Count */
      split_total_span_count?: number | null;
      /** Sample Count */
      sample_count: number;
      /** Span Count */
      span_count?: number | null;
      /** Has Next Page */
      has_next_page: boolean;
      model_metrics: components['schemas']['InferenceModelMetrics'];
      /**
       * Data Metrics
       * @default []
       */
      data_metrics?: components['schemas']['DataRow'][];
      /** Labels */
      labels: string[];
    };
    /** InferenceRunResults */
    InferenceRunResults: {
      split_name: components['schemas']['Split'];
      /** Inference Name */
      inference_name: string;
      split_run_results: components['schemas']['InferenceResults'];
    };
    /** InputMap */
    InputMap: {
      /** Prompt */
      prompt: string;
      /**
       * Prefix
       * @default
       */
      prefix?: string;
      /**
       * Suffix
       * @default
       */
      suffix?: string;
    };
    /** InputPIIScorer */
    InputPIIScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'input_pii';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** InputSexistScorer */
    InputSexistScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'input_sexist';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** InputToneScorer */
    InputToneScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'input_tone';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** InputToxicityScorer */
    InputToxicityScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'input_toxicity';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** InsightChartRequest */
    InsightChartRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
    };
    /** InsightChartResponse */
    InsightChartResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /** X Labels */
      x_labels: string[];
      /** Y Labels */
      y_labels: string[];
      /** Data */
      data: number[][];
    };
    /**
     * InsightType
     * @enum {string}
     */
    InsightType: 'vertical_bar' | 'horizontal_bar';
    /** InstructionAdherenceScorer */
    InstructionAdherenceScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'instruction_adherence';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default plus
       * @constant
       */
      type?: 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /** InstructionAdherenceTemplate */
    InstructionAdherenceTemplate: {
      /**
       * Metric System Prompt
       * @default The user will provide you with a prompt that was sent to a chatbot system, and the chatbot's latest response. Both will be provided as JSON strings.
       *
       *     In some cases, the prompt may be split up into multiple messages. If so, each message will begin with one of the following prefixes:
       *
       *     - "System: "
       *     - "Human: "
       *     - "AI: "
       *
       *     If you see these prefixes, pay attention to them because they indicate where messages begin and end. Messages prefixed with "System: " contain system instructions which the chatbot should follow. Messages prefixed with "Human: " are user input. Messages prefixed with "AI: " are system responses to user input.
       *     If you do not see these prefixes, treat the prompt as though it was a single user input message prefixed with "Human: ".
       *
       *     Your task is to determine whether the latest response from the chatbot is consistent with the instructions provided in the system prompt (if there is one) or in the first user message (if there is no system prompt).
       *
       *     Focus only on the latest response and the instructions. Do not consider the chat history or any previous messages from the chatbot.
       *
       *     Think step by step, and explain your reasoning carefully.
       *     State your observations first, before drawing any conclusions.
       *
       *     Respond in the following JSON format:
       *
       *     ```
       *     {
       *         "explanation": string,
       *         "is_consistent": boolean
       *     }
       *     ```
       *
       *     "explanation": Your step-by-step reasoning process. List out the relevant instructions and explain whether the latest response adheres to each of them.
       *
       *     "is_consistent": `true` if the latest response is consistent with the instructions, `false` otherwise.
       *
       *     You must respond with a valid JSON string.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @default I have a chatbot application.
       *     My system prompt contains a list of instructions for what the chatbot should and should not do in every interaction. I want a metric that checks whether the latest response from the chatbot is consistent with the instructions.
       *
       *     The metric should only evaluate the latest message (the response), not the chat history. It should return false only if the latest message violates one or more instructions. Violations earlier in the chat history should not affect whether the value is true or false. The value should only depend on whether the latest message was consistent with the instructions, considered in context. The metric should only consider instructions that are applicable to the latest message.
       */
      metric_description?: string;
      /**
       * Value Field Name
       * @default is_consistent
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default Prompt JSON:
       *
       *     ```
       *     {query_json}
       *     ```
       *
       *     Response JSON:
       *
       *     ```
       *     {response_json}
       *     ```
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @default [
       *       {
       *         "generation_prompt_and_response": "Prompt JSON:\n\n```\n\"System: Always be polite and respectful. Do not provide medical advice.\nHuman: Can you tell me what to do if I have a headache?\"\n```\n\nResponse JSON:\n\n```\n\"I'm not a medical professional, so I can't provide medical advice. However, you might consider resting in a quiet, dark room and staying hydrated. If your headache persists, please consult a healthcare provider.\"\n```",
       *         "evaluating_response": "{\n    \"explanation\": \"The relevant instructions are: 'Always be polite and respectful' and 'Do not provide medical advice.'\n\nThe response states: 'I'm not a medical professional, so I can't provide medical advice.' This adheres to the instruction not to provide medical advice.\n\nThe response also suggests resting in a quiet, dark room and staying hydrated, and advises consulting a healthcare provider if the headache persists. These suggestions are general and do not constitute medical advice.\n\nThe tone of the response is polite and respectful.\n\nTherefore, the latest response is consistent with the instructions.\",\n    \"is_consistent\": true\n}"
       *       }
       *     ]
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** IntegrationDB */
    IntegrationDB: {
      name: components['schemas']['IntegrationName'];
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
    };
    /**
     * IntegrationName
     * @enum {string}
     */
    IntegrationName:
      | 'aws_bedrock'
      | 'aws_sagemaker'
      | 'azure'
      | 'databricks'
      | 'labelstudio'
      | 'openai'
      | 'vertex_ai'
      | 'writer'
      | 'anthropic'
      | 'mistral';
    /** InviteUsersRequest */
    InviteUsersRequest: {
      /** Emails */
      emails: string[];
      /** @default user */
      role?: components['schemas']['UserRole'];
      /**
       * Group Ids
       * @default []
       */
      group_ids?: string[];
      /**
       * Send Email
       * @default true
       */
      send_email?: boolean;
    };
    /** InvokeResponse */
    InvokeResponse: {
      /** @default not_triggered */
      status?: components['schemas']['ExecutionStatus'];
      /**
       * Api Version
       * @default 1.0.0
       */
      api_version?: string;
      /**
       * Text
       * @description Text from the request after processing the rules.
       */
      text: string;
      trace_metadata: components['schemas']['TraceMetadata'];
      stage_metadata: components['schemas']['StageMetadata'];
      /**
       * Ruleset Results
       * @description Results of the rule execution.
       */
      ruleset_results?: components['schemas']['RulesetResult'][];
      /**
       * Metric Results
       * @description Results of the metric computation.
       */
      metric_results?: {
        [key: string]: components['schemas']['MetricComputation'];
      };
      action_result: components['schemas']['ActionResult'];
      /**
       * Metadata
       * @description Optional additional metadata. This being echoed back from the request.
       */
      metadata?: {
        [key: string]: string;
      } | null;
      /**
       * Headers
       * @description Optional additional HTTP headers that should be included in the response.
       */
      headers?: {
        [key: string]: string;
      } | null;
    };
    /** JobDB */
    JobDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Failed At */
      failed_at?: string | null;
      /** Completed At */
      completed_at?: string | null;
      /** Processing Started */
      processing_started?: string | null;
      /** Job Name */
      job_name: string;
      /** Migration Name */
      migration_name?: string | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Monitor Batch Id */
      monitor_batch_id?: string | null;
      /** Status */
      status: string;
      /** Retries */
      retries: number;
      /** Request Data */
      request_data: Record<string, never>;
      /** Error Message */
      error_message?: string | null;
      /** Progress Message */
      progress_message?: string | null;
      /**
       * Steps Completed
       * @default 0
       */
      steps_completed?: number;
      /**
       * Steps Total
       * @default 0
       */
      steps_total?: number;
      /**
       * Progress Percent
       * @default 0
       */
      progress_percent?: number;
    };
    /** JobInfo */
    JobInfo: {
      /** @description Job status used for computing the column. Only set for metrics columns that have a separate scorer job. */
      job_status?: components['schemas']['JobStatus'] | null;
      /**
       * Job Progress Message
       * @description Progress message to show the users on hover in case the job is in progress.
       */
      job_progress_message?: string | null;
      /**
       * Job Error Message
       * @description Error message to show the users on hover in case the job fails or errors out.
       */
      job_error_message?: string | null;
      /**
       * Scorer Name
       * @description Scorer Name executed by the job.
       */
      scorer_name?: string | null;
      /** @description Whether a job is designated as plus or basic. */
      job_type?: components['schemas']['ScorerType'] | null;
    };
    /**
     * JobStatus
     * @enum {string}
     */
    JobStatus: 'unstarted' | 'in_progress' | 'completed' | 'error' | 'failed';
    /**
     * LLMExportFormat
     * @enum {string}
     */
    LLMExportFormat: 'csv' | 'jsonl';
    /**
     * LLMIntegration
     * @enum {string}
     */
    LLMIntegration:
      | 'anthropic'
      | 'azure'
      | 'aws_bedrock'
      | 'aws_sagemaker'
      | 'databricks'
      | 'vertex_ai'
      | 'openai'
      | 'writer'
      | 'mistral';
    /**
     * LabelCoOccurences
     * @description Structure for each label co-occurrence response.
     */
    LabelCoOccurences: {
      /** Ids */
      ids: number[];
      /** Labels */
      labels: components['schemas']['TargetLabels'][];
      /** Starting Label */
      starting_label: string;
    };
    /** LabelResponse */
    LabelResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Labels */
      labels: unknown[];
    };
    /**
     * LabelStudioExportRequest
     * @description Schema for requesting data to be sent to labelstudio.
     *
     *     Coming soon!
     */
    LabelStudioExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Workspace */
      workspace?: string | null;
      /** Project Name */
      project_name: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Inference Name */
      inference_name?: string | null;
      /** Labels */
      labels?: string[] | null;
    };
    /**
     * LabelStudioIntegration
     * @description The active labelstudio integration information.
     */
    LabelStudioIntegration: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'labelstudio';
      /** Extra */
      extra?: Record<string, never> | null;
      /** Url */
      url: string;
      /** Is Enterprise */
      is_enterprise: boolean;
    };
    /** LabelStudioIntegrationCreate */
    LabelStudioIntegrationCreate: {
      /** Token */
      token: string;
      /**
       * Url
       * Format: uri
       */
      url: string;
      /** Is Enterprise */
      is_enterprise: boolean;
    };
    /** LabelStudioProject */
    LabelStudioProject: {
      /** Name */
      name: string;
      /** Labels */
      labels: string[];
    };
    /**
     * LassoSelection
     * @description Representation of a lasso selection (used by embeddings)
     *
     *     x and y correspond to the cursor movement while tracing the lasso. This is natively provided by plotly when creating
     *     a lasso selection, for example
     */
    LassoSelection: {
      /** X */
      x: number[];
      /** Y */
      y: number[];
    };
    /** LikeDislikeAggregate */
    LikeDislikeAggregate: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'like_dislike';
      /** Like Count */
      like_count: number;
      /** Dislike Count */
      dislike_count: number;
      /** Unrated Count */
      unrated_count: number;
    };
    /** LikeDislikeConstraints */
    LikeDislikeConstraints: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'like_dislike';
    };
    /** LikeDislikeRating */
    LikeDislikeRating: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'like_dislike';
      /** Value */
      value: boolean;
    };
    /** ListAlertConfigurationsResponse */
    ListAlertConfigurationsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Alerts */
      alerts?: components['schemas']['AlertConfigurationResponse'][];
    };
    /** ListApiKeyResponse */
    ListApiKeyResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Api Keys */
      api_keys: components['schemas']['GetApiKeyResponse'][];
    };
    /** ListDatasetParams */
    ListDatasetParams: {
      /** Filters */
      filters?: (
        | components['schemas']['DatasetNameFilter']
        | components['schemas']['DatasetUsedInProjectFilter']
      )[];
      /**
       * Sort
       * @default {
       *       "name": "created_at",
       *       "ascending": false,
       *       "sort_type": "column"
       *     }
       */
      sort?:
        | (
            | components['schemas']['DatasetNameSort']
            | components['schemas']['DatasetCreatedAtSort']
            | components['schemas']['DatasetUpdatedAtSort']
            | components['schemas']['DatasetProjectLastUsedAtSort']
            | components['schemas']['DatasetProjectsSort']
            | components['schemas']['DatasetRowsSort']
            | components['schemas']['DatasetLastEditedByUserAtSort']
          )
        | null;
    };
    /** ListDatasetResponse */
    ListDatasetResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Datasets */
      datasets?: components['schemas']['DatasetDB'][];
    };
    /** ListDatasetVersionParams */
    ListDatasetVersionParams: {
      /** Sort */
      sort?: components['schemas']['DatasetVersionIndexSort'] | null;
    };
    /** ListDatasetVersionResponse */
    ListDatasetVersionResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Versions */
      versions: components['schemas']['DatasetVersionDB'][];
    };
    /** ListGeneratedScorersResponse */
    ListGeneratedScorersResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Scorers */
      scorers: components['schemas']['GeneratedScorerResponse'][];
    };
    /** ListGroupCollaboratorsResponse */
    ListGroupCollaboratorsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Collaborators */
      collaborators: components['schemas']['GroupCollaborator'][];
    };
    /** ListGroupMembersResponse */
    ListGroupMembersResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Members */
      members: components['schemas']['GroupMemberDB'][];
    };
    /** ListGroupsResponse */
    ListGroupsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Groups */
      groups: components['schemas']['GroupDB'][];
    };
    /** ListMetaRequest */
    ListMetaRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /**
       * Include Stats
       * @default false
       */
      include_stats?: boolean;
    };
    /** ListMetaResponse */
    ListMetaResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Inference Name */
      inference_name?: string | null;
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta */
      meta: components['schemas']['MetaInfo'][];
    };
    /** ListOrganizationsResponse */
    ListOrganizationsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Organizations */
      organizations: components['schemas']['OrganizationDB'][];
    };
    /** ListPromptDatasetResponse */
    ListPromptDatasetResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Datasets */
      datasets?: components['schemas']['PromptDatasetDB'][];
    };
    /** ListRegisteredScorersResponse */
    ListRegisteredScorersResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Scorers */
      scorers: components['schemas']['CreateUpdateRegisteredScorerResponse'][];
    };
    /** ListScorersRequest */
    ListScorersRequest: {
      /** Filters */
      filters?: (
        | components['schemas']['ScorerNameFilter']
        | components['schemas']['ScorerTypeFilter']
        | components['schemas']['ScorerTagsFilter']
        | components['schemas']['ScorerCreatorFilter']
        | components['schemas']['ScorerCreatedAtFilter']
        | components['schemas']['ScorerUpdatedAtFilter']
      )[];
    };
    /** ListScorersResponse */
    ListScorersResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Scorers */
      scorers?: components['schemas']['ScorerResponse'][];
    };
    /** ListUserCollaboratorsResponse */
    ListUserCollaboratorsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Collaborators */
      collaborators: components['schemas']['UserCollaborator'][];
    };
    /** LlmSpan */
    LlmSpan: {
      /**
       * @description Type of the step. By default, it is set to llm. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'llm';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Tools
       * @description List of available tools passed to the LLM on invocation.
       */
      tools?: Record<string, never>[] | null;
      /**
       * Model
       * @description Model used for this step.
       */
      model?: string | null;
      /**
       * Input Tokens
       * @description Number of input tokens.
       */
      input_tokens?: number | null;
      /**
       * Output Tokens
       * @description Number of output tokens.
       */
      output_tokens?: number | null;
      /**
       * Total Tokens
       * @description Total number of tokens.
       */
      total_tokens?: number | null;
      /**
       * Temperature
       * @description Temperature used for generation.
       */
      temperature?: number | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
    };
    /** LlmSpanWithMetrics */
    LlmSpanWithMetrics: {
      /**
       * Trace Id
       * Format: uuid4
       */
      trace_id: string;
      /** Parent Id */
      parent_id?: string | null;
      /**
       * Step Id
       * Format: uuid4
       */
      step_id: string;
      /** Metrics */
      metrics?: {
        [key: string]:
          | components['schemas']['MetricNotComputed']
          | components['schemas']['MetricPending']
          | components['schemas']['MetricComputing']
          | components['schemas']['MetricNotApplicable']
          | components['schemas']['MetricSuccess']
          | components['schemas']['MetricError']
          | components['schemas']['MetricFailed'];
      };
      /**
       * @description Type of the step. By default, it is set to llm. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'llm';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Tools
       * @description List of available tools passed to the LLM on invocation.
       */
      tools?: Record<string, never>[] | null;
      /**
       * Model
       * @description Model used for this step.
       */
      model?: string | null;
      /**
       * Input Tokens
       * @description Number of input tokens.
       */
      input_tokens?: number | null;
      /**
       * Output Tokens
       * @description Number of output tokens.
       */
      output_tokens?: number | null;
      /**
       * Total Tokens
       * @description Total number of tokens.
       */
      total_tokens?: number | null;
      /**
       * Temperature
       * @description Temperature used for generation.
       */
      temperature?: number | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
    };
    /** LlmStep */
    LlmStep: {
      /**
       * @description Type of the step. By default, it is set to llm. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'llm';
      /**
       * Input
       * @description Input to the LLM step.
       */
      input:
        | string
        | {
            [key: string]: string;
          }
        | components['schemas']['Message']
        | string[]
        | {
            [key: string]: string;
          }[]
        | components['schemas']['Message'][];
      /**
       * Output
       * @description Output of the LLM step.
       * @default
       */
      output?:
        | string
        | {
            [key: string]: string;
          }
        | components['schemas']['Message']
        | string[]
        | {
            [key: string]: string;
          }[]
        | components['schemas']['Message'][];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Tools
       * @description List of available tools passed to the LLM on invocation.
       */
      tools?: Record<string, never>[] | null;
      /**
       * Model
       * @description Model used for this step.
       */
      model?: string | null;
      /**
       * Input Tokens
       * @description Number of input tokens.
       */
      input_tokens?: number | null;
      /**
       * Output Tokens
       * @description Number of output tokens.
       */
      output_tokens?: number | null;
      /**
       * Total Tokens
       * @description Total number of tokens.
       */
      total_tokens?: number | null;
      /**
       * Temperature
       * @description Temperature used for generation.
       */
      temperature?: number | null;
    };
    /** LogDataAvailableColumnsRequest */
    LogDataAvailableColumnsRequest: {
      /**
       * Log Stream Id
       * @description Log stream id associated with the traces.
       */
      log_stream_id?: string | null;
      /**
       * Experiment Id
       * @description Experiment id associated with the traces.
       */
      experiment_id?: string | null;
    };
    /** LogDataAvailableColumnsResponse */
    LogDataAvailableColumnsResponse: {
      /** Columns */
      columns?: components['schemas']['LogDataColumnInfo'][];
    };
    /** LogDataColumnInfo */
    LogDataColumnInfo: {
      /**
       * Id
       * @description Unique identifier of the column.  Format is subject to change and should not be used/parsed directly.
       */
      id: string;
      /**
       * Label
       * @description Display label of the column in the UI.
       */
      label?: string | null;
      /** @description Category of the column. */
      category: components['schemas']['ColumnCategory'];
      /**
       * Description
       * @description Description of the column.
       */
      description?: string | null;
      /**
       * Group Label
       * @description Display label of the group (super column) in the UI.
       */
      group_label?: string | null;
      /**
       * Group Description
       * @description Description of the group (super column).
       */
      group_description?: string | null;
      /**
       * @description Data type of the column. This is used to determine how to format the data on the UI.
       * @default unknown
       */
      data_type?: components['schemas']['DataTypeOptions'];
      /** @description Thresholds for the column, if this is a metrics column. */
      threshold?: components['schemas']['MetricThreshold'] | null;
      /**
       * Sortable
       * @description Whether the column is sortable.
       * @default true
       */
      sortable?: boolean;
      /**
       * Filterable
       * @description Whether the column is filterable by value. Doesn't include categorical filters
       * @default true
       */
      filterable?: boolean;
    };
    /** LogDataIDColumnFilter */
    LogDataIDColumnFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'id_column';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
      /** Column Id */
      column_id: string;
    };
    /**
     * LogDataLoggingMethod
     * @enum {string}
     */
    LogDataLoggingMethod: 'python_client' | 'typescript_client' | 'api_direct';
    /** LogDataNodeTypeFilter */
    LogDataNodeTypeFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'node_type';
      /** Value */
      value:
        | components['schemas']['NodeType']
        | components['schemas']['NodeType'][];
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'one_of' | 'not_in';
    };
    /** LogDataQueryRequest */
    LogDataQueryRequest: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Log Stream Id
       * @description Log stream id associated with the traces.
       */
      log_stream_id?: string | null;
      /**
       * Experiment Id
       * @description Experiment id associated with the traces.
       */
      experiment_id?: string | null;
      /**
       * Column Ids
       * @description column ids to return in each row
       */
      column_ids?: string[] | null;
      /** Filters */
      filters?: (
        | components['schemas']['LogDataNodeTypeFilter']
        | components['schemas']['LogDataIDColumnFilter']
      )[];
      /** Sort */
      sort?: components['schemas']['StandardColumnSort'][];
    };
    /** LogDataQueryResponse */
    LogDataQueryResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /**
       * Column Ids
       * @description column ids present in each row
       */
      column_ids?: string[];
      /**
       * Rows
       * @description list of data rows
       */
      rows?: (
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed']
      )[][];
      /**
       * Num Rows
       * @description number of data rows
       */
      num_rows?: number;
    };
    /** LogStreamCreateRequest */
    LogStreamCreateRequest: {
      /** Name */
      name: string;
    };
    /** LogStreamResponse */
    LogStreamResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Name */
      name: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** Created By */
      created_by?: string | null;
    };
    /** LogStreamUpdateRequest */
    LogStreamUpdateRequest: {
      /** Name */
      name: string;
    };
    /**
     * MAPResponse
     * @description The main metric for Object Detection.
     *
     *     mAP, or mean Average Precision, is an Object Detection metric that provides you with a general sense of the
     *     performance of your model.
     *
     *     mAP is not simply the average precision for each class, it is much more technical
     *     https://towardsdatascience.com/breaking-down-mean-average-precision-map-ae462f623a52
     *
     *     We also provide each error and its "score", which represents how much the model
     *     would have improved by fixing each value
     */
    MAPResponse: {
      /** Map */
      map: number;
      /** Map Threshold */
      map_threshold: number;
      ap_per_class: components['schemas']['BarChart'];
      error_scores: components['schemas']['BarChart'];
    };
    /** Message */
    Message: {
      /** Content */
      content: string;
      /** Role */
      role: string | components['schemas']['MessageRole'];
    } & {
      [key: string]: unknown;
    };
    /**
     * MessageRole
     * @enum {string}
     */
    MessageRole:
      | 'agent'
      | 'assistant'
      | 'function'
      | 'system'
      | 'tool'
      | 'user';
    /** Messages */
    Messages: components['schemas']['Message'][];
    /**
     * MetaFilter
     * @description A class for filtering arbitrary metadata columns.
     */
    MetaFilter: {
      /** Name */
      name: string;
      /** Greater Than */
      greater_than?: number | null;
      /** Less Than */
      less_than?: number | null;
      /** Isin */
      isin?: (string | boolean | number | null)[] | null;
      /** Is Equal */
      is_equal?: number | null;
    };
    /**
     * MetaInfo
     * @description Class for describing a metadata column.
     *
     *     Metadata columns and tabular data columns are similar, but metadata columns
     *
     *     a meta column is categorical if it is of string/object type with <= 50 unique values a meta column is continuous if
     *     it is of float/int type
     *
     *     Thus, a column of string type with > 50 unique values is neither continuous nor categorical in our case.
     */
    MetaInfo: {
      /** Name */
      name: string;
      /** Is Categorical */
      is_categorical: boolean;
      /** Is Continuous */
      is_continuous: boolean;
      /** Unique Values */
      unique_values?: unknown[] | null;
      /** Unique Values Full */
      unique_values_full?: unknown[] | null;
      /** Unique Count */
      unique_count?: number | null;
      /** Unique Count Full */
      unique_count_full?: number | null;
      /** Max */
      max?: number | null;
      /** Min */
      min?: number | null;
      /** Mean */
      mean?: number | null;
      /** Zeros */
      zeros?: number | null;
      /** Zeros Pct */
      zeros_pct?: number | null;
      /** Negative */
      negative?: number | null;
      /** Negative Pct */
      negative_pct?: number | null;
      /** Missing */
      missing?: number | null;
      /** Missing Pct */
      missing_pct?: number | null;
      /** High Cardinality */
      high_cardinality?: boolean | null;
    };
    /**
     * MetadataFilter
     * @description Filters on metadata key-value pairs in scorer jobs.
     */
    MetadataFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'metadata';
      /**
       * Filter Type
       * @default map
       * @constant
       */
      filter_type?: 'map';
      /**
       * Operator
       * @enum {string}
       */
      operator: 'one_of' | 'not_in' | 'eq' | 'ne';
      /** Key */
      key: string;
      /** Value */
      value: string | string[];
    };
    /**
     * Method
     * @enum {string}
     */
    Method: 'GET' | 'PUT';
    /** MetricComputation */
    MetricComputation: {
      /** Value */
      value?:
        | number
        | string
        | (number | string | null)[]
        | {
            [key: string]: number | string | null;
          }
        | null;
      /** Execution Time */
      execution_time?: number | null;
      status?: components['schemas']['MetricComputationStatus'] | null;
      /** Error Message */
      error_message?: string | null;
    };
    /**
     * MetricComputationStatus
     * @enum {string}
     */
    MetricComputationStatus: 'success' | 'timeout' | 'failed' | 'error';
    /** MetricComputing */
    MetricComputing: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default computing
       * @constant
       */
      status_type?: 'computing';
      /**
       * Message
       * @default Metric is computing.
       */
      message?: string;
    };
    /** MetricCritique */
    MetricCritique: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** Run Id */
      run_id: string | null;
      /** Metric */
      metric: string;
      /** Row Id */
      row_id: string | number;
      critique_info: components['schemas']['MetricCritiqueContent'];
      metric_inputs: components['schemas']['MetricInputs'];
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Is Computed */
      is_computed: boolean;
      /** Revised Explanation */
      revised_explanation: string | null;
    };
    /** MetricCritiqueColumn */
    MetricCritiqueColumn: {
      /** Col Name */
      col_name: string;
      /** Metric Critique Computing */
      metric_critique_computing: boolean;
    };
    /** MetricCritiqueColumnar */
    MetricCritiqueColumnar: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Is Computed */
      is_computed: boolean;
      /** Revised Explanation */
      revised_explanation: string | null;
      critique_info: components['schemas']['MetricCritiqueContent'];
    };
    /** MetricCritiqueColumns */
    MetricCritiqueColumns: {
      /** Metric Critique Columns */
      metric_critique_columns: components['schemas']['MetricCritiqueColumn'][];
    };
    /** MetricCritiqueContent */
    MetricCritiqueContent: {
      /** Critique */
      critique: string;
      /** Intended Value */
      intended_value: boolean;
      /** Original Explanation */
      original_explanation: string;
    };
    /**
     * MetricCritiqueJobConfiguration
     * @description Info necessary to execute a metric critique job.
     */
    MetricCritiqueJobConfiguration: {
      /** Project Type */
      project_type: 'prompt_evaluation' | 'llm_monitor';
      /** Metric Name */
      metric_name: string;
      /** Critique Ids */
      critique_ids: string[];
      llm_settings?: components['schemas']['PromptRunSettings'];
      /** Recompute Settings */
      recompute_settings?:
        | (
            | components['schemas']['RecomputeSettingsRuns']
            | components['schemas']['RecomputeSettingsProject']
            | components['schemas']['promptgalileo__schemas__metric_critique__RecomputeSettingsObserve']
          )
        | null;
    };
    /**
     * MetricDescriptions
     * @enum {string}
     */
    MetricDescriptions:
      | "A measure of the model's own confusion in its output. Higher scores indicate higher uncertainty."
      | "Measures whether the LLM's response is supported by (or baked in) the context provided. "
      | 'Measures how well the LLM follows the system instructions provided in the prompt.'
      | "Measures how well the workflow's response aligns with the ground truth provided."
      | 'Detects whether the model selected the right Tool with the right arguments.'
      | 'Detects whether the Tool executed successfully (i.e. without errors).'
      | "Measures the relevance of the retrieved context to the user's query as the semantic distance between the two."
      | "Measures the potential presence of factual errors or inconsistencies in the model's response."
      | "Classifies the sentiment of the user's input into one of joy, love, fear, surprise, sadness, anger, annoyance, confusion or neutral."
      | "Measures how 'sexist' a user's input might be perceived ranging in the values of 0-1 (1 being more sexist)."
      | 'Measures the presence and severity of harmful, offensive, or abusive language'
      | "Tracks the presence of personal identifiable information in the user's input"
      | "Classifies the sentiment in the model's response into one of joy, love, fear, surprise, sadness, anger, annoyance, confusion or neutral."
      | "Measures how 'sexist' a response might be perceived ranging in the values of 0-1 (1 being more sexist)."
      | "Measures the presence and severity of harmful, offensive, or abusive language in the model's response"
      | "Tracks the presence of personal identifiable information in the LLM's responses"
      | 'Measures the presence of prompt injection attacks in inputs to the LLM.'
      | 'Measures the perplexity of the prompt. Lower perplexity score is generally considered to be better because it means the model is less surprised by the text and can predict the next word in a sentence with higher accuracy.'
      | 'Measures which documents or chunks retrieved were used by the model to generate a response.'
      | 'Measures how much of the text in the retrieved chunks was used by the model to compose its response.'
      | 'Measures how much of the text in the retrieved chunks was relevant to the response composed by the model.'
      | "A response-level metric measuring 'out of all the information in the context pertinent to the question, how much was covered in the answer?'"
      | 'BLEU is a case-sensitive measurement of the difference between an model generation and target generation at the sentence-level.'
      | 'ROUGE measures the unigram overlap between model generation and target generation as a single F-1 score.'
      | 'Cost of executing the run and does not include any costs incurred for metric calculation.'
      | 'Cost of all the metrics that call the OpenAI API.'
      | 'Detects whether the user successfully accomplished or advanced towards their goal.'
      | 'Measures which documents or chunks retrieved were used by the model to generate a response, and how much of the text in the retrieved chunks was used by the model to compose its response.';
    /** MetricError */
    MetricError: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default error
       * @constant
       */
      status_type?: 'error';
      /**
       * Message
       * @default An error occured.
       */
      message?: string | null;
    };
    /** MetricFailed */
    MetricFailed: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default failed
       * @constant
       */
      status_type?: 'failed';
      /**
       * Message
       * @default Metric failed to compute.
       */
      message?: string | null;
    };
    /**
     * MetricInputs
     * @description Metric inputs for a prompt template.
     *     Include an optional inputs_config to help formatting with a prompt template.
     */
    MetricInputs: {
      /** Query */
      query: string;
      /** Response */
      response: string;
      /** Ground Truth */
      ground_truth?: string | null;
      /** Tools */
      tools?: string | null;
    };
    /** MetricInsight */
    MetricInsight: {
      /** Title */
      title: string;
      /** Column Name */
      column_name: string;
      insight_type: components['schemas']['InsightType'];
      /** Categories */
      categories: {
        [key: string]: number;
      };
      /** Aggregate */
      aggregate?: number | null;
      metric_threshold?: components['schemas']['MetricThreshold'] | null;
    };
    /** MetricNotApplicable */
    MetricNotApplicable: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default not_applicable
       * @constant
       */
      status_type?: 'not_applicable';
      /**
       * Message
       * @default Metric not applicable.
       */
      message?: string;
    };
    /** MetricNotComputed */
    MetricNotComputed: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default not_computed
       * @constant
       */
      status_type?: 'not_computed';
      /**
       * Message
       * @default Metric not computed.
       */
      message?: string;
    };
    /** MetricPending */
    MetricPending: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default pending
       * @constant
       */
      status_type?: 'pending';
    };
    /** MetricSuccess */
    MetricSuccess: {
      scorer_type?: components['schemas']['ScorerType'] | null;
      /**
       * Status Type
       * @default success
       * @constant
       */
      status_type?: 'success';
      /** Value */
      value:
        | string
        | number
        | boolean
        | components['schemas']['Segment']
        | components['schemas']['HallucinationSegment']
        | components['schemas']['Document']
        | components['schemas']['FeedbackRatingDB']
        | components['schemas']['FeedbackAggregate']
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[]
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[][]
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[][][]
        | null;
      /** Display Value */
      display_value?: string | null;
      /** Explanation */
      explanation?: string | null;
      /** Rationale */
      rationale?: string | null;
      /** Cost */
      cost?: number | null;
      /** Model Alias */
      model_alias?: string | null;
      /** Num Judges */
      num_judges?: number | null;
      critique?: components['schemas']['MetricCritiqueColumnar'] | null;
    };
    /** MetricThreshold */
    MetricThreshold: {
      /**
       * Inverted
       * @description Whether the column should be inverted for thresholds, i.e. if True, lower is better.
       * @default false
       */
      inverted?: boolean;
      /**
       * Buckets
       * @description Threshold buckets for the column. If the column is a metric, these are the thresholds for the column.
       */
      buckets?: number[];
      /**
       * Display Value Levels
       * @description Ordered list of strings that raw values get transformed to for displaying.
       */
      display_value_levels?: string[];
    };
    /** MetricWeight */
    MetricWeight: {
      /** Label */
      label?: string | null;
      group_label?: components['schemas']['GroupLabel'] | null;
      description?: components['schemas']['MetricDescriptions'] | null;
      /**
       * Weight
       * @default 0.5
       */
      weight?: number;
    };
    /** Metrics */
    Metrics: {
      /** Hallucination */
      hallucination?: number | null;
      /** Bleu */
      bleu?: number | null;
      /** Rouge */
      rouge?: number | null;
      /** Pii */
      pii?: string[] | null;
      /** Toxicity */
      toxicity?: number | null;
      /** Factuality */
      factuality?: number | null;
      /** Groundedness */
      groundedness?: number | null;
      /** Instruction Adherence */
      instruction_adherence?: number | null;
      /** Latency */
      latency?: number | null;
      /** Context Relevance */
      context_relevance?: number | null;
    } & {
      [key: string]: unknown;
    };
    /** MetricsRequest */
    MetricsRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
    };
    /** MetricsResponse */
    MetricsResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /** F1 */
      f1?: number | null;
      /** Recall */
      recall?: number | null;
      /** Precision */
      precision?: number | null;
      /** Accuracy */
      accuracy?: number | null;
      /** Data Error Potential */
      data_error_potential?: number | null;
      /** Confidence */
      confidence?: number | null;
      /** @default {
       *       "labels": [],
       *       "recall": [],
       *       "f1": [],
       *       "precision": []
       *     } */
      multi_label_task_metrics?: components['schemas']['MultiLabelTaskMetrics'];
    };
    /** MistralIntegration */
    MistralIntegration: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'mistral';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** MistralIntegrationCreate */
    MistralIntegrationCreate: {
      /** Token */
      token: string;
    };
    /** Model */
    Model: {
      /** Name */
      name: string;
      /** Alias */
      alias: string;
      /** @default openai */
      integration?: components['schemas']['LLMIntegration'];
      /** User Role */
      user_role?: string | null;
      /** Assistant Role */
      assistant_role?: string | null;
      /**
       * System Supported
       * @default false
       */
      system_supported?: boolean;
      /** Input Token Limit */
      input_token_limit?: number | null;
      /** Output Token Limit */
      output_token_limit?: number | null;
      /** Token Limit */
      token_limit?: number | null;
      /**
       * Output Price
       * @default 0
       */
      output_price?: number;
      /**
       * Input Price
       * @default 0
       */
      input_price?: number;
      /** @default tokens */
      cost_by?: components['schemas']['ModelCostBy'];
      /**
       * Is Chat
       * @default false
       */
      is_chat?: boolean;
      /**
       * Provides Log Probs
       * @default false
       */
      provides_log_probs?: boolean;
      /**
       * Formatting Tokens
       * @default 0
       */
      formatting_tokens?: number;
      /**
       * Response Prefix Tokens
       * @default 0
       */
      response_prefix_tokens?: number;
      /** Api Version */
      api_version?: string | null;
      params_map?: components['schemas']['RunParamsMap'];
      output_map?: components['schemas']['OutputMap'] | null;
      input_map?: components['schemas']['InputMap'] | null;
    };
    /**
     * ModelCostBy
     * @enum {string}
     */
    ModelCostBy: 'tokens' | 'characters';
    /**
     * ModelInfo
     * @description Model information that is useful to surface to the UI and in other contexts.
     *
     *     This is a subset of all of the information we store about the model. We need a lot more
     *     information to actually execute requests against the model, but that is not necessary
     *     to surface to the user.
     */
    ModelInfo: {
      /** Name */
      name: string;
      /** Alias */
      alias: string;
      /** @default openai */
      integration?: components['schemas']['LLMIntegration'];
      /** User Role */
      user_role?: string | null;
      /** Assistant Role */
      assistant_role?: string | null;
      /**
       * System Supported
       * @default false
       */
      system_supported?: boolean;
    };
    /**
     * ModelKind
     * @enum {string}
     */
    ModelKind: 'transformers' | 'setfit';
    /** ModelMetrics */
    ModelMetrics: {
      /** Precision */
      precision: number;
      /** Recall */
      recall: number;
      /** F1 */
      f1: number;
      /** Confidence */
      confidence?: number | null;
      /** Accuracy */
      accuracy: number;
      /** @default {
       *       "labels": [],
       *       "recall": [],
       *       "f1": [],
       *       "precision": []
       *     } */
      multi_label_task_metrics?: components['schemas']['MultiLabelTaskMetrics'];
      dep_distribution?: components['schemas']['Distribution'] | null;
    };
    /**
     * ModelType
     * @enum {string}
     */
    ModelType: 'slm' | 'llm';
    /**
     * ModelUploadStatus
     * @enum {string}
     */
    ModelUploadStatus: 'pending' | 'completed' | 'failed';
    /**
     * MultiLabelCoOccurrence
     * @description Label co-occurrence across tasks.
     */
    MultiLabelCoOccurrence: {
      /** Num Samples */
      num_samples: number;
      /** Percent Samples */
      percent_samples: number;
      /** Co Occurrences */
      co_occurrences: components['schemas']['LabelCoOccurences'][];
    };
    /**
     * MultiLabelTaskMetrics
     * @description Metrics per task for multi-label models.
     */
    MultiLabelTaskMetrics: {
      /** Labels */
      labels?: (string | number | boolean)[];
      /**
       * Recall
       * @default []
       */
      recall?: number[];
      /**
       * F1
       * @default []
       */
      f1?: number[];
      /**
       * Precision
       * @default []
       */
      precision?: number[];
    };
    /**
     * NodeNameFilter
     * @description Filters on node names in scorer jobs.
     */
    NodeNameFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'node_name';
      /**
       * Filter Type
       * @default string
       * @constant
       */
      filter_type?: 'string';
      /** Value */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'contains';
      /**
       * Case Sensitive
       * @default true
       */
      case_sensitive?: boolean;
    };
    /**
     * NodeType
     * @enum {string}
     */
    NodeType:
      | 'chain'
      | 'chat'
      | 'llm'
      | 'retriever'
      | 'tool'
      | 'agent'
      | 'workflow'
      | 'trace';
    /**
     * NoiseType
     * @enum {string}
     */
    NoiseType: 'Label Noise' | 'Feature Noise' | 'None';
    /** ObserveProjectSettings */
    ObserveProjectSettings: {
      scorers_config?: components['schemas']['ScorersConfig'] | null;
      alerts_configuration?:
        | components['schemas']['AlertsConfiguration']
        | null;
      scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Registered Scorers Configuration */
      registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Generated Scorers Configuration */
      generated_scorers_configuration?:
        | components['schemas']['GeneratedScorerConfig'][]
        | null;
      /** Customized Scorers Configuration */
      customized_scorers_configuration?:
        | components['schemas']['CustomizedScorer'][]
        | null;
    };
    /** OpenAIFunction */
    OpenAIFunction: {
      /** Name */
      name: string;
    };
    /** OpenAIIntegration */
    OpenAIIntegration: {
      /** Organization Id */
      organization_id?: string | null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'openai';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** OpenAIIntegrationCreate */
    OpenAIIntegrationCreate: {
      /** Organization Id */
      organization_id?: string | null;
      /** Token */
      token: string;
    };
    /** OpenAIToolChoice */
    OpenAIToolChoice: {
      /**
       * Type
       * @default function
       */
      type?: string;
      function: components['schemas']['OpenAIFunction'];
    };
    /**
     * Operator
     * @enum {string}
     */
    Operator:
      | 'eq'
      | 'ne'
      | 'gt'
      | 'gte'
      | 'lt'
      | 'lte'
      | 'in'
      | 'not_in'
      | 'contains'
      | 'has_all'
      | 'between'
      | 'like';
    /**
     * OrganizationAction
     * @enum {string}
     */
    OrganizationAction: 'rename' | 'delete';
    /** OrganizationCreate */
    OrganizationCreate: {
      /** Name */
      name: string;
    };
    /** OrganizationCreatedAtSort */
    OrganizationCreatedAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'created_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** OrganizationDB */
    OrganizationDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /** Name */
      name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** OrganizationIsMemberFilter */
    OrganizationIsMemberFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'is_member';
      /** Value */
      value: boolean;
    };
    /** OrganizationNameFilter */
    OrganizationNameFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /** Value */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'contains';
      /**
       * Case Sensitive
       * @default true
       */
      case_sensitive?: boolean;
    };
    /** OrganizationNameSort */
    OrganizationNameSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** OutputMap */
    OutputMap: {
      /** Response */
      response: string;
      /** Token Count */
      token_count?: string | null;
      /** Input Token Count */
      input_token_count?: string | null;
      /** Output Token Count */
      output_token_count?: string | null;
      /** Completion Reason */
      completion_reason?: string | null;
    };
    /** OutputPIIScorer */
    OutputPIIScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'output_pii';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** OutputSexistScorer */
    OutputSexistScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'output_sexist';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** OutputToneScorer */
    OutputToneScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'output_tone';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** OutputToxicityScorer */
    OutputToxicityScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'output_toxicity';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** OverrideAction */
    OverrideAction: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: 'OVERRIDE';
      /**
       * Subscriptions
       * @description List of subscriptions to send a notification to when this action is applied and the ruleset status matches any of the configured statuses.
       */
      subscriptions?: components['schemas']['SubscriptionConfig'][];
      /**
       * Choices
       * @description List of choices to override the response with. If there are multiple choices, one will be chosen at random when applying this action.
       */
      choices: string[];
    };
    /** PassthroughAction */
    PassthroughAction: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: 'PASSTHROUGH';
      /**
       * Subscriptions
       * @description List of subscriptions to send a notification to when this action is applied and the ruleset status matches any of the configured statuses.
       */
      subscriptions?: components['schemas']['SubscriptionConfig'][];
    };
    /** PasswordResetEmailResponse */
    PasswordResetEmailResponse: Record<string, never>;
    /** PasswordResetResponse */
    PasswordResetResponse: {
      /** Pathname */
      pathname: string;
    };
    /** Payload */
    Payload: {
      /**
       * Input
       * @description Input text to be processed.
       */
      input?: string | null;
      /**
       * Output
       * @description Output text to be processed.
       */
      output?: string | null;
    };
    /** Permission */
    Permission: {
      /** Action */
      action:
        | components['schemas']['UserAction']
        | components['schemas']['GroupAction']
        | components['schemas']['GroupMemberAction']
        | components['schemas']['ProjectAction']
        | components['schemas']['RegisteredScorerAction']
        | components['schemas']['ApiKeyAction']
        | components['schemas']['GeneratedScorerAction']
        | components['schemas']['DatasetAction']
        | components['schemas']['OrganizationAction'];
      /** Allowed */
      allowed: boolean;
      /** Message */
      message?: string | null;
    };
    /** PolygonData */
    PolygonData: {
      /** Id */
      id: number;
      /** Is Active */
      is_active: boolean;
      /** Pred */
      pred?: string | null;
      /** Gold */
      gold?: string | null;
      /** Is Pred */
      is_pred: boolean;
      /** Is Gold */
      is_gold: boolean;
      /** Data Error Potential */
      data_error_potential: number;
      /** Contours */
      contours: unknown[];
      error_type?: components['schemas']['SemSegErrorType'] | null;
      /** Background Error Pct */
      background_error_pct?: number | null;
      /** Area */
      area?: number | null;
      /** Accuracy */
      accuracy?: number | null;
      size?: components['schemas']['PolygonSize'] | null;
    };
    /**
     * PolygonSize
     * @enum {string}
     */
    PolygonSize: 'extra_small' | 'small' | 'medium' | 'large' | 'extra_large';
    /**
     * ProjectAction
     * @enum {string}
     */
    ProjectAction:
      | 'update'
      | 'delete'
      | 'rename'
      | 'share'
      | 'create_run'
      | 'delete_run'
      | 'rename_run'
      | 'move_run'
      | 'export_data'
      | 'configure_human_feedback'
      | 'record_human_feedback'
      | 'log_data'
      | 'toggle_metric'
      | 'edit_alert'
      | 'create_stage'
      | 'edit_stage'
      | 'configure_crown_logic'
      | 'delete_data'
      | 'set_metric'
      | 'edit_run_tags'
      | 'dismiss_alert'
      | 'edit_slice'
      | 'edit_edit';
    /** ProjectBookmarkFilter */
    ProjectBookmarkFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'bookmark';
      /** Value */
      value: boolean;
    };
    /** ProjectBookmarkSort */
    ProjectBookmarkSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'bookmark';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default custom
       * @constant
       */
      sort_type?: 'custom';
    };
    /** ProjectCollectionParams */
    ProjectCollectionParams: {
      /** Filters */
      filters?: (
        | components['schemas']['ProjectIDFilter']
        | components['schemas']['ProjectNameFilter']
        | components['schemas']['ProjectTypeFilter']
        | components['schemas']['ProjectCreatorFilter']
        | components['schemas']['ProjectCreatedAtFilter']
        | components['schemas']['ProjectUpdatedAtFilter']
        | components['schemas']['ProjectRunsFilter']
        | components['schemas']['ProjectBookmarkFilter']
      )[];
      /**
       * Sort
       * @default {
       *       "name": "created_at",
       *       "ascending": false,
       *       "sort_type": "column"
       *     }
       */
      sort?:
        | (
            | components['schemas']['ProjectNameSort']
            | components['schemas']['ProjectTypeSort']
            | components['schemas']['ProjectCreatedAtSort']
            | components['schemas']['ProjectUpdatedAtSort']
            | components['schemas']['ProjectRunsSort']
            | components['schemas']['ProjectBookmarkSort']
          )
        | null;
    };
    /** ProjectCreate */
    ProjectCreate: {
      /** Name */
      name: string;
      /** Created By */
      created_by?: string | null;
      /** @default training_inference */
      type?: components['schemas']['ProjectType'];
      /**
       * Create Example Templates
       * @default false
       */
      create_example_templates?: boolean;
    };
    /** ProjectCreateResponse */
    ProjectCreateResponse: {
      /** Name */
      name?: string | null;
      /** Created By */
      created_by?: string | null;
      type?: components['schemas']['ProjectType'] | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** ProjectCreatedAtFilter */
    ProjectCreatedAtFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'created_at';
      /**
       * Value
       * Format: date-time
       */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    };
    /** ProjectCreatedAtSort */
    ProjectCreatedAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'created_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** ProjectCreatorFilter */
    ProjectCreatorFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'creator';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
    };
    /** ProjectDB */
    ProjectDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /** Name */
      name?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      type?: components['schemas']['ProjectType'] | null;
      /** Runs */
      runs: components['schemas']['RunDB'][];
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /**
       * Bookmark
       * @default false
       */
      bookmark?: boolean;
    };
    /** ProjectDBThin */
    ProjectDBThin: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /** Name */
      name?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      type?: components['schemas']['ProjectType'] | null;
      /** Runs */
      runs: components['schemas']['RunDBThin'][];
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /**
       * Bookmark
       * @default false
       */
      bookmark?: boolean;
    };
    /** ProjectDeleteResponse */
    ProjectDeleteResponse: {
      /** Message */
      message: string;
    };
    /** ProjectIDFilter */
    ProjectIDFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'id';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
    };
    /** ProjectIntegration */
    ProjectIntegration: {
      /** Models */
      models: string[];
      /** Scorer Models */
      scorer_models: string[];
    };
    /** ProjectIntegrationsResponse */
    ProjectIntegrationsResponse: {
      /** Integrations */
      integrations: {
        [key: string]: components['schemas']['ProjectIntegration'];
      };
    };
    /** ProjectNameFilter */
    ProjectNameFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /** Value */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'contains';
      /**
       * Case Sensitive
       * @default true
       */
      case_sensitive?: boolean;
    };
    /** ProjectNameSort */
    ProjectNameSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** ProjectRunSummary */
    ProjectRunSummary: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Name */
      name: string;
      task_type: components['schemas']['TaskType'];
      /** Task */
      task?: string | null;
      /** Labels */
      labels: string[];
      /** Num Samples */
      num_samples: number;
      metrics: components['schemas']['ModelMetrics'];
      /** Slices */
      slices: components['schemas']['SliceMetrics'][];
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /** Avg Samples */
      avg_samples: number;
      /** Hard Sample Pct */
      hard_sample_pct: number;
      hard_sample_metrics?: components['schemas']['ModelMetrics'] | null;
      /** Num Spans */
      num_spans?: number | null;
      /** Spans Per Sample */
      spans_per_sample?: number | null;
      /** Spans Per Class */
      spans_per_class?: number | null;
      /**
       * Data Edits
       * @default []
       */
      data_edits?: components['schemas']['EditSummary'][];
    };
    /** ProjectRunsFilter */
    ProjectRunsFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'runs';
      /** Value */
      value: number | number[];
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'between';
    };
    /** ProjectRunsSort */
    ProjectRunsSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'runs';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default custom
       * @constant
       */
      sort_type?: 'custom';
    };
    /** ProjectSettingsDB */
    ProjectSettingsDB: {
      scorers_config?: components['schemas']['ScorersConfig'] | null;
      /** Metric Weights Configuration */
      metric_weights_configuration?: {
        [key: string]: components['schemas']['MetricWeight'];
      } | null;
      alerts_configuration?:
        | components['schemas']['AlertsConfiguration']
        | null;
      scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Registered Scorers Configuration */
      registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Generated Scorers Configuration */
      generated_scorers_configuration?:
        | components['schemas']['GeneratedScorerConfig'][]
        | null;
      /** Customized Scorers Configuration */
      customized_scorers_configuration?:
        | components['schemas']['CustomizedScorer'][]
        | null;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /**
     * ProjectType
     * @enum {string}
     */
    ProjectType:
      | 'training_inference'
      | 'prompt_evaluation'
      | 'llm_monitor'
      | 'protect'
      | 'gen_ai';
    /** ProjectTypeFilter */
    ProjectTypeFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'type';
      /** Value */
      value:
        | components['schemas']['ProjectType']
        | components['schemas']['ProjectType'][];
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'one_of' | 'not_in';
    };
    /** ProjectTypeSort */
    ProjectTypeSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'type';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** ProjectUpdate */
    ProjectUpdate: {
      /** Name */
      name?: string | null;
      /** Created By */
      created_by?: string | null;
      type?: components['schemas']['ProjectType'] | null;
    };
    /** ProjectUpdateResponse */
    ProjectUpdateResponse: {
      /** Name */
      name?: string | null;
      /** Created By */
      created_by?: string | null;
      type?: components['schemas']['ProjectType'] | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** ProjectUpdatedAtFilter */
    ProjectUpdatedAtFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'updated_at';
      /**
       * Value
       * Format: date-time
       */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    };
    /** ProjectUpdatedAtSort */
    ProjectUpdatedAtSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'updated_at';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
    };
    /** PromptChainIngestBatchRequest */
    PromptChainIngestBatchRequest: {
      /** Rows */
      rows?: components['schemas']['ChainRow'][];
      /** Scorers */
      scorers?: (
        | components['schemas']['AgenticWorkflowSuccessScorer']
        | components['schemas']['BleuScorer']
        | components['schemas']['ChunkAttributionUtilizationScorer']
        | components['schemas']['CompletenessScorer']
        | components['schemas']['ContextAdherenceScorer']
        | components['schemas']['ContextRelevanceScorer']
        | components['schemas']['CorrectnessScorer']
        | components['schemas']['GroundTruthAdherenceScorer']
        | components['schemas']['InputPIIScorer']
        | components['schemas']['InputSexistScorer']
        | components['schemas']['InputToneScorer']
        | components['schemas']['InputToxicityScorer']
        | components['schemas']['InstructionAdherenceScorer']
        | components['schemas']['OutputPIIScorer']
        | components['schemas']['OutputSexistScorer']
        | components['schemas']['OutputToneScorer']
        | components['schemas']['OutputToxicityScorer']
        | components['schemas']['PromptInjectionScorer']
        | components['schemas']['PromptPerplexityScorer']
        | components['schemas']['RougeScorer']
        | components['schemas']['ToolErrorRateScorer']
        | components['schemas']['ToolSelectionQualityScorer']
        | components['schemas']['UncertaintyScorer']
      )[];
      /** Prompt Registered Scorers Configuration */
      prompt_registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Generated Scorers */
      generated_scorers?:
        | components['schemas']['GeneratedScorerConfig'][]
        | null;
      prompt_scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Prompt Customized Scorers Configuration */
      prompt_customized_scorers_configuration?:
        | (
            | components['schemas']['CustomizedAgenticWorkflowSuccessGPTScorer']
            | components['schemas']['CustomizedChunkAttributionUtilizationGPTScorer']
            | components['schemas']['CustomizedCompletenessGPTScorer']
            | components['schemas']['CustomizedFactualityGPTScorer']
            | components['schemas']['CustomizedGroundednessGPTScorer']
            | components['schemas']['CustomizedInstructionAdherenceGPTScorer']
            | components['schemas']['CustomizedGroundTruthAdherenceGPTScorer']
            | components['schemas']['CustomizedToolSelectionQualityGPTScorer']
            | components['schemas']['CustomizedToolErrorRateGPTScorer']
          )[]
        | null;
      /**
       * Total Chains
       * @description Total number of chains / workflows in the batch. This should match the unique root ID count and is used to determine if all chains have been ingested.
       */
      total_chains: number;
      /**
       * Timeout Minutes
       * @description Minutes to wait before concluding ingestion, regardless of how many batches of chains / chains have been successfully ingested.
       */
      timeout_minutes?: number;
    };
    /** PromptChainIngestBatchResponse */
    PromptChainIngestBatchResponse: {
      /** Num Rows */
      num_rows: number;
      /** Message */
      message: string;
      /**
       * Job Id
       * Format: uuid4
       */
      job_id: string;
      /** Link */
      link: string;
      /** Num Chains */
      num_chains: number;
      /** Total Chains */
      total_chains: number;
    };
    /** PromptChainIngestRequest */
    PromptChainIngestRequest: {
      /** Rows */
      rows?: components['schemas']['ChainRow'][];
      /** Scorers */
      scorers?: (
        | components['schemas']['AgenticWorkflowSuccessScorer']
        | components['schemas']['BleuScorer']
        | components['schemas']['ChunkAttributionUtilizationScorer']
        | components['schemas']['CompletenessScorer']
        | components['schemas']['ContextAdherenceScorer']
        | components['schemas']['ContextRelevanceScorer']
        | components['schemas']['CorrectnessScorer']
        | components['schemas']['GroundTruthAdherenceScorer']
        | components['schemas']['InputPIIScorer']
        | components['schemas']['InputSexistScorer']
        | components['schemas']['InputToneScorer']
        | components['schemas']['InputToxicityScorer']
        | components['schemas']['InstructionAdherenceScorer']
        | components['schemas']['OutputPIIScorer']
        | components['schemas']['OutputSexistScorer']
        | components['schemas']['OutputToneScorer']
        | components['schemas']['OutputToxicityScorer']
        | components['schemas']['PromptInjectionScorer']
        | components['schemas']['PromptPerplexityScorer']
        | components['schemas']['RougeScorer']
        | components['schemas']['ToolErrorRateScorer']
        | components['schemas']['ToolSelectionQualityScorer']
        | components['schemas']['UncertaintyScorer']
      )[];
      /** Prompt Registered Scorers Configuration */
      prompt_registered_scorers_configuration?:
        | components['schemas']['RegisteredScorer'][]
        | null;
      /** Generated Scorers */
      generated_scorers?:
        | components['schemas']['GeneratedScorerConfig'][]
        | null;
      prompt_scorers_configuration?:
        | components['schemas']['ScorersConfiguration']
        | null;
      /** Prompt Customized Scorers Configuration */
      prompt_customized_scorers_configuration?:
        | (
            | components['schemas']['CustomizedAgenticWorkflowSuccessGPTScorer']
            | components['schemas']['CustomizedChunkAttributionUtilizationGPTScorer']
            | components['schemas']['CustomizedCompletenessGPTScorer']
            | components['schemas']['CustomizedFactualityGPTScorer']
            | components['schemas']['CustomizedGroundednessGPTScorer']
            | components['schemas']['CustomizedInstructionAdherenceGPTScorer']
            | components['schemas']['CustomizedGroundTruthAdherenceGPTScorer']
            | components['schemas']['CustomizedToolSelectionQualityGPTScorer']
            | components['schemas']['CustomizedToolErrorRateGPTScorer']
          )[]
        | null;
    };
    /** PromptChainIngestResponse */
    PromptChainIngestResponse: {
      /** Num Rows */
      num_rows: number;
      /** Message */
      message: string;
      /**
       * Job Id
       * Format: uuid4
       */
      job_id: string;
      /** Link */
      link: string;
    };
    /** PromptDatasetDB */
    PromptDatasetDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Dataset Id
       * Format: uuid4
       */
      dataset_id: string;
      /** File Name */
      file_name?: string | null;
      /** Message */
      message?: string | null;
      /** Num Rows */
      num_rows?: number | null;
      /** Rows */
      rows?: number | null;
    };
    /** PromptFilterParams */
    PromptFilterParams: {
      /**
       * Filters
       * @description A list of filters.
       */
      filters?: (
        | components['schemas']['RangePromptFilterParam']
        | components['schemas']['ValuePromptFilterParam']
        | components['schemas']['CategoricalPromptFilterParam']
      )[];
    };
    /**
     * PromptGroupResponse
     * @description Contains relevant data for prompt column group.
     */
    PromptGroupResponse: {
      /** Group Label */
      group_label: string;
      /** Group Name */
      group_name?: string | null;
      /** Group Description */
      group_description?: string | null;
      /**
       * Group Icon
       * @default Puzzle
       */
      group_icon?: string;
      /** Columns */
      columns: string[];
    };
    /** PromptInjectionScorer */
    PromptInjectionScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'prompt_injection';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /**
     * PromptOptimizationConfiguration
     * @description Configuration for prompt optimization.
     */
    PromptOptimizationConfiguration: {
      /** Prompt */
      prompt: string;
      /** Evaluation Criteria */
      evaluation_criteria: string;
      /** Task Description */
      task_description: string;
      /** Includes Target */
      includes_target: boolean;
      /** Num Rows */
      num_rows: number;
      /** Iterations */
      iterations: number;
      /** Max Tokens */
      max_tokens: number;
      /** Temperature */
      temperature: number;
      /** Generation Model Alias */
      generation_model_alias: string;
      /** Evaluation Model Alias */
      evaluation_model_alias: string;
      /** @default openai */
      integration_name?: components['schemas']['LLMIntegration'];
    };
    /** PromptPerplexityScorer */
    PromptPerplexityScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'prompt_perplexity';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** PromptRow */
    PromptRow: {
      /**
       * Hallucination Severity
       * @default 0
       */
      hallucination_severity?: number;
      /** Index */
      index: number;
      /** Prompt */
      prompt?: string | null;
      /** Response */
      response?: string | null;
      /** Target */
      target?: string | null;
      /** Node Id */
      node_id?: string | null;
      node_type?: components['schemas']['NodeType'] | null;
      /** Node Name */
      node_name?: string | null;
      /** Node Input */
      node_input?: string | null;
      /** Node Output */
      node_output?:
        | string
        | string[]
        | {
            [key: string]: string;
          }
        | null;
      /** Chain Id */
      chain_id?: string | null;
      /** Chain Root Id */
      chain_root_id?: string | null;
      /** Has Children */
      has_children?: boolean | null;
      /** Inputs */
      inputs?: {
        [key: string]: string | null;
      };
      metrics?: components['schemas']['Metrics'];
      /** Segments */
      segments?: components['schemas']['HallucinationSegment'][];
      /** Response Segments */
      response_segments?: components['schemas']['HallucinationSegment'][];
      /** Hallucination */
      hallucination?: number | null;
      /** Bleu */
      bleu?: number | null;
      /** Rouge */
      rouge?: number | null;
      /** Cost */
      cost?: number | null;
      /** Prompt Segments */
      prompt_segments?: components['schemas']['HallucinationSegment'][] | null;
      /**
       * Prompt Hallucination Severity
       * @default 0
       */
      prompt_hallucination_severity?: number;
    };
    /** PromptRowColumn */
    PromptRowColumn: {
      /** @description Job status used for computing the column. Only set for metrics columns that have a separate scorer job. */
      job_status?: components['schemas']['JobStatus'] | null;
      /**
       * Job Progress Message
       * @description Progress message to show the users on hover in case the job is in progress.
       */
      job_progress_message?: string | null;
      /**
       * Job Error Message
       * @description Error message to show the users on hover in case the job fails or errors out.
       */
      job_error_message?: string | null;
      /**
       * Scorer Name
       * @description Scorer Name executed by the job.
       */
      scorer_name?: string | null;
      /** @description If a column is associated with a basic or a plus scorer. Defaults to None for columns not associated with either. */
      job_type?: components['schemas']['ScorerType'] | null;
      /**
       * Name
       * @description Name of the column.
       */
      name: string;
      /**
       * Label
       * @description Display label of the column in the UI.
       */
      label?: string | null;
      /**
       * Description
       * @description Description of the column.
       */
      description?: string | null;
      /**
       * Group Label
       * @description Display label of the group (super column) in the UI.
       */
      group_label?: string | null;
      /**
       * Group Name
       * @description Name of the group (super column).
       */
      group_name?: string | null;
      /**
       * Group Description
       * @description Description of the group (super column).
       */
      group_description?: string | null;
      /**
       * @description Data type of the column. This is used to determine how to format the data on the UI.
       * @default unknown
       */
      data_type?: components['schemas']['DataTypeOptions'];
      /** @description Thresholds for the column, if this is a metrics column. */
      metric_threshold?: components['schemas']['MetricThreshold'] | null;
      /**
       * Sortable
       * @description Whether the column is sortable.
       * @default true
       */
      sortable?: boolean;
      /**
       * Filterable
       * @description Whether the column is filterable by value. Doesn't include categorical filters
       * @default true
       */
      filterable?: boolean;
      /**
       * Metric Infos
       * @description Metric values with metadata.
       */
      metric_infos?: (
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed']
      )[];
      /**
       * Values
       * @description Values of the column.
       */
      values?: (
        | string
        | number
        | boolean
        | components['schemas']['Segment']
        | components['schemas']['HallucinationSegment']
        | components['schemas']['Document']
        | components['schemas']['FeedbackRatingDB']
        | components['schemas']['FeedbackAggregate']
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[]
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[][]
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[][][]
        | null
      )[];
      /**
       * Display Values
       * @description Display values of the column. This is used to display the values in the UI if we want them to be different from the actual values.
       */
      display_values?: (string | null)[] | null;
      /**
       * Job Info
       * @description Job info used for computing the column. Only present for metrics columns that have a separate scorer job.
       */
      job_info?: (components['schemas']['JobInfo'] | null)[] | null;
      /** @description Alert for a given column with title and message */
      alert?: components['schemas']['Alert'] | null;
      /**
       * Source
       * @description Source DF of the column.
       */
      source?: string | null;
      /**
       * Can Critique Column
       * @default false
       */
      can_critique_column?: boolean;
      /**
       * Metric Critique Computing
       * @default false
       */
      metric_critique_computing?: boolean;
    };
    /** PromptRunColumn */
    PromptRunColumn: {
      /**
       * Name
       * @description Name of the column.
       */
      name: string;
      /**
       * Label
       * @description Display label of the column in the UI.
       */
      label?: string | null;
      /**
       * Description
       * @description Description of the column.
       */
      description?: string | null;
      /**
       * Group Label
       * @description Display label of the group (super column) in the UI.
       */
      group_label?: string | null;
      /**
       * Group Name
       * @description Name of the group (super column).
       */
      group_name?: string | null;
      /**
       * Group Description
       * @description Description of the group (super column).
       */
      group_description?: string | null;
      /**
       * @description Data type of the column. This is used to determine how to format the data on the UI.
       * @default unknown
       */
      data_type?: components['schemas']['DataTypeOptions'];
      /** @description Thresholds for the column, if this is a metrics column. */
      metric_threshold?: components['schemas']['MetricThreshold'] | null;
      /**
       * Sortable
       * @description Whether the column is sortable.
       * @default true
       */
      sortable?: boolean;
      /**
       * Filterable
       * @description Whether the column is filterable by value. Doesn't include categorical filters
       * @default true
       */
      filterable?: boolean;
      /**
       * Metric Infos
       * @description Metric values with metadata.
       */
      metric_infos?: (
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed']
      )[];
      /**
       * Values
       * @description Values of the column.
       */
      values?: (
        | string
        | number
        | boolean
        | components['schemas']['Segment']
        | components['schemas']['HallucinationSegment']
        | components['schemas']['Document']
        | components['schemas']['FeedbackRatingDB']
        | components['schemas']['FeedbackAggregate']
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[]
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[][]
        | (
            | string
            | number
            | boolean
            | components['schemas']['Segment']
            | components['schemas']['HallucinationSegment']
            | components['schemas']['Document']
            | components['schemas']['FeedbackRatingDB']
            | components['schemas']['FeedbackAggregate']
            | null
          )[][][]
        | null
      )[];
      /**
       * Display Values
       * @description Display values of the column. This is used to display the values in the UI if we want them to be different from the actual values.
       */
      display_values?: (string | null)[] | null;
      /**
       * Job Info
       * @description Job info used for computing the column. Only present for metrics columns that have a separate scorer job.
       */
      job_info?: (components['schemas']['JobInfo'] | null)[] | null;
      /** @description Alert for a given column with title and message */
      alert?: components['schemas']['Alert'] | null;
      /** @description If a column is associated with a basic or a plus scorer. Defaults to None for columns not associated with either. */
      job_type?: components['schemas']['ScorerType'] | null;
    };
    /**
     * PromptRunSettings
     * @description Prompt run settings.
     */
    PromptRunSettings: {
      /**
       * Logprobs
       * @default true
       */
      logprobs?: boolean;
      /**
       * Top Logprobs
       * @default 5
       */
      top_logprobs?: number;
      /**
       * Echo
       * @default false
       */
      echo?: boolean;
      /**
       * N
       * @default 1
       */
      n?: number;
      /** Deployment Name */
      deployment_name?: string | null;
      /**
       * Model Alias
       * @default ChatGPT (4K context)
       */
      model_alias?: string;
      /**
       * Temperature
       * @default 1
       */
      temperature?: number;
      /**
       * Max Tokens
       * @default 256
       */
      max_tokens?: number;
      /** Stop Sequences */
      stop_sequences?: string[] | null;
      /**
       * Top P
       * @default 1
       */
      top_p?: number;
      /**
       * Top K
       * @default 40
       */
      top_k?: number;
      /**
       * Frequency Penalty
       * @default 0
       */
      frequency_penalty?: number;
      /**
       * Presence Penalty
       * @default 0
       */
      presence_penalty?: number;
      /** Tools */
      tools?: Record<string, never>[] | null;
      /** Tool Choice */
      tool_choice?: string | components['schemas']['OpenAIToolChoice'] | null;
      /** Response Format */
      response_format?: {
        [key: string]: string;
      } | null;
      /** Known Models */
      known_models?: components['schemas']['Model'][];
    };
    /** PromptSampleIDs */
    PromptSampleIDs: {
      /** Total Samples */
      total_samples: number;
      /** Sample Indices */
      sample_indices: {
        [key: string]: number[];
      };
    };
    /** PutPromptScoreRequest */
    PutPromptScoreRequest: {
      /** Metric Name */
      metric_name?: string | null;
      /** Scores */
      scores?: unknown[] | null;
      /** Indices */
      indices?: number[] | null;
      /** Aggregates */
      aggregates?: Record<string, never> | null;
      /** Registered Scorer Id */
      registered_scorer_id?: string | null;
    };
    /** PutPromptScoreResponse */
    PutPromptScoreResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /**
       * Job Id
       * Format: uuid4
       */
      job_id: string;
      /** Scorer Name */
      scorer_name: string;
    };
    /** QueryDatasetParams */
    QueryDatasetParams: {
      /** Filters */
      filters?: components['schemas']['DatasetContentFilter'][];
      sort?: components['schemas']['DatasetContentSortClause'] | null;
    };
    /** QueryFilterV1 */
    QueryFilterV1: {
      /** Col Name */
      col_name: string;
      /** Value */
      value: unknown;
      operator: components['schemas']['Operator'];
      json_field_type?: components['schemas']['FieldType'] | null;
      /**
       * Value Is Column
       * @default false
       */
      value_is_column?: boolean | null;
      /** Json Field */
      json_field?: string | null;
      /** Alternate Json Field */
      alternate_json_field?: string | null;
    };
    /** QueryOrganizationParams */
    QueryOrganizationParams: {
      /** Filters */
      filters?: (
        | components['schemas']['OrganizationNameFilter']
        | components['schemas']['OrganizationIsMemberFilter']
      )[];
      /**
       * Sort
       * @default {
       *       "name": "created_at",
       *       "ascending": false,
       *       "sort_type": "column"
       *     }
       */
      sort?:
        | (
            | components['schemas']['OrganizationCreatedAtSort']
            | components['schemas']['OrganizationNameSort']
          )
        | null;
    };
    /** RangePromptFilterParam */
    RangePromptFilterParam: {
      /** Column */
      column: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      filter_type: 'range';
      /** Low */
      low: number;
      /** High */
      high: number;
    };
    /** RecomputeSettingsProject */
    RecomputeSettingsProject: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      mode: 'project';
    };
    /** RecomputeSettingsRuns */
    RecomputeSettingsRuns: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      mode: 'runs';
      /** Run Ids */
      run_ids: string[];
    };
    /** RegisteredScorer */
    RegisteredScorer: {
      /** Id */
      id?: string | null;
      /** Name */
      name?: string | null;
    };
    /**
     * RegisteredScorerAction
     * @enum {string}
     */
    RegisteredScorerAction: 'update' | 'delete';
    /** RegisteredScorerConfig */
    RegisteredScorerConfig: {
      /**
       * Name
       * @description Name of the scorer to enable.
       */
      name: string;
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** RemoteEditExportRequest */
    RemoteEditExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
      /** Bucket Name */
      bucket_name: string;
      /** Object Name */
      object_name: string;
      /**
       * Export To
       * @default s3
       */
      export_to?: string;
    };
    /** RemoteEditExportResponse */
    RemoteEditExportResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Edit Ids */
      edit_ids: string[];
      /**
       * Edit Overrides
       * @default []
       */
      edit_overrides?: components['schemas']['EditOverride'][] | null;
      /**
       * Only Export Edited
       * @default false
       */
      only_export_edited?: boolean | null;
      /** Min Reviews */
      min_reviews?: number | null;
      /** Bucket Name */
      bucket_name: string;
      /** Object Name */
      object_name: string;
      /**
       * Export To
       * @default s3
       */
      export_to?: string;
    };
    /** RemoteExportRequest */
    RemoteExportRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Bucket Name */
      bucket_name: string;
      /** Object Name */
      object_name: string;
      /**
       * Export To
       * @default s3
       */
      export_to?: string;
    };
    /** RemoteExportResponse */
    RemoteExportResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /**
       * All But
       * @default false
       */
      all_but?: boolean;
      /** @default csv */
      file_type?: components['schemas']['FileType'];
      /**
       * Include Cols
       * @default []
       */
      include_cols?: string[] | null;
      /**
       * Col Mapping
       * @default {}
       */
      col_mapping?: {
        [key: string]: string;
      } | null;
      /**
       * Hf Format
       * @default false
       */
      hf_format?: boolean;
      tagging_schema?: components['schemas']['TaggingSchema'] | null;
      /** Bucket Name */
      bucket_name: string;
      /** Object Name */
      object_name: string;
      /**
       * Export To
       * @default s3
       */
      export_to?: string;
    };
    /** Request */
    Request: {
      /**
       * Prioritized Rulesets
       * @description Rulesets to be applied to the payload.
       */
      prioritized_rulesets?: components['schemas']['Ruleset'][];
      /** @description Payload to be processed. */
      payload: components['schemas']['Payload'];
      /**
       * Project Name
       * @description Project name.
       */
      project_name?: string | null;
      /**
       * Project Id
       * @description Project ID.
       */
      project_id?: string | null;
      /**
       * Stage Name
       * @description Stage name.
       */
      stage_name?: string | null;
      /**
       * Stage Id
       * @description Stage ID.
       */
      stage_id?: string | null;
      /**
       * Stage Version
       * @description Stage version to use for the request, if it's a central stage with a previously registered version.
       */
      stage_version?: number | null;
      /**
       * Timeout
       * @description Optional timeout for the guardrail execution in seconds. This is not the timeout for the request. If not set, a default timeout of 5 minutes will be used.
       * @default 300
       */
      timeout?: number;
      /**
       * Metadata
       * @description Optional additional metadata. This will be echoed back in the response.
       */
      metadata?: {
        [key: string]: string;
      } | null;
      /**
       * Headers
       * @description Optional additional HTTP headers that should be included in the response.
       */
      headers?: {
        [key: string]: string;
      } | null;
    };
    /**
     * ResourceKind
     * @enum {string}
     */
    ResourceKind:
      | 'user'
      | 'group'
      | 'group_member'
      | 'project'
      | 'integration'
      | 'registered_scorer'
      | 'generated_scorer'
      | 'api_key'
      | 'dataset'
      | 'stage'
      | 'stage_version'
      | 'organization';
    /** Response */
    Response: {
      /**
       * @description Status of the request after processing the rules.
       * @default not_triggered
       */
      status?: components['schemas']['ExecutionStatus'];
      /**
       * Text
       * @description Text from the request after processing the rules.
       */
      text: string;
      trace_metadata: components['schemas']['TraceMetadata'];
    } & {
      [key: string]: unknown;
    };
    /** RetrieverSpan */
    RetrieverSpan: {
      /**
       * @description Type of the step. By default, it is set to retriever. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'retriever';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
    };
    /** RetrieverSpanWithMetrics */
    RetrieverSpanWithMetrics: {
      /**
       * Trace Id
       * Format: uuid4
       */
      trace_id: string;
      /** Parent Id */
      parent_id?: string | null;
      /**
       * Step Id
       * Format: uuid4
       */
      step_id: string;
      /** Metrics */
      metrics?: {
        [key: string]:
          | components['schemas']['MetricNotComputed']
          | components['schemas']['MetricPending']
          | components['schemas']['MetricComputing']
          | components['schemas']['MetricNotApplicable']
          | components['schemas']['MetricSuccess']
          | components['schemas']['MetricError']
          | components['schemas']['MetricFailed'];
      };
      /**
       * @description Type of the step. By default, it is set to retriever. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'retriever';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
    };
    /** RetrieverStep */
    RetrieverStep: {
      /**
       * @description Type of the step. By default, it is set to retriever. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'retriever';
      /**
       * Input
       * @description Input query to the retriever.
       */
      input: string;
      /**
       * Output
       * @description Documents retrieved from the retriever. This can be a list of strings or `Document`s.
       */
      output?: components['schemas']['Document'][];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
    };
    /** RollbackRequest */
    RollbackRequest: {
      /** Rollback Version */
      rollback_version: number;
    };
    /** RootModel[Sequence[WeeklyChangelog]] */
    RootModel_Sequence_WeeklyChangelog__: components['schemas']['WeeklyChangelog'][];
    /** RootModel[Union[InferenceRunResults, SplitRunResults]] */
    RootModel_Union_InferenceRunResults__SplitRunResults__:
      | components['schemas']['InferenceRunResults']
      | components['schemas']['SplitRunResults'];
    /** RougeScorer */
    RougeScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'rouge';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** Rule */
    Rule: {
      /**
       * Metric
       * @description Name of the metric.
       */
      metric: string;
      /** @description Operator to use for comparison. */
      operator: components['schemas']['RuleOperator'];
      /**
       * Target Value
       * @description Value to compare with for this metric (right hand side).
       */
      target_value: string | number | unknown[] | null;
    };
    /**
     * RuleOperator
     * @enum {string}
     */
    RuleOperator:
      | 'gt'
      | 'lt'
      | 'gte'
      | 'lte'
      | 'eq'
      | 'neq'
      | 'contains'
      | 'all'
      | 'any'
      | 'empty'
      | 'not_empty';
    /** RuleResult */
    RuleResult: {
      /** @default not_triggered */
      status?: components['schemas']['ExecutionStatus'];
      /**
       * Metric
       * @description Name of the metric.
       */
      metric: string;
      /** @description Operator to use for comparison. */
      operator: components['schemas']['RuleOperator'];
      /**
       * Target Value
       * @description Value to compare with for this metric (right hand side).
       */
      target_value: string | number | unknown[] | null;
      /**
       * Value
       * @description Result of the metric computation.
       */
      value?: unknown | null;
      /**
       * Execution Time
       * @description Execution time for the rule in seconds.
       */
      execution_time?: number | null;
    };
    /** Ruleset */
    Ruleset: {
      /**
       * Rules
       * @description List of rules to evaluate. Atleast 1 rule is required.
       */
      rules?: components['schemas']['Rule'][];
      /**
       * Action
       * @description Action to take if all the rules are met.
       */
      action?:
        | components['schemas']['OverrideAction']
        | components['schemas']['PassthroughAction'];
      /**
       * Description
       * @description Description of the ruleset.
       */
      description?: string | null;
    };
    /** RulesetResult */
    RulesetResult: {
      /** @default not_triggered */
      status?: components['schemas']['ExecutionStatus'];
      /**
       * Rules
       * @description List of rules to evaluate. Atleast 1 rule is required.
       */
      rules?: components['schemas']['Rule'][];
      /**
       * Action
       * @description Action to take if all the rules are met.
       */
      action?:
        | components['schemas']['OverrideAction']
        | components['schemas']['PassthroughAction'];
      /**
       * Description
       * @description Description of the ruleset.
       */
      description?: string | null;
      /**
       * Rule Results
       * @description Results of the rule execution.
       */
      rule_results?: components['schemas']['RuleResult'][];
    };
    /** RulesetsMixin */
    RulesetsMixin: {
      /**
       * Prioritized Rulesets
       * @description Rulesets to be applied to the payload.
       */
      prioritized_rulesets?: components['schemas']['Ruleset'][];
    };
    /** RunCreate */
    RunCreate: {
      /** Name */
      name: string;
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
      /** Num Samples */
      num_samples?: number | null;
      /** Winner */
      winner?: boolean | null;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /** Task Type */
      task_type: number;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagCreateRequest'][];
    };
    /** RunDB */
    RunDB: {
      /** Name */
      name?: string | null;
      /** Project Id */
      project_id?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Num Samples */
      num_samples: number;
      /** Winner */
      winner: boolean;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      task_type?: components['schemas']['TaskType'] | null;
      /**
       * Last Updated By
       * Format: uuid4
       */
      last_updated_by: string;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagDB'][];
      /** Example Content Id */
      example_content_id?: string | null;
      creator: components['schemas']['UserDB'];
      /** Logged Splits */
      logged_splits: string[];
      /** Logged Inference Names */
      logged_inference_names: string[];
    };
    /** RunDBThin */
    RunDBThin: {
      /** Name */
      name?: string | null;
      /** Project Id */
      project_id?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Num Samples */
      num_samples: number;
      /** Winner */
      winner: boolean;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      task_type?: components['schemas']['TaskType'] | null;
      /**
       * Last Updated By
       * Format: uuid4
       */
      last_updated_by: string;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagDB'][];
      /** Example Content Id */
      example_content_id?: string | null;
      creator: components['schemas']['UserDB'];
    };
    /** RunDBThinWithProjectName */
    RunDBThinWithProjectName: {
      /** Name */
      name?: string | null;
      /** Project Id */
      project_id?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Num Samples */
      num_samples: number;
      /** Winner */
      winner: boolean;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      task_type?: components['schemas']['TaskType'] | null;
      /**
       * Last Updated By
       * Format: uuid4
       */
      last_updated_by: string;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagDB'][];
      /** Example Content Id */
      example_content_id?: string | null;
      creator: components['schemas']['UserDB'];
      /** Project Name */
      project_name: string;
    };
    /** RunLinkResponse */
    RunLinkResponse: {
      /** Link */
      link: string;
    };
    /** RunMetricCreateRequest */
    RunMetricCreateRequest: {
      /** Key */
      key: string;
      /** Value */
      value?: number | null;
      object_value?: components['schemas']['FeedbackAggregate'] | null;
      /**
       * Epoch
       * @default 0
       */
      epoch?: number;
      /** Extra */
      extra?: unknown[] | Record<string, never> | null;
    };
    /** RunMetricDB */
    RunMetricDB: {
      /** Key */
      key: string;
      /** Value */
      value?: number | null;
      object_value?: components['schemas']['FeedbackAggregate'] | null;
      /**
       * Epoch
       * @default 0
       */
      epoch?: number;
      /** Extra */
      extra?: unknown[] | Record<string, never> | null;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /**
     * RunParamsMap
     * @description Maps the internal settings parameters (left) to the serialized parameters (right) we want to send in the API
     *     requests.
     */
    RunParamsMap: {
      /** Model */
      model?: string | null;
      /** Temperature */
      temperature?: string | null;
      /** Max Tokens */
      max_tokens?: string | null;
      /** Stop Sequences */
      stop_sequences?: string | null;
      /** Top P */
      top_p?: string | null;
      /** Top K */
      top_k?: string | null;
      /** Frequency Penalty */
      frequency_penalty?: string | null;
      /** Presence Penalty */
      presence_penalty?: string | null;
      /** Echo */
      echo?: string | null;
      /** Logprobs */
      logprobs?: string | null;
      /** Top Logprobs */
      top_logprobs?: string | null;
      /** N */
      n?: string | null;
      /** Api Version */
      api_version?: string | null;
      /** Tools */
      tools?: string | null;
      /** Tool Choice */
      tool_choice?: string | null;
      /** Response Format */
      response_format?: string | null;
      /** Deployment Name */
      deployment_name?: string | null;
    };
    /** RunResults */
    RunResults: {
      /** Split Total Sample Count */
      split_total_sample_count: number;
      /** Split Total Span Count */
      split_total_span_count?: number | null;
      /** Sample Count */
      sample_count: number;
      /** Span Count */
      span_count?: number | null;
      /** Sample Hard Percentage */
      sample_hard_percentage: number;
      /** Sample Easy Percentage */
      sample_easy_percentage: number;
      /** Sample Misclassified Percentage */
      sample_misclassified_percentage: number;
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Data Metrics
       * @default []
       */
      data_metrics?: components['schemas']['DataRow'][];
      /** Labels */
      labels: string[];
      /** Hard Samples Threshold */
      hard_samples_threshold?: number | null;
      /** Easy Samples Threshold */
      easy_samples_threshold?: number | null;
      /** Top Erroneous Words */
      top_erroneous_words?: {
        [key: string]: number;
      } | null;
    };
    /** RunScorerSettingsRequest */
    RunScorerSettingsRequest: {
      /**
       * Run Id
       * Format: uuid4
       * @description ID of the run.
       */
      run_id: string;
      /**
       * Scorers
       * @description List of Galileo scorers to enable.
       */
      scorers?: components['schemas']['ScorerConfig'][];
    };
    /** RunTagCreateRequest */
    RunTagCreateRequest: {
      /** Key */
      key: string;
      /** Value */
      value: string;
      /** Tag Type */
      tag_type: string;
    };
    /** RunTagDB */
    RunTagDB: {
      /** Key */
      key: string;
      /** Value */
      value: string;
      /** Tag Type */
      tag_type: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** RunUpdateRequest */
    RunUpdateRequest: {
      /** Name */
      name?: string | null;
    };
    /** ScoreAggregate */
    ScoreAggregate: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'score';
      /** Average */
      average: number;
      /** Unrated Count */
      unrated_count: number;
    };
    /** ScoreConstraints */
    ScoreConstraints: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'score';
      /** Min */
      min: number;
      /** Max */
      max: number;
    };
    /** ScoreRating */
    ScoreRating: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'score';
      /** Value */
      value: number;
    };
    /**
     * ScorerConfig
     * @description Used for configuring a scorer for a scorer job.
     */
    ScorerConfig: {
      /** Model Name */
      model_name?: string | null;
      /** Num Judges */
      num_judges?: number | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      scorer_type: components['schemas']['ScorerTypes'];
      /** @description Type of model to use for this scorer. slm maps to luna, and llm maps to plus */
      model_type?: components['schemas']['ModelType'] | null;
    };
    /** ScorerCreatedAtFilter */
    ScorerCreatedAtFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'created_at';
      /**
       * Value
       * Format: date-time
       */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    };
    /** ScorerCreatorFilter */
    ScorerCreatorFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'creator';
      /**
       * Value
       * Format: uuid4
       */
      value: string;
    };
    /** ScorerDefaults */
    ScorerDefaults: {
      /** Model Name */
      model_name?: string | null;
      /** Num Judges */
      num_judges?: number | null;
    };
    /**
     * ScorerName
     * @enum {string}
     */
    ScorerName:
      | '_completeness_gpt'
      | '_context_relevance'
      | '_chunk_attribution_utilization_gpt'
      | '_factuality'
      | '_groundedness'
      | '_latency'
      | '_prompt_perplexity'
      | '_protect_status'
      | '_pii'
      | '_input_pii'
      | '_sexist'
      | '_input_sexist'
      | '_tone'
      | '_input_tone'
      | '_toxicity'
      | '_input_toxicity'
      | '_user_registered'
      | '_user_submitted'
      | '_user_generated'
      | '_uncertainty'
      | '_bleu'
      | '_cost'
      | '_rouge'
      | '_prompt_injection'
      | '_rag_nli'
      | '_adherence_nli'
      | '_completeness_nli'
      | '_chunk_attribution_utilization_nli'
      | '_instruction_adherence'
      | '_ground_truth_adherence'
      | '_tool_selection_quality'
      | '_tool_error_rate'
      | '_agentic_workflow_success'
      | '_customized_completeness_gpt'
      | '_customized_factuality'
      | '_customized_groundedness'
      | '_customized_chunk_attribution_utilization_gpt'
      | '_customized_instruction_adherence'
      | '_customized_ground_truth_adherence'
      | '_customized_tool_selection_quality'
      | '_customized_tool_error_rate'
      | '_customized_agentic_workflow_success';
    /** ScorerNameFilter */
    ScorerNameFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'name';
      /** Value */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'contains';
      /**
       * Case Sensitive
       * @default true
       */
      case_sensitive?: boolean;
    };
    /** ScorerResponse */
    ScorerResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Name */
      name: string;
      scorer_type: components['schemas']['ScorerTypes'];
      defaults?: components['schemas']['ScorerDefaults'] | null;
      latest_version?:
        | components['schemas']['BaseScorerVersionResponse']
        | null;
      /** Tags */
      tags: string[];
      /**
       * Included Fields
       * @description Fields that can be used in the scorer to configure it. i.e. model, num_judges, etc. This enables the ui to know which fields a user can configure when they're setting a scorer
       */
      included_fields?: string[];
      /** Description */
      description?: string | null;
      /** Created By */
      created_by?: string | null;
      /** Created At */
      created_at?: string | null;
      /** Updated At */
      updated_at?: string | null;
    };
    /** ScorerTagsFilter */
    ScorerTagsFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'tags';
      /** Value */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'contains' | 'not_in';
    };
    /**
     * ScorerType
     * @enum {string}
     */
    ScorerType: 'Luna' | 'Plus';
    /** ScorerTypeFilter */
    ScorerTypeFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'scorer_type';
      /** Value */
      value:
        | components['schemas']['ScorerTypes']
        | components['schemas']['ScorerTypes'][];
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'one_of' | 'not_in';
    };
    /**
     * ScorerTypes
     * @enum {string}
     */
    ScorerTypes: 'llm' | 'code' | 'preset';
    /** ScorerUpdatedAtFilter */
    ScorerUpdatedAtFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'updated_at';
      /**
       * Value
       * Format: date-time
       */
      value: string;
      /**
       * Operator
       * @enum {string}
       */
      operator: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    };
    /** ScorerVersionResponse */
    ScorerVersionResponse: {
      /**
       * Scorer Content
       * @description chainpoll template for llm based scorers and the code as a string for code based scorers
       */
      scorer_content: components['schemas']['ChainPollTemplate'] | string;
    };
    /** ScorerVersionsResponse */
    ScorerVersionsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Versions */
      versions?: components['schemas']['ScorerVersionResponse'][];
    };
    /** ScorersConfig */
    ScorersConfig: {
      /**
       * Scorers
       * @description List of Galileo scorers to enable.
       */
      scorers?: (
        | components['schemas']['AgenticWorkflowSuccessScorer']
        | components['schemas']['BleuScorer']
        | components['schemas']['ChunkAttributionUtilizationScorer']
        | components['schemas']['CompletenessScorer']
        | components['schemas']['ContextAdherenceScorer']
        | components['schemas']['ContextRelevanceScorer']
        | components['schemas']['CorrectnessScorer']
        | components['schemas']['GroundTruthAdherenceScorer']
        | components['schemas']['InputPIIScorer']
        | components['schemas']['InputSexistScorer']
        | components['schemas']['InputToneScorer']
        | components['schemas']['InputToxicityScorer']
        | components['schemas']['InstructionAdherenceScorer']
        | components['schemas']['OutputPIIScorer']
        | components['schemas']['OutputSexistScorer']
        | components['schemas']['OutputToneScorer']
        | components['schemas']['OutputToxicityScorer']
        | components['schemas']['PromptInjectionScorer']
        | components['schemas']['PromptPerplexityScorer']
        | components['schemas']['RougeScorer']
        | components['schemas']['ToolErrorRateScorer']
        | components['schemas']['ToolSelectionQualityScorer']
        | components['schemas']['UncertaintyScorer']
      )[];
      /**
       * Registered Scorers
       * @description List of user registered scorers to enable.
       */
      registered_scorers?: components['schemas']['RegisteredScorer'][];
      /**
       * Generated Scorers
       * @description List of user generated scorers to enable.
       */
      generated_scorers?: components['schemas']['GeneratedScorer'][];
    };
    /**
     * ScorersConfiguration
     * @description Configure which scorers to enable for a particular prompt run.
     *
     *     The keys here are sorted by their approximate execution time to execute the scorers that we anticipate will be the
     *     fastest first, and the slowest last.
     */
    ScorersConfiguration: {
      /**
       * Latency
       * @default true
       */
      latency?: boolean;
      /**
       * Cost
       * @default true
       */
      cost?: boolean;
      /**
       * Pii
       * @default false
       */
      pii?: boolean;
      /**
       * Input Pii
       * @default false
       */
      input_pii?: boolean;
      /**
       * Bleu
       * @default true
       */
      bleu?: boolean;
      /**
       * Rouge
       * @default true
       */
      rouge?: boolean;
      /**
       * Protect Status
       * @default true
       */
      protect_status?: boolean;
      /**
       * Context Relevance
       * @default false
       */
      context_relevance?: boolean;
      /**
       * Toxicity
       * @default false
       */
      toxicity?: boolean;
      /**
       * Input Toxicity
       * @default false
       */
      input_toxicity?: boolean;
      /**
       * Tone
       * @default false
       */
      tone?: boolean;
      /**
       * Input Tone
       * @default false
       */
      input_tone?: boolean;
      /**
       * Sexist
       * @default false
       */
      sexist?: boolean;
      /**
       * Input Sexist
       * @default false
       */
      input_sexist?: boolean;
      /**
       * Prompt Injection
       * @default false
       */
      prompt_injection?: boolean;
      /**
       * Adherence Nli
       * @default false
       */
      adherence_nli?: boolean;
      /**
       * Chunk Attribution Utilization Nli
       * @default false
       */
      chunk_attribution_utilization_nli?: boolean;
      /**
       * Completeness Nli
       * @default false
       */
      completeness_nli?: boolean;
      /**
       * Uncertainty
       * @default false
       */
      uncertainty?: boolean;
      /**
       * Factuality
       * @default false
       */
      factuality?: boolean;
      /**
       * Groundedness
       * @default false
       */
      groundedness?: boolean;
      /**
       * Prompt Perplexity
       * @default false
       */
      prompt_perplexity?: boolean;
      /**
       * Chunk Attribution Utilization Gpt
       * @default false
       */
      chunk_attribution_utilization_gpt?: boolean;
      /**
       * Completeness Gpt
       * @default false
       */
      completeness_gpt?: boolean;
      /**
       * Instruction Adherence
       * @default false
       */
      instruction_adherence?: boolean;
      /**
       * Ground Truth Adherence
       * @default false
       */
      ground_truth_adherence?: boolean;
      /**
       * Tool Selection Quality
       * @default false
       */
      tool_selection_quality?: boolean;
      /**
       * Tool Error Rate
       * @default false
       */
      tool_error_rate?: boolean;
      /**
       * Agentic Workflow Success
       * @default false
       */
      agentic_workflow_success?: boolean;
    };
    /** Segment */
    Segment: {
      /** Start */
      start: number;
      /** End */
      end: number;
      /** Value */
      value: number | string;
      /** Prob */
      prob?: number | null;
    };
    /**
     * SegmentationMetricsResponse
     * @description The main metric for Semantic Segmentation.
     *
     *     IoU, or Intersection over Union, is an Semantic Segmentation metric that provides you with a general sense of the
     *     performance of your model.
     *
     *     IoU is defined as the intersection of the predicted and ground truth masks Mean IoU is the average IoU across all
     *     classes Boundary IoU is the IoU for the boundary of the mask, which protects against   bias towards larger masks
     *     https://learnopencv.com/intersection-over-union-iou-in-object-detection-and-segmentation/
     */
    SegmentationMetricsResponse: {
      /** Mean Iou */
      mean_iou: number;
      /** Boundary Iou */
      boundary_iou: number;
      /** Dice Coefficient */
      dice_coefficient: number;
      mean_iou_per_class: components['schemas']['BarChart'];
      boundary_iou_per_class: components['schemas']['BarChart'];
      dice_per_class: components['schemas']['BarChart'];
    };
    /**
     * SemSegErrorType
     * @enum {string}
     */
    SemSegErrorType:
      | 'class_confusion'
      | 'classification'
      | 'background'
      | 'missed'
      | 'None';
    /**
     * Seq2SeqMetricsResponse
     * @description Returns Seq2Seq specific metrics.
     *
     *     Bleu and Rouge are the most common metrics for Seq2Seq models We also include average data error potential
     */
    Seq2SeqMetricsResponse: {
      /** Average Data Error Potential */
      average_data_error_potential?: number | null;
      /** Average Bleu */
      average_bleu?: number | null;
      /** Average Rouge */
      average_rouge?: number | null;
    };
    /** Seq2SeqSegment */
    Seq2SeqSegment: {
      /** Start */
      start: number;
      /** End */
      end: number;
      /** Data Error Potential */
      data_error_potential?: number | null;
      /** Generated Uncertainty */
      generated_uncertainty?: number | null;
      /**
       * Top K Tokens
       * @default []
       */
      top_k_tokens?: components['schemas']['TopKToken'][];
      /** Segment Probability */
      segment_probability?: number | null;
    };
    /** SimilarToResponse */
    SimilarToResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      split: components['schemas']['Split'];
      /** Task */
      task?: string | null;
      /** Inference Name */
      inference_name?: string | null;
      from_split: components['schemas']['Split'];
      /** From Inference Name */
      from_inference_name?: string | null;
      /** Similar Ids */
      similar_ids: number[];
    };
    /** SliceCreate */
    SliceCreate: {
      /** Name */
      name: string;
      logic: components['schemas']['FilterParams'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
    };
    /** SliceCreateResponse */
    SliceCreateResponse: {
      /** Name */
      name: string;
      logic: components['schemas']['FilterParams'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** SliceDB */
    SliceDB: {
      /** Name */
      name: string;
      logic: components['schemas']['FilterParams'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** SliceDeleteResponse */
    SliceDeleteResponse: {
      /** Message */
      message: string;
    };
    /** SliceMetrics */
    SliceMetrics: {
      /** Name */
      name: string;
      logic: components['schemas']['FilterParams'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
      metrics: components['schemas']['ModelMetrics'];
    };
    /** SliceUpdate */
    SliceUpdate: {
      /** Name */
      name: string;
      logic: components['schemas']['FilterParams'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
    };
    /** SliceUpdateResponse */
    SliceUpdateResponse: {
      /** Name */
      name: string;
      logic: components['schemas']['FilterParams'];
      /** Project Id */
      project_id?: string | null;
      /** Created By */
      created_by?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** SocialLoginRequest */
    SocialLoginRequest: {
      /** Id Token */
      id_token: string;
      provider: components['schemas']['SocialProvider'];
    };
    /**
     * SocialProvider
     * @enum {string}
     */
    SocialProvider: 'google' | 'github' | 'okta' | 'azure-ad' | 'custom';
    /** SortClause */
    SortClause: {
      /** Col Name */
      col_name: string;
      sort_dir: components['schemas']['SortDirection'];
      /** Json Field */
      json_field?: string | null;
      json_field_type?: components['schemas']['FieldType'] | null;
    };
    /**
     * SortDirection
     * @enum {string}
     */
    SortDirection: 'asc' | 'desc';
    /** Span */
    Span: {
      /** Id */
      id: number;
      /** Span Start */
      span_start: number;
      /** Span End */
      span_end: number;
      /** Gold */
      gold?: string | null;
      /** Pred */
      pred: string;
      /** Data Error Potential */
      data_error_potential?: number | null;
      /** Confidence */
      confidence?: number | null;
      /** X */
      x?: number | null;
      /** Y */
      y?: number | null;
      /** Is Active */
      is_active: boolean;
      /** Error Type */
      error_type?: string | null;
      /** Is On The Boundary */
      is_on_the_boundary?: boolean | null;
      /** Is Drifted */
      is_drifted?: boolean | null;
    };
    /**
     * Split
     * @enum {string}
     */
    Split: 'training' | 'validation' | 'test' | 'inference';
    /** SplitRunResults */
    SplitRunResults: {
      split_name: components['schemas']['Split'];
      split_run_results: components['schemas']['RunResults'];
    };
    /** StageDB */
    StageDB: {
      /**
       * Name
       * @description Name of the stage. Must be unique within the project.
       */
      name: string;
      /**
       * Project Id
       * Format: uuid4
       * @description ID of the project to which this stage belongs.
       */
      project_id: string;
      /**
       * Description
       * @description Optional human-readable description of the goals of this guardrail.
       */
      description?: string | null;
      /**
       * @description Type of the stage.
       * @default local
       */
      type?: components['schemas']['StageType'];
      /**
       * Paused
       * @description Whether the action is enabled. If False, the action will not be applied.
       * @default false
       */
      paused?: boolean;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Version */
      version?: number | null;
    };
    /** StageMetadata */
    StageMetadata: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Stage Id
       * Format: uuid4
       */
      stage_id: string;
      /** Stage Name */
      stage_name: string;
      /** Stage Version */
      stage_version: number;
      stage_type: components['schemas']['StageType'];
    };
    /**
     * StageType
     * @enum {string}
     */
    StageType: 'local' | 'central';
    /** StageWithRulesets */
    StageWithRulesets: {
      /**
       * Prioritized Rulesets
       * @description Rulesets to be applied to the payload.
       */
      prioritized_rulesets?: components['schemas']['Ruleset'][];
      /**
       * Name
       * @description Name of the stage. Must be unique within the project.
       */
      name: string;
      /**
       * Project Id
       * Format: uuid4
       * @description ID of the project to which this stage belongs.
       */
      project_id: string;
      /**
       * Description
       * @description Optional human-readable description of the goals of this guardrail.
       */
      description?: string | null;
      /**
       * @description Type of the stage.
       * @default local
       */
      type?: components['schemas']['StageType'];
      /**
       * Paused
       * @description Whether the action is enabled. If False, the action will not be applied.
       * @default false
       */
      paused?: boolean;
    };
    /** StandardColumnSort */
    StandardColumnSort: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'standard';
      /**
       * Ascending
       * @default true
       */
      ascending?: boolean;
      /**
       * Sort Type
       * @default column
       * @constant
       */
      sort_type?: 'column';
      /** Column Id */
      column_id: string;
    };
    /** StarAggregate */
    StarAggregate: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'star';
      /** Average */
      average: number;
      /** Counts */
      counts: {
        [key: string]: number;
      };
      /** Unrated Count */
      unrated_count: number;
    };
    /** StarConstraints */
    StarConstraints: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'star';
    };
    /** StarRating */
    StarRating: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'star';
      /** Value */
      value: number;
    };
    /** StepMetric */
    StepMetric: {
      /** Name */
      name: string;
      /** Value */
      value: unknown;
    };
    /** StepWithChildSpans */
    StepWithChildSpans: {
      /**
       * @description Type of the step. By default, it is set to workflow.
       * @default workflow
       */
      type?: components['schemas']['NodeType'];
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Spans
       * @description Child spans.
       */
      spans?: (
        | components['schemas']['WorkflowSpan']
        | components['schemas']['LlmSpan']
        | components['schemas']['RetrieverSpan']
        | components['schemas']['ToolSpan']
      )[];
    };
    /** StepWithChildren */
    StepWithChildren: {
      /**
       * @description Type of the step. By default, it is set to workflow.
       * @default workflow
       */
      type?: components['schemas']['NodeType'];
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Steps
       * @description Steps in the workflow.
       */
      steps?: (
        | components['schemas']['WorkflowStep']
        | components['schemas']['ChainStep']
        | components['schemas']['LlmStep']
        | components['schemas']['RetrieverStep']
        | components['schemas']['ToolStep']
        | components['schemas']['AgentStep']
      )[];
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildren'] | null;
    };
    /** SubscriptionConfig */
    SubscriptionConfig: {
      /**
       * Statuses
       * @description List of statuses that will cause a notification to be sent to the configured URL.
       * @default [
       *       "triggered"
       *     ]
       */
      statuses?: components['schemas']['ExecutionStatus'][];
      /**
       * Url
       * Format: uri
       * @description URL to send the event to. This can be a webhook URL, a message queue URL, an event bus or a custom endpoint that can receive an HTTP POST request.
       */
      url: string;
    };
    /** SummaryIDRequest */
    SummaryIDRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /**
       * Include Emb
       * @default true
       */
      include_emb?: boolean;
      /**
       * Page Num
       * @default 0
       */
      page_num?: number;
      /**
       * Hard Easy Threshold
       * @default false
       */
      hard_easy_threshold?: boolean;
      /** Sort By */
      sort_by?: string | null;
      /**
       * Sort By Id List
       * @default false
       */
      sort_by_id_list?: boolean;
      /**
       * Sort Ascending
       * @default false
       */
      sort_ascending?: boolean;
    };
    /** SummaryIDResponse */
    SummaryIDResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /**
       * Include Emb
       * @default true
       */
      include_emb?: boolean;
      /**
       * Page Num
       * @default 0
       */
      page_num?: number;
      /**
       * Hard Easy Threshold
       * @default false
       */
      hard_easy_threshold?: boolean;
      /** Sort By */
      sort_by?: string | null;
      /**
       * Sort By Id List
       * @default false
       */
      sort_by_id_list?: boolean;
      /**
       * Sort Ascending
       * @default false
       */
      sort_ascending?: boolean;
      /** Ids */
      ids: number[];
    };
    /** SummaryRequest */
    SummaryRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /**
       * Include Emb
       * @default true
       */
      include_emb?: boolean;
      /**
       * Page Num
       * @default 0
       */
      page_num?: number;
      /**
       * Hard Easy Threshold
       * @default false
       */
      hard_easy_threshold?: boolean;
      /** Sort By */
      sort_by?: string | null;
      /**
       * Sort By Id List
       * @default false
       */
      sort_by_id_list?: boolean;
      /**
       * Sort Ascending
       * @default false
       */
      sort_ascending?: boolean;
    };
    /**
     * TaggingSchema
     * @description Supported NER Tagging schemas.
     *
     *     A tagging schema is a definition of the way NER data is formatted. The schema
     *     letters define the tags used within it.
     *         ex:
     *             BIOES - B means before (a token), I means in (a token),
     *                 E means end (of a token), S means single (length token)
     *     See https://en.wikipedia.org/wiki/Inside%E2%80%93outside%E2%80%93beginning_(tagging)
     * @enum {string}
     */
    TaggingSchema: 'BIO' | 'BIOES' | 'BILOU';
    /** TagsAggregate */
    TagsAggregate: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'tags';
      /** Counts */
      counts: {
        [key: string]: number;
      };
      /** Unrated Count */
      unrated_count: number;
    };
    /** TagsConstraints */
    TagsConstraints: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'tags';
      /** Tags */
      tags: string[];
      /**
       * Allow Other
       * @default false
       */
      allow_other?: boolean;
    };
    /** TagsRating */
    TagsRating: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'tags';
      /** Value */
      value: string[];
    };
    /**
     * TargetLabels
     * @description Structure for each target label in a co-occurence response.
     */
    TargetLabels: {
      /** Label */
      label: string;
      /** Co Occurrence */
      co_occurrence: number;
    };
    /**
     * TaskResponse
     * @description Response for the available task-labels of a multi-label model.
     */
    TaskResponse: {
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /** Tasks */
      tasks: string[];
    };
    /**
     * TaskType
     * @description Valid task types for modeling.
     *
     *     We store these as ints instead of strings because we will be looking this up in the database frequently.
     * @enum {integer}
     */
    TaskType:
      | 0
      | 1
      | 2
      | 3
      | 4
      | 5
      | 6
      | 7
      | 8
      | 9
      | 10
      | 11
      | 12
      | 13
      | 14
      | 15
      | 16;
    /** TextConstraints */
    TextConstraints: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'text';
    };
    /** TextRating */
    TextRating: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      feedback_type: 'text';
      /** Value */
      value: string;
    };
    /** ThresholdRequest */
    ThresholdRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
    };
    /** ThresholdResponse */
    ThresholdResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Easy Samples Threshold */
      easy_samples_threshold: number;
      /** Hard Samples Threshold */
      hard_samples_threshold: number;
    };
    /** Token */
    Token: {
      /** Access Token */
      access_token: string;
      /**
       * Token Type
       * @default bearer
       */
      token_type?: string;
    };
    /** ToolErrorRateScorer */
    ToolErrorRateScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'tool_error_rate';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default plus
       * @constant
       */
      type?: 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
    };
    /**
     * ToolErrorRateTemplate
     * @description Template for the tool error rate metric,
     *     containing all the info necessary to send the tool error rate prompt.
     */
    ToolErrorRateTemplate: {
      /**
       * Metric System Prompt
       * @default One or more functions have been called, and you will receive their output. The output format could be a string containing the tool's result, it could be in JSON or XML format with additional metadata and information, or it could be a list of the outputs in any such format.
       *
       *     Your task is to determine whether at least one function call didn't execute correctly and errored out. If at least one call failed, then you should consider the entire call as a failure.
       *     You should NOT evaluate any other aspect of the tool call. In particular you should not evaluate whether the output is well formatted, coherent or contains spelling mistakes.
       *
       *     If you conclude that the call failed, provide an explanation as to why. You may summarize any error message you encounter. If the call was successful, no explanation is needed.
       *
       *     Respond in the following JSON format:
       *
       *     ```
       *     {
       *        "function_errored_out": boolean,
       *        "explanation": string
       *     }
       *     ```
       *
       *     - **"function_errored_out"**: Use `false` if all tool calls were successful, and `true` if at least one errored out.
       *
       *     - **"explanation"**: If a tool call failed, provide your step-by-step reasoning to determine why it might have failed. If all tool calls were succesful, leave this blank.
       *
       *     You must respond with a valid JSON object; don't forget to escape special characters.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @default I have a multi-turn chatbot application where the assistant is an agent that has access to tools. I want a metric to evaluate whether a tool invocation was successful or if it resulted in an error.
       */
      metric_description?: string;
      /**
       * Value Field Name
       * @default function_errored_out
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default Tools output:
       *     ```
       *     {response}
       *     ```
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @default [
       *       {
       *         "generation_prompt_and_response": "Tools output:\n```\n0\n```",
       *         "evaluating_response": "{\n  \"function_errored_out\": false,\n  \"explanation\": \"\"\n}"
       *       },
       *       {
       *         "generation_prompt_and_response": "Tools output:\n```\n{\n  \"error\": \"InvalidFunctionArgumentException\",\n  \"status_code\": 400\n}\n```",
       *         "evaluating_response": "{\n  \"function_errored_out\": true,\n  \"explanation\": \"The call failed due to an InvalidFunctionArgumentException.\",\n}"
       *       }
       *     ]
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** ToolSelectionQualityScorer */
    ToolSelectionQualityScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'tool_selection_quality';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
      /**
       * Type
       * @default plus
       * @constant
       */
      type?: 'plus';
      /**
       * Model Name
       * @description Alias of the model to use for the scorer.
       */
      model_name?: string | null;
      /**
       * Num Judges
       * @description Number of judges for the scorer.
       */
      num_judges?: number | null;
    };
    /**
     * ToolSelectionQualityTemplate
     * @description Template for the tool selection quality metric,
     *     containing all the info necessary to send the tool selection quality prompt.
     */
    ToolSelectionQualityTemplate: {
      /**
       * Metric System Prompt
       * @default You will receive the chat history from a chatbot application. At the end of the  conversation, it will be the bots turn to act. The bot has several options: it can reflect and plan its next steps, choose to call tools, or respond directly to the user. If the bot opts to use tools, the tools execute separately, and the bot will subsequently review the output from those tools. Ultimately, the bot should reply to the user, choosing the relevant parts of the tools' output.
       *
       *     Your task is to evaluate the bot's decision-making process and ensure it follows these guidelines:
       *     - If all user queries have already been answered and can be found in the chat history, the bot should not call tools.
       *     - If no suitable tools are available to assist with user queries, the bot should not call tools.
       *     - If the chat history contains all the necessary information to directly answer all user queries, the bot should not call tools.
       *     - If the bot decided to call tools, the tools and argument values selected must relate to at least part of one user query.
       *     - If the bot decided to call tools, all arguments marked as "required" in the tools' schema must be provided with values.
       *
       *     Remember that there are many ways the bot's actions can comply with these rules. Your role is to determine whether the bot fundamentally violated any of these rules, not whether it chose the most optimal response.
       *
       *     Respond in the following JSON format:
       *     ```
       *     {
       *         "explanation": string,
       *         "bot_answer_follows_rules": boolean
       *     }
       *     ```
       *
       *     - **"explanation"**: Provide your step-by-step reasoning to determine whether the bot's reply follows the above-mentioned guidelines.
       *
       *     - **"bot_answer_follows_rules"**: Respond `true` if you believe the bot followed the above guidelines, respond `false` otherwise.
       *
       *     You must respond with a valid JSON object; don't forget to escape special characters.
       */
      metric_system_prompt?: string;
      /**
       * Metric Description
       * @default I have a multi-turn chatbot application where the assistant is an agent that has access to tools. I want a metric that assesses whether the assistant made the correct decision in choosing to either use tools or to directly respond, and in cases where it uses tools, whether it selected the correct tools with the correct arguments.
       */
      metric_description?: string;
      /**
       * Value Field Name
       * @default bot_answer_follows_rules
       */
      value_field_name?: string;
      /**
       * Explanation Field Name
       * @description Field name to look for in the chainpoll response, for the explanation.
       * @default explanation
       */
      explanation_field_name?: string;
      /**
       * Template
       * @default Chatbot history:
       *     ```
       *     {query}
       *     ```
       *
       *     The bot's available tools:
       *     ```
       *     {tools}
       *     ```
       *
       *     The answer to evaluate:
       *     ```
       *     {response}
       *     ```
       */
      template?: string;
      /**
       * Metric Few Shot Examples
       * @default [
       *       {
       *         "generation_prompt_and_response": "Chatbot history:\n```\nhuman: Do the genuses Sapium and Aristotelia belong to the same family?\n```\n\nThe bot's available tools:\n```\n[{'name': 'Search',\n  'description': 'Search for the query',\n  'parameters': {'type': 'object',\n   'properties': {'query': {'type': 'string',\n     'description': 'the query to search'}},\n   'required': ['query']}},\n {'name': 'Lookup',\n  'description': 'Lookup the keyword',\n  'parameters': {'type': 'object',\n   'properties': {'keyword': {'type': 'string',\n     'description': 'the keyword to lookup'}},\n   'required': ['keyword']}}]\n```\n\nThe answer to evaluate:\n```\n{\"Thought\": \"I need to search Sapium and Aristotelia, find their families, then find if they are the same.\", \"Action\": {\"name\": \"Search\", \"arguments\": {\"query\": \"Sapium\"}}}\n```",
       *         "evaluating_response": "{\n    \"explanation\": \"The user asked if the genuses Sapium and Aristotelia belong to the same family. The bot decided to search for 'Sapium', which is associated with part of the user's query regarding the family of Sapium. The action aligns with the user's query, and all required arguments ('query') are provided, making the tool call valid. Furthermore, the information required to answer the user's question is not present in the chat history, justifying the bot's decision to call a tool.\",\n    \"bot_answer_follows_rules\": true\n}"
       *       }
       *     ]
       */
      metric_few_shot_examples?: components['schemas']['FewShotExample'][];
    };
    /** ToolSpan */
    ToolSpan: {
      /**
       * @description Type of the step. By default, it is set to tool. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'tool';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
    };
    /** ToolSpanWithMetrics */
    ToolSpanWithMetrics: {
      /**
       * Trace Id
       * Format: uuid4
       */
      trace_id: string;
      /** Parent Id */
      parent_id?: string | null;
      /**
       * Step Id
       * Format: uuid4
       */
      step_id: string;
      /** Metrics */
      metrics?: {
        [key: string]:
          | components['schemas']['MetricNotComputed']
          | components['schemas']['MetricPending']
          | components['schemas']['MetricComputing']
          | components['schemas']['MetricNotApplicable']
          | components['schemas']['MetricSuccess']
          | components['schemas']['MetricError']
          | components['schemas']['MetricFailed'];
      };
      /**
       * @description Type of the step. By default, it is set to tool. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'tool';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
    };
    /** ToolStep */
    ToolStep: {
      /**
       * @description Type of the step. By default, it is set to tool. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'tool';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
    };
    /** TopInsightsRequest */
    TopInsightsRequest: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
    };
    /** TopInsightsResponse */
    TopInsightsResponse: {
      /** Task */
      task?: string | null;
      /** @default {
       *       "ids": [],
       *       "span_regex": false,
       *       "exclude_ids": [],
       *       "likely_mislabeled_dep_percentile": 0,
       *       "data_embs": false
       *     } */
      filter_params?: components['schemas']['FilterParams'];
      compare_to?: components['schemas']['Split'] | null;
      /**
       * Map Threshold
       * @default 0.5
       */
      map_threshold?: number;
      /** Meta Cols */
      meta_cols?: string[] | null;
      /**
       * Top Misclassified Pairs
       * @default []
       */
      top_misclassified_pairs?: Record<string, never>[];
      /** Top Misclassified Pairs Percentage */
      top_misclassified_pairs_percentage: number;
      /**
       * Top Correlation Pairs
       * @default {}
       */
      top_correlation_pairs?: {
        [key: string]: number;
      };
      /**
       * Top Erroneous Words
       * @default {}
       */
      top_erroneous_words?: {
        [key: string]: number;
      };
    };
    /**
     * TopKToken
     * @description Representation of a token and its probability for Segment Top k logprob tokens.
     *
     *     Attributes:
     *         token: The text of the token
     *         prob: The probability of the token
     */
    TopKToken: {
      /** Token */
      token: string;
      /** Prob */
      prob: number;
    };
    /** Trace */
    Trace: {
      /**
       * Type
       * @description Type of the span. By default, it is set to trace.
       * @default trace
       * @constant
       */
      type?: 'trace';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Spans
       * @description Child spans.
       */
      spans?: (
        | components['schemas']['WorkflowSpan']
        | components['schemas']['LlmSpan']
        | components['schemas']['RetrieverSpan']
        | components['schemas']['ToolSpan']
      )[];
    };
    /** TraceMetadata */
    TraceMetadata: {
      /**
       * Id
       * Format: uuid4
       * @description Unique identifier for the request.
       */
      id?: string;
      /**
       * Received At
       * @description Time the request was received by the server in nanoseconds.
       */
      received_at?: number;
      /**
       * Response At
       * @description Time the response was sent by the server in nanoseconds.
       */
      response_at?: number;
      /**
       * Execution Time
       * @description Execution time for the request (in seconds).
       * @default -1
       */
      execution_time?: number;
    };
    /** TraceWithMetrics */
    TraceWithMetrics: {
      /**
       * Trace Id
       * Format: uuid4
       */
      trace_id: string;
      /** Parent Id */
      parent_id?: string | null;
      /**
       * Step Id
       * Format: uuid4
       */
      step_id: string;
      /** Metrics */
      metrics?: {
        [key: string]:
          | components['schemas']['MetricNotComputed']
          | components['schemas']['MetricPending']
          | components['schemas']['MetricComputing']
          | components['schemas']['MetricNotApplicable']
          | components['schemas']['MetricSuccess']
          | components['schemas']['MetricError']
          | components['schemas']['MetricFailed'];
      };
      /**
       * Type
       * @description Type of the span. By default, it is set to trace.
       * @default trace
       * @constant
       */
      type?: 'trace';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** Spans */
      spans?: (
        | components['schemas']['WorkflowSpanWithMetrics']
        | components['schemas']['LlmSpanWithMetrics']
        | components['schemas']['RetrieverSpanWithMetrics']
        | components['schemas']['ToolSpanWithMetrics']
      )[];
    };
    /** TracesIngestRequest */
    TracesIngestRequest: {
      /**
       * Log Stream Id
       * @description Log stream id associated with the traces.
       */
      log_stream_id?: string | null;
      /**
       * Experiment Id
       * @description Experiment id associated with the traces.
       */
      experiment_id?: string | null;
      /**
       * Traces
       * @description List of traces to log.
       */
      traces: components['schemas']['Trace'][];
      /** @default api_direct */
      logging_method?: components['schemas']['LogDataLoggingMethod'];
      /** Client Version */
      client_version?: string | null;
    };
    /** TracesIngestResponse */
    TracesIngestResponse: {
      /**
       * Log Stream Id
       * @description Log stream id associated with the traces.
       */
      log_stream_id?: string | null;
      /**
       * Experiment Id
       * @description Experiment id associated with the traces.
       */
      experiment_id?: string | null;
      /**
       * Project Id
       * Format: uuid4
       * @description Project id associated with the traces.
       */
      project_id: string;
      /**
       * Project Name
       * @description Project name associated with the traces.
       */
      project_name: string;
      /**
       * Traces Count
       * @description total number of traces ingested
       */
      traces_count: number;
      /**
       * Records Count
       * @description total number of records (traces & spans) ingested
       */
      records_count: number;
    };
    /** TrainJobAuthTokenResponse */
    TrainJobAuthTokenResponse: {
      /** Token */
      token: string;
      /** File Url */
      file_url: string;
    };
    /** TrainJobStatusResponse */
    TrainJobStatusResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Status */
      status: string;
      /** Status Message */
      status_message: string;
      /** Project Id */
      project_id?: string | null;
      /** Run Id */
      run_id?: string | null;
      /** History */
      history: unknown[];
      /** Project Name */
      project_name?: string | null;
      /** Run Name */
      run_name?: string | null;
    };
    /** TrainResponse */
    TrainResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
    };
    /** TrainingModelResponse */
    TrainingModelResponse: {
      kind: components['schemas']['ModelKind'];
      /** Parameters */
      parameters: Record<string, never>;
      /**
       * Run Id
       * Format: uuid4
       */
      run_id: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** Filename */
      filename?: string | null;
      /** Storage Url */
      storage_url?: string | null;
      /** @default pending */
      upload_status?: components['schemas']['ModelUploadStatus'];
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Run Name */
      run_name: string;
      /** Project Name */
      project_name: string;
    };
    /**
     * TransactionLoggingMethod
     * @enum {string}
     */
    TransactionLoggingMethod:
      | 'py_langchain'
      | 'py_langchain_async'
      | 'js_langchain'
      | 'py_logger'
      | 'js_logger'
      | 'api_direct'
      | 'workflows';
    /** TransactionMetricInfo */
    TransactionMetricInfo: {
      /**
       * Chunk Attribution
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_attribution?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Length
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_length?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Utilized Substrings
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_utilized_substrings?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Utilized Substrings Offsets
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_utilized_substrings_offsets?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Utilization
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_utilization?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Utilized
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_utilized?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Relevance
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_relevance?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Relevant
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_relevant?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Relevant Substrings
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_relevant_substrings?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunk Relevant Substrings Offsets
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunk_relevant_substrings_offsets?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Rag Nli Non Adherent Substrings
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      rag_nli_non_adherent_substrings?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Rag Nli Non Adherent Substrings Offsets
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      rag_nli_non_adherent_substrings_offsets?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunks Attributed
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunks_attributed?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunks Length
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunks_length?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunks Unattributed
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunks_unattributed?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Chunks Utilized
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      chunks_utilized?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Completeness Gpt
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      completeness_gpt?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Cost
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      cost?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Factuality
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      factuality?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Groundedness
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      groundedness?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Pii
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_pii?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Pii Spans
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_pii_spans?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Pii Spans Prob
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_pii_spans_prob?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Pii Spans Offset
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_pii_spans_offset?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Sexist
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_sexist?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Tone
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_tone?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Input Toxicity
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      input_toxicity?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Instruction Adherence
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      instruction_adherence?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Latency
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      latency?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Pii
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      pii?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Pii Spans
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      pii_spans?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Pii Spans Prob
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      pii_spans_prob?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Pii Spans Offset
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      pii_spans_offset?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Prompt Perplexity
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      prompt_perplexity?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Protect Status
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      protect_status?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Retriever Attribution
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      retriever_attribution?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Retriever Utilization
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      retriever_utilization?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Sexist
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      sexist?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Toxicity
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      toxicity?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Tone
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      tone?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Prompt Injection
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      prompt_injection?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Tool Selection Quality
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      tool_selection_quality?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Tool Error Rate
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      tool_error_rate?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
      /**
       * Agentic Workflow Success
       * @default {
       *       "status_type": "not_computed",
       *       "message": "Metric not computed."
       *     }
       */
      agentic_workflow_success?:
        | components['schemas']['MetricNotComputed']
        | components['schemas']['MetricPending']
        | components['schemas']['MetricComputing']
        | components['schemas']['MetricNotApplicable']
        | components['schemas']['MetricSuccess']
        | components['schemas']['MetricError']
        | components['schemas']['MetricFailed'];
    } & {
      [key: string]: unknown;
    };
    /** TransactionMetricsResponse */
    TransactionMetricsResponse: {
      /** Group By Columns */
      group_by_columns: string[];
      aggregate_metrics: components['schemas']['AggregateMetrics'];
      /** Bucketed Metrics */
      bucketed_metrics: {
        [key: string]: components['schemas']['BucketedMetrics'][];
      };
    };
    /** TransactionRecordBatch */
    TransactionRecordBatch: {
      /** Records */
      records: components['schemas']['TransactionRecordIngest'][];
      /** @default api_direct */
      logging_method?: components['schemas']['TransactionLoggingMethod'];
      /** Client Version */
      client_version?: string | null;
    };
    /** TransactionRecordDB */
    TransactionRecordDB: {
      /** Latency Ms */
      latency_ms?: number | null;
      /** Time To First Token Ms */
      time_to_first_token_ms?: number | null;
      /** Status Code */
      status_code?: number | null;
      /** Model */
      model?: string | null;
      /** Num Input Tokens */
      num_input_tokens?: number | null;
      /** Num Output Tokens */
      num_output_tokens?: number | null;
      /** Num Total Tokens */
      num_total_tokens?: number | null;
      /** Finish Reason */
      finish_reason?: string | null;
      /**
       * Node Id
       * Format: uuid4
       */
      node_id: string;
      /** Chain Id */
      chain_id?: string | null;
      /** Chain Root Id */
      chain_root_id?: string | null;
      /** Output Logprobs */
      output_logprobs?: Record<string, never> | null;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Temperature */
      temperature?: number | null;
      /** Tags */
      tags?: string[] | null;
      /** User Metadata */
      user_metadata?: {
        [key: string]: string;
      } | null;
      /** Node Name */
      node_name?: string | null;
      node_type: components['schemas']['NodeType'];
      /** Has Children */
      has_children?: boolean | null;
      /** Version */
      version?: string | null;
      /** Input Text */
      input_text: string;
      /** Output Text */
      output_text?: string | null;
      /** Tools */
      tools?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** @default unprocessed */
      metrics_status?: components['schemas']['TransactionRecordStatus'];
      /** Metrics Batch Id */
      metrics_batch_id?: string | null;
      metric_info: components['schemas']['TransactionMetricInfo'];
      /** Feedback Ratings */
      feedback_ratings?: {
        [key: string]: components['schemas']['FeedbackRatingDB'];
      };
    };
    /** TransactionRecordIngest */
    TransactionRecordIngest: {
      /** Latency Ms */
      latency_ms?: number | null;
      /** Time To First Token Ms */
      time_to_first_token_ms?: number | null;
      /** Status Code */
      status_code?: number | null;
      /** Model */
      model?: string | null;
      /** Num Input Tokens */
      num_input_tokens?: number | null;
      /** Num Output Tokens */
      num_output_tokens?: number | null;
      /** Num Total Tokens */
      num_total_tokens?: number | null;
      /** Finish Reason */
      finish_reason?: string | null;
      /**
       * Node Id
       * Format: uuid4
       */
      node_id: string;
      /** Chain Id */
      chain_id?: string | null;
      /** Chain Root Id */
      chain_root_id?: string | null;
      /** Output Logprobs */
      output_logprobs?: Record<string, never> | null;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /** Temperature */
      temperature?: number | null;
      /** Tags */
      tags?: string[] | null;
      /** User Metadata */
      user_metadata?: {
        [key: string]: string;
      } | null;
      /** Node Name */
      node_name?: string | null;
      node_type: components['schemas']['NodeType'];
      /** Has Children */
      has_children?: boolean | null;
      /** Version */
      version?: string | null;
      /** Input Text */
      input_text: string;
      /** Output Text */
      output_text?: string | null;
      /** Tools */
      tools?: string | null;
    };
    /**
     * TransactionRecordStatus
     * @enum {string}
     */
    TransactionRecordStatus: 'unprocessed' | 'processing' | 'processed';
    /**
     * TransactionRecordsResponse
     * @description Rows response with column types for json blobs.
     *
     *     columns example:
     *     {
     *       "metrics": {
     *         "uncertainty": "float"
     *       },
     *       "user_metadata": {
     *         "source": "string"
     *       }
     *     }
     */
    TransactionRecordsResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Columns */
      columns: {
        [key: string]: {
          [key: string]: string;
        };
      };
      /** Rows */
      rows: components['schemas']['TransactionRecordDB'][];
      /** Filter Options */
      filter_options?: {
        [key: string]: string[];
      };
    };
    /** TransactionRowsRequestBody */
    TransactionRowsRequestBody: {
      /** Filters */
      filters?: components['schemas']['QueryFilterV1'][];
      /**
       * Sort Spec
       * @default [
       *       {
       *         "col_name": "created_at",
       *         "sort_dir": "desc"
       *       }
       *     ]
       */
      sort_spec?: components['schemas']['SortClause'][];
      /** Columns */
      columns?: string[] | null;
    };
    /** TransferUserResponse */
    TransferUserResponse: {
      /** Message */
      message: string;
    };
    /** UncertaintyScorer */
    UncertaintyScorer: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'uncertainty';
      /**
       * Filters
       * @description List of filters to apply to the scorer.
       */
      filters?:
        | (
            | components['schemas']['NodeNameFilter']
            | components['schemas']['MetadataFilter']
          )[]
        | null;
    };
    /** UpdateAlertConfigurationRequest */
    UpdateAlertConfigurationRequest: {
      /** Conditions */
      conditions?: components['schemas']['AlertCondition'][] | null;
      /** Interval */
      interval?: number | null;
      /** Active */
      active?: boolean | null;
      /** Processed By */
      processed_by?: string | null;
      /** Last Triggered */
      last_triggered?: string | null;
      /** Last Sent */
      last_sent?: string | null;
      /** Alert Sent */
      alert_sent?: boolean | null;
      /** Counter Since Last Sent */
      counter_since_last_sent?: number | null;
      /** Counter */
      counter?: number | null;
      schema_version?: components['schemas']['AlertMonitorType'] | null;
    };
    /** UpdateDatasetContentRequest */
    UpdateDatasetContentRequest: {
      /** Edits */
      edits: (
        | components['schemas']['DatasetAppendRow']
        | components['schemas']['DatasetUpdateRow']
        | components['schemas']['DatasetDeleteRow']
        | components['schemas']['DatasetDeleteColumn']
        | components['schemas']['DatasetRenameColumn']
        | components['schemas']['DatasetAddColumn']
      )[];
    };
    /** UpdateDatasetRequest */
    UpdateDatasetRequest: {
      /** Name */
      name?: string | null;
    };
    /** UpdateDatasetVersionRequest */
    UpdateDatasetVersionRequest: {
      /** Name */
      name?: string | null;
    };
    /** UpdateGeneratedScorerRequest */
    UpdateGeneratedScorerRequest: {
      /** Name */
      name?: string | null;
      /** Instructions */
      instructions?: string | null;
      /** Scoreable Node Types */
      scoreable_node_types?: components['schemas']['NodeType'][] | null;
      scorer_configuration?:
        | components['schemas']['GeneratedScorerConfiguration']
        | null;
      chain_poll_template?: components['schemas']['ChainPollTemplate'] | null;
    };
    /** UpdateRunResponse */
    UpdateRunResponse: {
      /** Name */
      name?: string | null;
      /** Project Id */
      project_id?: string | null;
      /**
       * Created By
       * Format: uuid4
       */
      created_by: string;
      /** Num Samples */
      num_samples: number;
      /** Winner */
      winner: boolean;
      /** Dataset Hash */
      dataset_hash?: string | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
      task_type?: components['schemas']['TaskType'] | null;
      /**
       * Last Updated By
       * Format: uuid4
       */
      last_updated_by: string;
      /** Run Tags */
      run_tags?: components['schemas']['RunTagDB'][];
    };
    /** UpdateScorerRequest */
    UpdateScorerRequest: {
      /** Name */
      name?: string | null;
      /** Description */
      description?: string | null;
      /** Tags */
      tags?: string[] | null;
      defaults?: components['schemas']['ScorerDefaults'] | null;
    };
    /** UpdateUserResponse */
    UpdateUserResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /** Email Is Verified */
      email_is_verified?: boolean | null;
      /**
       * Organization Id
       * Format: uuid4
       */
      organization_id: string;
      /** Organization Name */
      organization_name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /** UploadModel */
    UploadModel: {
      /** Parameters */
      parameters: Record<string, never>;
      kind: components['schemas']['ModelKind'];
    };
    /** UploadModelResponse */
    UploadModelResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Filename */
      filename: string;
      /** Upload Url */
      upload_url: string;
    };
    /** UsagePlan */
    UsagePlan: {
      /** Max Traces Per Month */
      max_traces_per_month: number;
      /** Max Organizations Per User */
      max_organizations_per_user: number;
      /** Max Users Per Organization */
      max_users_per_organization: number;
      /** Max Data Visibility Days */
      max_data_visibility_days: number;
      /** Max Payload Size Bytes */
      max_payload_size_bytes: number;
    };
    /**
     * UsagePlanName
     * @enum {string}
     */
    UsagePlanName: 'developer' | 'pro' | 'enterprise';
    /**
     * UserAction
     * @enum {string}
     */
    UserAction: 'update' | 'delete' | 'read_api_keys';
    /** UserCollaborator */
    UserCollaborator: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      role: components['schemas']['CollaboratorRole'];
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * User Id
       * Format: uuid4
       */
      user_id: string;
      /** First Name */
      first_name: string | null;
      /** Last Name */
      last_name: string | null;
      /** Email */
      email: string;
    };
    /** UserCollaboratorCreate */
    UserCollaboratorCreate: {
      /** @default viewer */
      role?: components['schemas']['CollaboratorRole'];
      /**
       * User Id
       * Format: uuid4
       */
      user_id: string;
    };
    /** UserCreate */
    UserCreate: {
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /**
       * Email Is Verified
       * @default false
       */
      email_is_verified?: boolean | null;
      /** Password */
      password?: string | null;
    };
    /** UserDB */
    UserDB: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /** Email Is Verified */
      email_is_verified?: boolean | null;
      /**
       * Organization Id
       * Format: uuid4
       */
      organization_id: string;
      /** Organization Name */
      organization_name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /**
     * UserInfo
     * @description A user's basic information, used for display purposes.
     */
    UserInfo: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Email
       * Format: email
       */
      email: string;
      /** First Name */
      first_name?: string | null;
      /** Last Name */
      last_name?: string | null;
    };
    /** UserMetadataFilter */
    UserMetadataFilter: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'user_metadata';
      /**
       * Operator
       * @enum {string}
       */
      operator: 'one_of' | 'not_in' | 'eq' | 'ne';
      /** Key */
      key: string;
      /** Value */
      value: string | string[];
    };
    /** UserPasswordResetRequest */
    UserPasswordResetRequest: {
      /** Email */
      email: string;
      /** Password */
      password?: string | null;
      /**
       * Email Is Verified
       * @default true
       */
      email_is_verified?: boolean;
    };
    /** UserPasswordResetResponse */
    UserPasswordResetResponse: {
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /**
       * Permissions
       * @default []
       */
      permissions?: components['schemas']['Permission'][];
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * First Name
       * @default
       */
      first_name?: string | null;
      /**
       * Last Name
       * @default
       */
      last_name?: string | null;
      /** @default email */
      auth_method?: components['schemas']['AuthMethod'];
      /** @default read_only */
      role?: components['schemas']['UserRole'];
      /** Email Is Verified */
      email_is_verified?: boolean | null;
      /**
       * Organization Id
       * Format: uuid4
       */
      organization_id: string;
      /** Organization Name */
      organization_name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /**
     * UserRole
     * @enum {string}
     */
    UserRole: 'admin' | 'manager' | 'user' | 'read_only';
    /** UserRoleInfo */
    UserRoleInfo: {
      name: components['schemas']['UserRole'];
      /** Display Name */
      display_name: string;
      /** Description */
      description: string;
    };
    /** UserUpdate */
    UserUpdate: {
      /** Email */
      email?: string | null;
      /** First Name */
      first_name?: string | null;
      /** Last Name */
      last_name?: string | null;
      role?: components['schemas']['UserRole'] | null;
      /** Email Is Verified */
      email_is_verified?: boolean | null;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** ValidationRequest */
    ValidationRequest: {
      /**
       * File Type
       * @default csv
       */
      file_type?: string;
      /** Payload */
      payload: string;
    };
    /** ValidationResponse */
    ValidationResponse: {
      /** Upload Url */
      upload_url: string;
      /** Filename */
      filename: string;
    };
    /** ValuePromptFilterParam */
    ValuePromptFilterParam: {
      /** Column */
      column: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      filter_type: 'value';
      /** Value */
      value: number | boolean | string;
      relation: components['schemas']['Operator'];
    };
    /** VertexAIIntegration */
    VertexAIIntegration: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'vertex_ai';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** VertexAIIntegrationCreate */
    VertexAIIntegrationCreate: {
      /** Token */
      token: string;
    };
    /** Webhook */
    Webhook: {
      /**
       * Url
       * Format: uri
       */
      url: string;
      /** @default untested */
      status?: components['schemas']['WebhookStatus'];
      /**
       * Notes
       * @default
       */
      notes?: string;
    };
    /**
     * WebhookStatus
     * @enum {string}
     */
    WebhookStatus: 'active' | 'untested' | 'failed' | 'paused';
    /** WeeklyChangelog */
    WeeklyChangelog: {
      /**
       * Week Of
       * Format: date
       */
      week_of: string;
      /** Changes */
      changes?: {
        [key: string]: components['schemas']['Changes'];
      };
    };
    /** WorkflowCountResponse */
    WorkflowCountResponse: {
      /** Count */
      count: number;
      /**
       * Max Rows
       * @default 512
       */
      max_rows?: number;
      /**
       * Max Rows Exceeded
       * @default false
       */
      max_rows_exceeded?: boolean;
    };
    /** WorkflowSpan */
    WorkflowSpan: {
      /**
       * @description Type of the span. By default, it is set to workflow. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'workflow';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
      /**
       * Spans
       * @description Child spans.
       */
      spans?: (
        | components['schemas']['WorkflowSpan']
        | components['schemas']['LlmSpan']
        | components['schemas']['RetrieverSpan']
        | components['schemas']['ToolSpan']
      )[];
    };
    /** WorkflowSpanWithMetrics */
    WorkflowSpanWithMetrics: {
      /**
       * Trace Id
       * Format: uuid4
       */
      trace_id: string;
      /** Parent Id */
      parent_id?: string | null;
      /**
       * Step Id
       * Format: uuid4
       */
      step_id: string;
      /** Metrics */
      metrics?: {
        [key: string]:
          | components['schemas']['MetricNotComputed']
          | components['schemas']['MetricPending']
          | components['schemas']['MetricComputing']
          | components['schemas']['MetricNotApplicable']
          | components['schemas']['MetricSuccess']
          | components['schemas']['MetricError']
          | components['schemas']['MetricFailed'];
      };
      /**
       * @description Type of the span. By default, it is set to workflow. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'workflow';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildSpans'] | null;
      /** Spans */
      spans?: (
        | components['schemas']['WorkflowSpanWithMetrics']
        | components['schemas']['LlmSpanWithMetrics']
        | components['schemas']['RetrieverSpanWithMetrics']
        | components['schemas']['ToolSpanWithMetrics']
      )[];
    };
    /** WorkflowStep */
    WorkflowStep: {
      /**
       * @description Type of the step. By default, it is set to workflow. (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      type: 'workflow';
      /**
       * Input
       * @description Input to the step.
       */
      input:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Output
       * @description Output of the step.
       * @default
       */
      output?:
        | string
        | components['schemas']['Document']
        | components['schemas']['Message']
        | Record<string, never>
        | string[]
        | components['schemas']['Document'][]
        | components['schemas']['Message'][]
        | {
            [key: string]: string;
          }[]
        | Record<string, never>[];
      /**
       * Name
       * @description Name of the step.
       * @default
       */
      name?: string;
      /**
       * Created At Ns
       * @description Timestamp of the step's creation, as nanoseconds since epoch.
       */
      created_at_ns?: number;
      /**
       * Duration Ns
       * @description Duration of the step in nanoseconds.
       * @default 0
       */
      duration_ns?: number;
      /**
       * Metadata
       * @description Metadata associated with this step.
       */
      metadata?: {
        [key: string]: string;
      };
      /**
       * Status Code
       * @description Status code of the step. Used for logging failed/errored steps.
       */
      status_code?: number | null;
      /**
       * Ground Truth
       * @description Ground truth expected output for the step.
       */
      ground_truth?: string | null;
      /**
       * Steps
       * @description Steps in the workflow.
       */
      steps?: (
        | components['schemas']['WorkflowStep']
        | components['schemas']['ChainStep']
        | components['schemas']['LlmStep']
        | components['schemas']['RetrieverStep']
        | components['schemas']['ToolStep']
        | components['schemas']['AgentStep']
      )[];
      /** @description Parent node of the current node. For internal use only. */
      parent?: components['schemas']['StepWithChildren'] | null;
    };
    /** WorkflowsIngestRequest */
    WorkflowsIngestRequest: {
      /**
       * Workflows
       * @description List of workflows to log.
       */
      workflows: (
        | components['schemas']['WorkflowStep']
        | components['schemas']['ChainStep']
        | components['schemas']['LlmStep']
        | components['schemas']['RetrieverStep']
        | components['schemas']['ToolStep']
        | components['schemas']['AgentStep']
      )[];
      /**
       * Project Id
       * @description Project ID for the Observe project.
       */
      project_id?: string | null;
      /**
       * Project Name
       * @description Project name for the Observe project.
       */
      project_name?: string | null;
    };
    /** WorkflowsIngestResponse */
    WorkflowsIngestResponse: {
      /** Message */
      message: string;
      /**
       * Project Id
       * Format: uuid4
       */
      project_id: string;
      /** Project Name */
      project_name: string;
      /** Workflows Count */
      workflows_count: number;
      /** Records Count */
      records_count: number;
    };
    /**
     * WorkflowsReadResponse
     * @description Response model for workflow evaluation results
     */
    WorkflowsReadResponse: {
      /**
       * Starting Token
       * @default 0
       */
      starting_token?: number;
      /**
       * Limit
       * @default 100
       */
      limit?: number;
      /**
       * Paginated
       * @default false
       */
      paginated?: boolean;
      /** Next Starting Token */
      next_starting_token?: number | null;
      /** Workflows */
      workflows: components['schemas']['BaseGalileoStep'][];
    };
    /** WriterIntegration */
    WriterIntegration: {
      /** Organization Id */
      organization_id: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      name: 'writer';
      /** Extra */
      extra?: Record<string, never> | null;
    };
    /** WriterIntegrationCreate */
    WriterIntegrationCreate: {
      /** Organization Id */
      organization_id: string;
      /** Token */
      token: string;
    };
    /** XRayCardDB */
    XRayCardDB: {
      xray_class: components['schemas']['XRayClass'];
      /** Message Fields */
      message_fields: Record<string, never>;
      logic?: components['schemas']['FilterParams'] | null;
      /** Score */
      score?: number | null;
      extra_filters?: components['schemas']['ExtraAlertFilters'] | null;
      /**
       * Id
       * Format: uuid4
       */
      id: string;
      /** Dismissed */
      dismissed: boolean;
      /**
       * Xray Classname
       * @default
       */
      xray_classname?: string;
      /**
       * Message
       * @default
       */
      message?: string;
      /** Suggestion */
      suggestion?: string | null;
      importance?: components['schemas']['AlertImportance'] | null;
      /** Alert Id */
      alert_id: number;
      /** Pct Samples */
      pct_samples?: number | null;
    };
    /**
     * XRayClass
     * @enum {integer}
     */
    XRayClass:
      | 0
      | 1
      | 2
      | 3
      | 4
      | 5
      | 6
      | 7
      | 8
      | 9
      | 10
      | 11
      | 12
      | 13
      | 14
      | 15
      | 16
      | 17
      | 18
      | 19
      | 20
      | 21
      | 22
      | 23
      | 24
      | 25
      | 26
      | 27
      | 28
      | 29
      | 30
      | 31
      | 32
      | 33
      | 34
      | 35
      | 36
      | 37
      | 38
      | 39
      | 40
      | 41
      | 42
      | 43
      | 44
      | 45
      | 46
      | 47
      | 48
      | 49
      | 50
      | 51
      | 52
      | 53;
    /** RecomputeSettingsObserve */
    api__schemas__metric_critique__RecomputeSettingsObserve: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      mode: 'observe_filters';
      /**
       * Filters
       * @description The parsed filters that are used to recompute the metric critique.
       */
      filters?: components['schemas']['QueryFilterV1'][];
    };
    /** RecomputeSettingsObserve */
    promptgalileo__schemas__metric_critique__RecomputeSettingsObserve: {
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      mode: 'observe_filters';
      /** Filters */
      filters: unknown[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  login_email_login_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['Body_login_email_login_post'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Token'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  login_api_key_login_api_key_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ApiKeyLoginRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Token'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  login_social_login_social_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SocialLoginRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Token'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  logout_logout_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Token'];
        };
      };
    };
  };
  current_user_current_user_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CurrentUserDB'];
        };
      };
    };
  };
  get_presigned_url_presigned_url_get: {
    parameters: {
      query: {
        api_url: string;
        method: components['schemas']['Method'];
        bucket_name: string;
        object_name: string;
        project_id: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPresignedUrlResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  verify_email_verify_email_post: {
    parameters: {
      query: {
        verification_token: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EmailVerificationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Token'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_token_token_get: {
    parameters: {
      query?: {
        organization_id?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTokenResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_current_changelog_changelog_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootModel_Sequence_WeeklyChangelog__'];
        };
      };
    };
  };
  healthcheck_healthcheck_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HealthcheckResponse'];
        };
      };
    };
  };
  validate_dataset_projects__project_id___training_or_inference__validate_dataset_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        training_or_inference: components['schemas']['DatasetType'];
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidationResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  start_training_job_projects__project_id___training_mode__start_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        training_mode: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': Record<string, never>;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  training_status_projects__project_id__training__training_job_id__status__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        training_job_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainJobStatusResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_token_for_training_job_training__training_job_id__token_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        training_job_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': Record<string, never>;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainJobAuthTokenResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_user_roles_user_roles_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserRoleInfo'][];
        };
      };
    };
  };
  request_access_request_access_post: {
    parameters: {
      query: {
        user_email: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  generate_signup_link_signup_link_post: {
    parameters: {
      query: {
        user_email: string;
        send_email?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateSignupLinkResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  invite_users_invite_users_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InviteUsersRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_users_users_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetUsersResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_verify_user_users_post: {
    parameters: {
      query?: {
        signup_token?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateUserResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_user_self_users_delete: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteUserResponse'];
        };
      };
    };
  };
  create_or_verify_user_social_users_social_post: {
    parameters: {
      query?: {
        signup_token?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SocialLoginRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateUserResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_all_users_users_all_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetUserResponse'][];
        };
      };
    };
  };
  get_user_users__user_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetUserResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_user_users__user_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateUserResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_user_users__user_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteUserResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_latest_user_run_users__user_id__runs_latest_get: {
    parameters: {
      query?: {
        project_type?: components['schemas']['ProjectType'];
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetUserLatestRunsDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_runs_for_user_users__user_id__runs_get: {
    parameters: {
      query?: {
        project_type?: components['schemas']['ProjectType'] | null;
      };
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  generate_password_reset_link_generate_password_reset_get: {
    parameters: {
      query: {
        user_email: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PasswordResetResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  generate_password_reset_email_generate_password_reset_email_get: {
    parameters: {
      query: {
        user_email: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PasswordResetEmailResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  password_reset_password_reset_post: {
    parameters: {
      query: {
        reset_token: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserPasswordResetRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserPasswordResetResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  transfer_user_data_users__user_id__transfer_post: {
    parameters: {
      query: {
        new_user_id: string;
      };
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransferUserResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_current_user_groups_current_user_groups_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupDB'][];
        };
      };
    };
  };
  get_api_keys_users__user_id__api_keys_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListApiKeyResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_api_key_users_api_keys_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateApiKeyRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateApiKeyResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_api_key_users_api_keys__api_key_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        api_key_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ApiKeyDeleteResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_prompt_datasets_projects__project_id__prompt_datasets_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListPromptDatasetResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  upload_prompt_evaluation_dataset_projects__project_id__prompt_datasets_post: {
    parameters: {
      query?: {
        format?: components['schemas']['DatasetFormat'];
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'multipart/form-data': components['schemas']['Body_upload_prompt_evaluation_dataset_projects__project_id__prompt_datasets_post'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PromptDatasetDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_datasets_datasets_get: {
    parameters: {
      query?: {
        /** @description Actions to include in the 'permissions' field. */
        actions?: components['schemas']['DatasetAction'][];
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDatasetResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  upload_dataset_datasets_post: {
    parameters: {
      query?: {
        format?: components['schemas']['DatasetFormat'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'multipart/form-data': components['schemas']['Body_upload_dataset_datasets_post'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_dataset_datasets__dataset_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_dataset_datasets__dataset_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_dataset_datasets__dataset_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDatasetRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_datasets_datasets_query_post: {
    parameters: {
      query?: {
        /** @description Actions to include in the 'permissions' field. */
        actions?: components['schemas']['DatasetAction'][];
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ListDatasetParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDatasetResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  download_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__put: {
    parameters: {
      query?: {
        file_name?: string | null;
        num_rows?: number | null;
        format?: components['schemas']['DatasetFormat'];
      };
      header?: never;
      path: {
        project_id: string;
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'multipart/form-data': components['schemas']['Body_update_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__put'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PromptDatasetDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_prompt_dataset_projects__project_id__prompt_datasets__dataset_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_dataset_content_datasets__dataset_id__content_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetContent'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  rollback_dataset_content_datasets__dataset_id__content_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RollbackRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_dataset_content_datasets__dataset_id__content_patch: {
    parameters: {
      query?: never;
      header?: {
        /**
         * @description ETag of the dataset as a version identifier.
         * @example d89cce33-549d-4b6d-b220-afb641d859c8
         */
        'If-Match'?: string | null;
      };
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDatasetContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  download_dataset_datasets__dataset_id__download_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_dataset_content_datasets__dataset_id__content_query_post: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['QueryDatasetParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetContent'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_user_dataset_collaborators_datasets__dataset_id__users_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListUserCollaboratorsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_user_dataset_collaborators_datasets__dataset_id__users_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserCollaboratorCreate'][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserCollaborator'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_group_dataset_collaborators_datasets__dataset_id__groups_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListGroupCollaboratorsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_group_dataset_collaborators_datasets__dataset_id__groups_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupCollaboratorCreate'][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupCollaborator'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_user_dataset_collaborator_datasets__dataset_id__users__user_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_user_dataset_collaborator_datasets__dataset_id__users__user_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
        user_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollaboratorUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserCollaborator'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_group_dataset_collaborator_datasets__dataset_id__groups__group_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
        group_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_group_dataset_collaborator_datasets__dataset_id__groups__group_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
        group_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollaboratorUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupCollaborator'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_dataset_versions_datasets__dataset_id__versions_query_post: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        dataset_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ListDatasetVersionParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDatasetVersionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_dataset_version_content_datasets__dataset_id__versions__version_index__content_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        dataset_id: string;
        version_index: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetContent'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_dataset_version_datasets__dataset_id__versions__version_index__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        dataset_id: string;
        version_index: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDatasetVersionRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatasetVersionDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_edits_projects__project_id__runs__run_id__split__split__edits_get: {
    parameters: {
      query?: {
        inference_name?: string | null;
        include_exported?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditGetResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_edit_projects__project_id__runs__run_id__split__split__edits_post: {
    parameters: {
      query?: {
        inference_name?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EditCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditCreateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_edits_exports_projects__project_id__runs__run_id__split__split__edits_exports_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditExportDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_edit_edits__edit_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        edit_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditGetResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_edit_edits__edit_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        edit_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditDeleteResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_edit_content_edits__edit_id__content_get: {
    parameters: {
      query?: {
        page_num?: number;
        meta_cols?: string[] | null;
        text_pat?: string | null;
        regex?: boolean | null;
      };
      header?: never;
      path: {
        edit_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditContent'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_edit_contents_for_run_projects__project_id__runs__run_id__split__split__edits_content_get: {
    parameters: {
      query?: {
        inference_name?: string | null;
        include_exported?: boolean;
        page_num?: number;
        meta_cols?: string[] | null;
        text_pat?: string | null;
        regex?: boolean | null;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditContent'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_edits_edits_export_post: {
    parameters: {
      query?: {
        ignore_conflicting_edits?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EditExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_edits_remote_edits_export_remote_post: {
    parameters: {
      query?: {
        ignore_conflicting_edits?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoteEditExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemoteEditExportResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_new_labels_for_run_edits_projects__project_id__runs__run_id__split__split__edits_labels_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  add_review_for_edit_edits__edit_id__review_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        edit_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EditReviewDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  has_embeddings_projects__project_id__runs__run_id__split__split__embeddings_available_get: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HasEmbeddingsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_embeddings_projects__project_id__runs__run_id__split__split__embeddings_post: {
    parameters: {
      query?: {
        inference_name?: string;
        data_view?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EmbeddingRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_point_embeddings_projects__project_id__runs__run_id__split__split__embeddings_point_post: {
    parameters: {
      query?: {
        inference_name?: string;
        data_view?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EmbeddingPointRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EmbeddingPointResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_evaluate_alerts_projects__project_id__runs__run_id__prompts_alerts_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        run_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EvaluateAlertDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_metric_insights_with_filters_projects__project_id__runs__run_id__prompts_insights_metrics_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['PromptFilterParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MetricInsight'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_workflows_run_evaluate_runs_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EvaluateRunRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EvaluateRunResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_evaluate_run_results_evaluate_run_workflows_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EvaluateRunResultsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowsReadResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_experiments_projects__project_id__experiments_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_experiment_projects__project_id__experiments_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExperimentCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_experiment_projects__project_id__experiments__experiment_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        experiment_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_experiment_projects__project_id__experiments__experiment_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        experiment_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExperimentUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_experiment_projects__project_id__experiments__experiment_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        experiment_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_data_projects__project_id__runs__run_id__split__split__export_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_data_remote_projects__project_id__runs__run_id__split__split__export_remote_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoteExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RemoteExportResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_feature_columns_projects__project_id__runs__run_id__features_columns_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeatureColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_feedback_templates_projects__project_id__feedback_templates_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackTemplateDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_feedback_template_projects__project_id__feedback_templates_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FeedbackTemplateCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackTemplateDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_feedback_template_projects__project_id__feedback_templates__template_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        template_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackTemplateDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_feedback_template_projects__project_id__feedback_templates__template_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        template_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_feedback_template_projects__project_id__feedback_templates__template_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        template_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FeedbackTemplateUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackTemplateDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_feedback_rating_projects__project_id__runs__run_id__feedback_templates__template_id__index__index__rating_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        index: number;
        template_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackRatingDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_feedback_rating_projects__project_id__runs__run_id__feedback_templates__template_id__index__index__rating_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        index: number;
        template_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FeedbackRatingCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackRatingDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_feedback_rating_projects__project_id__runs__run_id__feedback_templates__template_id__index__index__rating_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        template_id: string;
        index: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  apply_bulk_feedback_projects__project_id__runs__run_id__ratings_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkFeedbackRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkFeedbackRatingStatus'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_feedback_rating_observe_projects__project_id__feedback_templates__template_id__nodes__node_id__rating_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        node_id: string;
        template_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackRatingDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_feedback_rating_observe_projects__project_id__feedback_templates__template_id__nodes__node_id__rating_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        node_id: string;
        template_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FeedbackRatingCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FeedbackRatingDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_feedback_rating_observe_projects__project_id__feedback_templates__template_id__nodes__node_id__rating_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        node_id: string;
        template_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  generate_generated_scorers_generate_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenerationResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  validate_generated_scorers_validate_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GeneratedScorerValidationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GeneratedScorerValidationResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_all_generated_scorers_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListGeneratedScorersResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_generated_scorers_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateGeneratedScorerRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GeneratedScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_task_result_generated_scorers_task_results__task_result_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        task_result_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GeneratedScorerTaskResultResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_generated_scorers__generated_scorer_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        generated_scorer_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GeneratedScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_generated_scorers__generated_scorer_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        generated_scorer_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_generated_scorers__generated_scorer_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        generated_scorer_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateGeneratedScorerRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GeneratedScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_group_roles_group_roles_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupRoleInfo'][];
        };
      };
    };
  };
  list_groups_groups_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListGroupsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_group_groups_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_group_groups__group_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        group_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_group_groups__group_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        group_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_group_groups__group_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        group_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_group_members_groups__group_id__members_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        group_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListGroupMembersResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  add_user_to_group_groups__group_id__members_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        group_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupMemberCreate'][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupMemberDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_group_member_groups__group_id__members__user_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        user_id: string;
        group_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_group_member_groups__group_id__members__user_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        user_id: string;
        group_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupMemberUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupMemberDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_summary_statistics_projects__project_id__runs__run_id__split__split__insights_summary_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SummaryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RootModel_Union_InferenceRunResults__SplitRunResults__'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_groupby_statistics_projects__project_id__runs__run_id__split__split__insights_groupby_post: {
    parameters: {
      query: {
        groupby_col: string;
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupByMetrics'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_insight_ids_projects__project_id__runs__run_id__split__split__insights_ids_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SummaryIDRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SummaryIDResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_percentage_projects__project_id__runs__run_id__split__split__insights_percentage_sample_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['FilterPercentageRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FilterPercentageResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_thresholds_projects__project_id__runs__run_id__split__split__insights_thresholds_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ThresholdRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ThresholdResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  compare_runs_projects__project_id__split__split__insights_compare_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        split: components['schemas']['Split'];
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CompareRunsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_column_distribution_projects__project_id__runs__run_id__split__split__insights_distribution_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DistributionRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Distribution'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_model_metrics_projects__project_id__runs__run_id__split__split__insights_metrics_post: {
    parameters: {
      query?: {
        inference_name?: string;
        macro?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MetricsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MetricsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_task_metrics_projects__project_id__runs__run_id__split__split__insights_metrics_tasks_post: {
    parameters: {
      query?: {
        inference_name?: string;
        macro?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MetricsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MultiLabelTaskMetrics'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_label_co_occurrence_projects__project_id__runs__run_id__split__split__insights_co_occurrence_post: {
    parameters: {
      query?: {
        inference_name?: string;
        threshold?: number;
        top_n?: number;
        starting_label?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MetricsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MultiLabelCoOccurrence'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_similar_from_split_projects__project_id__runs__run_id__split__split__insights_similar_post: {
    parameters: {
      query: {
        from_split: components['schemas']['Split'];
        inference_name?: string;
        from_inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SimilarToResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_cbo_clusters_for_split_projects__project_id__runs__run_id__split__split__insights_cbo_clusters_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CBOClusterRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CBOClusterResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_cartograph_clusters_for_split_projects__project_id__runs__run_id__split__split__insights_cartograph_clusters_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        run_id: string;
        split: components['schemas']['Split'];
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CartographClusterResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_communities_for_split_projects__project_id__runs__run_id__split__split__insights_communities_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CommunityResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_top_insights_projects__project_id__runs__run_id__split__split__insights_top_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TopInsightsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TopInsightsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_correlation_matrix_chart_projects__project_id__runs__run_id__split__split__insights_charts_correlation_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InsightChartRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InsightChartResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_alerts_for_run_projects__project_id__runs__run_id__split__split__insights_alerts_get: {
    parameters: {
      query?: {
        inference_name?: string;
        include_dismissed?: boolean;
        map_threshold?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['XRayCardDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  dismiss_alert_projects__project_id__runs__run_id__split__split__insights_alerts__alert_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
        alert_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_errors_projects__project_id__runs__run_id__split__split__insights_errors_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_error_counts_projects__project_id__runs__run_id__split__split__insights_errors_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BarChart'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_map_for_run_projects__project_id__runs__run_id__split__split__insights_map_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MAPResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_segmentation_metrics_for_run_projects__project_id__runs__run_id__split__split__insights_semseg_metrics_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SegmentationMetricsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_seq2seq_metrics_for_run_projects__project_id__runs__run_id__split__split__insights_seq2seq_metrics_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Seq2SeqMetricsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_data_rows_projects__project_id__runs__run_id__split__split__insights_rows_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SummaryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DataRows'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_error_distribution_for_column_projects__project_id__runs__run_id__split__split__insights_errors__error_name__distribution_post: {
    parameters: {
      query?: {
        column_name?: string;
        inference_name?: string;
      };
      header?: never;
      path: {
        error_name: string;
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ContentRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorDistribution'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_integrations_integrations_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['IntegrationDB'][];
        };
      };
    };
  };
  list_available_integrations_integrations_available_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AvailableIntegrations'];
        };
      };
    };
  };
  get_integration_integrations__name__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        name: components['schemas']['IntegrationName'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['AwsBedrockIntegration']
            | components['schemas']['AwsSageMakerIntegration']
            | components['schemas']['AzureIntegration']
            | components['schemas']['DatabricksIntegration']
            | components['schemas']['LabelStudioIntegration']
            | components['schemas']['OpenAIIntegration']
            | components['schemas']['VertexAIIntegration']
            | components['schemas']['WriterIntegration']
            | components['schemas']['AnthropicIntegration']
            | components['schemas']['MistralIntegration'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_integration_integrations__name__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        name: components['schemas']['IntegrationName'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_integration_status_integrations__name__status_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        name: components['schemas']['IntegrationName'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            [key: string]: string;
          };
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_anthropic_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AnthropicIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_aws_bedrock_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BaseAwsIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_aws_sagemaker_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AwsSageMakerIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_azure_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AzureIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_unity_catalog_integration_integrations_databricks_unity_catalog_sql_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_unity_catalog_integration_integrations_databricks_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_databricks_catalogs_integrations_databricks_catalogs_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
    };
  };
  get_databases_for_cluster_integrations_databricks_databases_get: {
    parameters: {
      query?: {
        catalog?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_to_databricks_integrations_databricks_export_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatabricksExportResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_edits_databricks_integrations_databricks_edits_export_post: {
    parameters: {
      query?: {
        ignore_conflicting_edits?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksEditExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatabricksEditExportResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_to_databricks_unity_catalog_integrations_databricks_unity_catalog_export_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatabricksUnityCatalogExportResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_edits_databricks_unity_catalog_integrations_databricks_unity_catalog_edits_export_post: {
    parameters: {
      query?: {
        ignore_conflicting_edits?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksUnityCatalogEditExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DatabricksUnityCatalogExportEditsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_labelstudio_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LabelStudioIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_labelstudio_projects_integrations_labelstudio_projects_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LabelStudioProject'][];
        };
      };
    };
  };
  export_to_labelstudio_integrations_labelstudio_export_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LabelStudioExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_mistral_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MistralIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_openai_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OpenAIIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_vertex_ai_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VertexAIIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_integration_integrations_writer_put: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WriterIntegrationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_job_jobs_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateJobRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateJobResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_job_jobs__job_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        job_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JobDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_jobs_for_project_run_projects__project_id__runs__run_id__jobs_get: {
    parameters: {
      query?: {
        status?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JobDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_latest_job_for_project_run_projects__project_id__runs__run_id__jobs_latest_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['JobDB'] | null;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_available_models_llm_integrations__llm_integration__models_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        llm_integration: components['schemas']['LLMIntegration'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_available_scorer_models_llm_integrations__llm_integration__scorer_models_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        llm_integration: components['schemas']['LLMIntegration'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_log_streams_projects__project_id__log_streams_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_log_stream_projects__project_id__log_streams_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogStreamCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_log_stream_projects__project_id__log_streams__log_stream_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        log_stream_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_log_stream_projects__project_id__log_streams__log_stream_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        log_stream_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogStreamUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_log_stream_projects__project_id__log_streams__log_stream_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        log_stream_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_metadata_columns_projects__project_id__runs__run_id__split__split__meta_columns_post: {
    parameters: {
      query?: {
        inference_name?: string;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListMetaRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListMetaResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_metric_critiques_projects__project_id__metric_critiques_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateMetricCritiquesRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MetricCritique'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_metric_critique_projects__project_id__metric_critiques__critique_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        critique_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_projects__project_id__alerts_create_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAlertConfigurationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AlertConfigurationResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_projects__project_id__alerts__monitor_alert_config_id__update_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        monitor_alert_config_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAlertConfigurationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AlertConfigurationResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_alert_by_id_projects__project_id__alerts__monitor_alert_config_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        monitor_alert_config_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AlertConfigurationResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_alert_projects__project_id__alerts__monitor_alert_config_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        monitor_alert_config_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AlertStatusResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_alerts_by_project_projects__project_id__alerts_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListAlertConfigurationsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  log_workflows_observe_workflows_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkflowsIngestRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowsIngestResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_workflows_observe_projects__project_id__workflows_post: {
    parameters: {
      query?: {
        start_time?: string | null;
        end_time?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['GetObserveWorkflowsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowsReadResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  ingest_projects__project_id__observe_ingest_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TransactionRecordBatch'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_rows_projects__project_id__observe_rows_post: {
    parameters: {
      query?: {
        start_time?: string | null;
        end_time?: string | null;
        chain_id?: string | null;
        limit?: number;
        offset?: number;
        include_chains?: boolean;
        return_col_schema?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['TransactionRowsRequestBody'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransactionRecordsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_filter_options_projects__project_id__observe_filter_options_get: {
    parameters: {
      query?: {
        start_time?: string | null;
        end_time?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['FilterOptionsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_metric_critique_columns_projects__project_id__observe_metric_critique_columns_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MetricCritiqueColumns'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_rows_projects__project_id__observe_export_post: {
    parameters: {
      query?: {
        start_time?: string | null;
        end_time?: string | null;
        chain_id?: string | null;
        include_chains?: boolean;
        test_set?: boolean;
        export_format?: components['schemas']['LLMExportFormat'];
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['TransactionRowsRequestBody'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  export_rows_databricks_projects__project_id__observe_export_databricks_post: {
    parameters: {
      query?: {
        start_time?: string | null;
        end_time?: string | null;
        chain_id?: string | null;
        test_set?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DatabricksObserveExportRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_metrics_projects__project_id__observe_metrics_post: {
    parameters: {
      query: {
        start_time: string;
        end_time: string;
        interval?: number;
        group_by?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['FiltersRequestBody'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransactionMetricsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_rows_projects__project_id__observe_delete_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['TransactionRowsRequestBody'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TransactionRecordsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_workflow_count_projects__project_id__observe_workflows_count_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['FiltersRequestBody'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowCountResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_integrations_projects__project_id__observe_integrations_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectIntegrationsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_metrics_schema_endpoint_projects__project_id__observe_column_schema_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            [key: string]: string;
          };
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_user_metadata_endpoint_projects__project_id__observe_user_metadata_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_organization_organizations_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OrganizationCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['OrganizationDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_organizations_organizations_query_post: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['QueryOrganizationParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListOrganizationsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_project_settings_legacy_project_settings__project_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompositeProjectSettings'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectSettingsDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_settings_projects__project_id__settings_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GenAIProjectSettings'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_project_settings_projects__project_id__settings_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenAIProjectSettings'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectSettingsDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_scorers_config_projects__project_id__settings_scorers_config_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScorersConfig'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_scorers_config_project__project_id__settings_scorers_config_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScorersConfig'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_observe_settings_projects__project_id__settings_observe_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObserveProjectSettings'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_evaluate_settings_projects__project_id__settings_evaluate_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EvaluateProjectSettings'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_collaborator_roles_collaborator_roles_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CollaboratorRoleInfo'][];
        };
      };
    };
  };
  get_projects_projects_get: {
    parameters: {
      query?: {
        project_name?: string | null;
        type?: components['schemas']['ProjectType'] | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_project_projects_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ProjectCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectCreateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_projects_paginated_projects_paginated_post: {
    parameters: {
      query?: {
        /** @description Actions to include in the 'permissions' field. */
        actions?: components['schemas']['ProjectAction'][];
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ProjectCollectionParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetProjectsPaginatedResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_projects_count_projects_count_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ProjectCollectionParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': number;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_all_projects_projects_all_get: {
    parameters: {
      query?: {
        type?: components['schemas']['ProjectType'] | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectDBThin'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_projects__project_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_project_projects__project_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ProjectUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectUpdateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_project_projects__project_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectDeleteResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  upload_file_projects__project_id__upload_file_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'multipart/form-data': components['schemas']['Body_upload_file_projects__project_id__upload_file_post'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_user_project_collaborators_projects__project_id__users_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListUserCollaboratorsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_user_project_collaborators_projects__project_id__users_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UserCollaboratorCreate'][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserCollaborator'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_group_project_collaborators_projects__project_id__groups_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListGroupCollaboratorsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_group_project_collaborators_projects__project_id__groups_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GroupCollaboratorCreate'][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupCollaborator'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_user_project_collaborator_projects__project_id__users__user_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        user_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_user_project_collaborator_projects__project_id__users__user_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        user_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollaboratorUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserCollaborator'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_group_project_collaborator_projects__project_id__groups__group_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        group_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_group_project_collaborator_projects__project_id__groups__group_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        group_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollaboratorUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GroupCollaborator'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  ingest_prompt_chain_run_projects__project_id__runs__run_id__chains_ingest_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromptChainIngestRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PromptChainIngestResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  ingest_batch_projects__project_id__runs__run_id__chains_ingest_batch_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromptChainIngestBatchRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PromptChainIngestBatchResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_all_models_prompts_models_all_get: {
    parameters: {
      query?: {
        with_custom_models?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ModelInfo'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_rows_as_columns_with_filters_projects__project_id__runs__run_id__prompts_rows_columnar_post: {
    parameters: {
      query?: {
        sort_by?: string;
        sort_ascending?: boolean;
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['PromptFilterParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRowsColumnarResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_row_as_column_projects__project_id__runs__run_id__prompts_rows__row_id__columnar_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        row_id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRowsColumnarResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_multi_run_sample_ids_projects__project_id__runs_prompts_rows_columnar_get: {
    parameters: {
      query: {
        run_ids: string[];
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PromptSampleIDs'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_multi_run_samples_for_row_ids_projects__project_id__runs_prompts_rows_columnar_post: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: number;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            [
              key: string
            ]: components['schemas']['GetPromptRowsColumnarResponse'];
          };
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_chain_as_columns_projects__project_id__runs__run_id__prompts_rows_chains__chain_id__columnar_get: {
    parameters: {
      query?: {
        root?: boolean;
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        chain_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRowsColumnarResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_groups_prompts_rows_groups_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PromptGroupResponse'][];
        };
      };
    };
  };
  export_prompt_dataset_projects__project_id__runs__run_id__prompts_export_prompt_dataset_get: {
    parameters: {
      query?: {
        export_format?: components['schemas']['LLMExportFormat'];
        include_chains?: boolean;
        columns?: string[];
        inputs?: boolean;
        prompts?: boolean;
        responses?: boolean;
        metrics?: boolean;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_prompt_chain_rows_projects__project_id__runs__run_id__chains__chain_id__get: {
    parameters: {
      query?: {
        task_type?: components['schemas']['TaskType'];
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        chain_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRowsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_rows_projects__project_id__runs__run_id__prompts_rows_get: {
    parameters: {
      query?: {
        task_type?: components['schemas']['TaskType'];
        sort_by?: string;
        sort_ascending?: boolean;
        text_column?: string | null;
        text_pattern?: string | null;
        regex?: boolean;
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRowsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  submit_scorers_projects__project_id__scorers_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateComputeScoreRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  put_score_projects__project_id__runs__run_id__prompts_scorers__scorer_name__put: {
    parameters: {
      query?: {
        monitor_batch_id?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        scorer_name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PutPromptScoreRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PutPromptScoreResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_templates_projects__project_id__templates_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_prompt_template_with_version_projects__project_id__templates_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePromptTemplateWithVersionRequestBody'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_template_version_by_name_projects__project_id__templates_versions_get: {
    parameters: {
      query: {
        template_name: string;
        version?: number | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateVersionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_template_from_project_projects__project_id__templates__template_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        template_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_template_projects__project_id__templates__template_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        template_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeletePromptResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_prompt_template_version_projects__project_id__templates__template_id__versions_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        template_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BasePromptTemplateVersion'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateVersionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_template_version_projects__project_id__templates__template_id__versions__version__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        template_id: string;
        version: number;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateVersionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  set_selected_template_version_projects__project_id__templates__template_id__versions__version__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        template_id: string;
        version: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BasePromptTemplateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  invoke_protect_invoke_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Request'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['Response']
            | components['schemas']['InvokeResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_scorers_registered_scorers_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRegisteredScorersResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_or_update_registered_scorers_put: {
    parameters: {
      query: {
        name: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'multipart/form-data': components['schemas']['Body_create_or_update_registered_scorers_put'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateUpdateRegisteredScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_scorer_registered_scorers__registered_scorer_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        registered_scorer_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_settings_projects__project_id__runs__run_id__scorer_settings_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunScorerSettingsRequest'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  upsert_scorers_config_projects__project_id__runs__run_id__scorer_settings_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunScorerSettingsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunScorerSettingsRequest'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_runs_projects__project_id__runs_get: {
    parameters: {
      query?: {
        run_name?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_run_projects__project_id__runs_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateRunResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_runs_projects__project_id__runs_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteRunsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteRunsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_prompt_runs_projects__project_id__prompts_runs_get: {
    parameters: {
      query?: {
        sort_by?: string;
        sort_ascending?: boolean;
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRunsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_prompt_runs_as_columns_projects__project_id__prompts_runs_columnar_get: {
    parameters: {
      query?: {
        sort_by?: string;
        sort_ascending?: boolean;
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRunColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_prompt_runs_as_columns_with_filters_projects__project_id__prompts_runs_columnar_post: {
    parameters: {
      query?: {
        sort_by?: string;
        sort_ascending?: boolean;
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['PromptFilterParams'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRunColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_projects__project_id__runs__run_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_run_projects__project_id__runs__run_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateRunResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_run_projects__project_id__runs__run_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteRunResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_prompt_run_projects__project_id__prompts_runs__run_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRun'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_link_projects__project_id__runs__run_id__link_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunLinkResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_tasks_projects__project_id__runs__run_id__tasks_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TaskResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_labels_projects__project_id__runs__run_id__labels_get: {
    parameters: {
      query?: {
        task?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LabelResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_inference_names_projects__project_id__runs__run_id__inference_names_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InferenceNamesResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_num_epochs_for_run_projects__project_id__runs__run_id__split__split__epochs_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
        split: components['schemas']['Split'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': number[];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_splits_projects__project_id__runs__run_id__splits_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetSplitsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_metrics_for_run_projects__project_id__runs__run_id__metrics_get: {
    parameters: {
      query?: {
        key?: string | null;
      };
      header?: never;
      path: {
        run_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunMetricDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  set_metric_for_run_projects__project_id__runs__run_id__metrics_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunMetricCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunMetricDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_prompt_aggregate_metrics_as_singleton_columns_projects__project_id__runs__run_id__prompts_metrics_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        run_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetPromptRunColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_tags_projects__project_id__runs__run_id__tags_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunTagDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  set_tag_for_run_projects__project_id__runs__run_id__tags_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunTagCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunTagDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_run_tag_projects__project_id__runs__run_id__tags__tag_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        tag_id: string;
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunTagDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_tag_for_run_projects__project_id__runs__run_id__tags__tag_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        tag_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RunTagCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RunTagDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_run_tag_projects__project_id__runs__run_id__tags__tag_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        tag_id: string;
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteRunResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_scorers_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateScorerRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_scorer_scorers__scorer_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        scorer_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_scorers__scorer_id__patch: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        scorer_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateScorerRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScorerResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_llm_scorer_version_scorers__scorer_id__version_llm_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        scorer_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLLMScorerVersionRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BaseScorerVersionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_scorers_with_filters_scorers_list_post: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListScorersRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListScorersResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_tags_scorers_tags_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
    };
  };
  get_scorer_versions_scorers__scorer_id__versions_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        scorer_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ScorerVersionsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_project_slices_projects__project_id__slices_get: {
    parameters: {
      query?: {
        slice_name?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SliceDB'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_slice_projects__project_id__slices_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SliceCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SliceCreateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_slice_metrics_for_run_projects__project_id__runs__run_id__split__split__slices_get: {
    parameters: {
      query?: {
        inference_name?: string;
        task?: string | null;
      };
      header?: never;
      path: {
        run_id: string;
        split: components['schemas']['Split'];
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SliceMetrics'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_slice_projects__project_id__slices__slice_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slice_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SliceDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_slice_projects__project_id__slices__slice_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        slice_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SliceUpdate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SliceUpdateResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_slice_projects__project_id__slices__slice_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        slice_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SliceDeleteResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_stage_projects__project_id__stages_get: {
    parameters: {
      query?: {
        stage_name?: string | null;
        stage_id?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StageDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_stage_projects__project_id__stages_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StageWithRulesets'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StageDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  pause_stage_projects__project_id__stages__stage_id__put: {
    parameters: {
      query?: {
        pause?: boolean;
      };
      header?: never;
      path: {
        stage_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StageDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_stage_projects__project_id__stages__stage_id__post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        stage_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RulesetsMixin'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['StageDB'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  log_traces_projects__project_id__traces_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TracesIngestRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TracesIngestResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  traces_available_columns_projects__project_id__traces_available_columns_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataAvailableColumnsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataAvailableColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  spans_available_columns_projects__project_id__spans_available_columns_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataAvailableColumnsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataAvailableColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_traces_projects__project_id__traces_search_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataQueryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataQueryResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_spans_projects__project_id__spans_search_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataQueryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataQueryResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_trace_projects__project_id__traces__trace_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        trace_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TraceWithMetrics'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_span_projects__project_id__spans__span_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        span_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['WorkflowSpanWithMetrics']
            | components['schemas']['LlmSpanWithMetrics']
            | components['schemas']['RetrieverSpanWithMetrics']
            | components['schemas']['ToolSpanWithMetrics'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_model_endpoint_models__model_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        model_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainingModelResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_all_models_models_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainingModelResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_model_by_run_projects__project_id__runs__run_id__model_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        run_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainingModelResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  upload_model_projects__project_id__runs__run_id__model_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
        run_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadModel'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadModelResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_all_models_for_project_projects__project_id__models_all_get: {
    parameters: {
      query?: {
        starting_token?: number;
        limit?: number;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TrainingModelResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  bookmark_project_projects__project_id__bookmark_put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  unbookmark_project_projects__project_id__bookmark_delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_usage_plans_usage_plans_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            [key: string]: components['schemas']['UsagePlan'];
          };
        };
      };
    };
  };
  healthcheck_v1_healthcheck_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HealthcheckResponse'];
        };
      };
    };
  };
  get_token_v1_token_get: {
    parameters: {
      query?: {
        organization_id?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTokenResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_workflows_run_v1_evaluate_runs_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EvaluateRunRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EvaluateRunResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_evaluate_run_results_v1_evaluate_run_workflows_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EvaluateRunResultsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowsReadResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  log_workflows_v1_observe_workflows_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkflowsIngestRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowsIngestResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_workflows_v1_observe_projects__project_id__workflows_post: {
    parameters: {
      query?: {
        start_time?: string | null;
        end_time?: string | null;
      };
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['GetObserveWorkflowsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowsReadResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  invoke_v1_protect_invoke_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Request'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['Response']
            | components['schemas']['InvokeResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  healthcheck_v2_healthcheck_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HealthcheckResponse'];
        };
      };
    };
  };
  get_token_v2_token_get: {
    parameters: {
      query?: {
        organization_id?: string | null;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetTokenResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  log_traces_v2_projects__project_id__traces_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TracesIngestRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TracesIngestResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  traces_available_columns_v2_projects__project_id__traces_available_columns_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataAvailableColumnsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataAvailableColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  spans_available_columns_v2_projects__project_id__spans_available_columns_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataAvailableColumnsRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataAvailableColumnsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_traces_v2_projects__project_id__traces_search_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataQueryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataQueryResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  query_spans_v2_projects__project_id__spans_search_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogDataQueryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogDataQueryResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_trace_v2_projects__project_id__traces__trace_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        trace_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TraceWithMetrics'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_span_v2_projects__project_id__spans__span_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        span_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['WorkflowSpanWithMetrics']
            | components['schemas']['LlmSpanWithMetrics']
            | components['schemas']['RetrieverSpanWithMetrics']
            | components['schemas']['ToolSpanWithMetrics'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_log_streams_v2_projects__project_id__log_streams_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_log_stream_v2_projects__project_id__log_streams_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogStreamCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_log_stream_v2_projects__project_id__log_streams__log_stream_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        log_stream_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_log_stream_v2_projects__project_id__log_streams__log_stream_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        log_stream_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LogStreamUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LogStreamResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_log_stream_v2_projects__project_id__log_streams__log_stream_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        log_stream_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  list_experiments_v2_projects__project_id__experiments_get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'][];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_experiment_v2_projects__project_id__experiments_post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExperimentCreateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_experiment_v2_projects__project_id__experiments__experiment_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        experiment_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_experiment_v2_projects__project_id__experiments__experiment_id__put: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        experiment_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExperimentUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExperimentResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_experiment_v2_projects__project_id__experiments__experiment_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        experiment_id: string;
        project_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
}
