#!/usr/bin/env python3
"""
Patch the generated HTTPValidationError model so it accepts either a list
or a single string in the ``detail`` field.

Workflow
--------
1. Parse the target file into an AST.
2. Locate the ``for item in (_detail or [])`` loop inside
   ``HTTPValidationError.from_dict``.
3. Replace that loop with an ``if/else`` block:

       if isinstance(_detail, str):
           detail.append(ValidationError(loc=["api"], msg=_detail, type_="string"))
       else:
           for item in (_detail or []):
               ...

4. Write the file back only if the replacement succeeded; otherwise exit
   with status 2 so a CI job can flag the mismatch.

Run this script as a post-generation hook for *openapi-python-client*.

Exit codes
0 - patch applied
1 - I/O or syntax error
2 - target loop not found (template drift)
"""

from __future__ import annotations

import ast
import sys
from pathlib import Path


def _build_replacement_if_node(iter_node: ast.AST) -> ast.If:
    """Return the `if/else` AST that replaces the original loop."""
    return ast.If(
        test=ast.Call(
            func=ast.Name(id="isinstance", ctx=ast.Load()),
            args=[ast.Name(id="_detail", ctx=ast.Load()), ast.Name(id="str", ctx=ast.Load())],
            keywords=[],
        ),
        body=[
            ast.Expr(
                ast.Call(
                    func=ast.Attribute(ast.Name(id="detail", ctx=ast.Load()), attr="append", ctx=ast.Load()),
                    args=[
                        ast.Call(
                            func=ast.Name(id="ValidationError", ctx=ast.Load()),
                            args=[],
                            keywords=[
                                ast.keyword(
                                    arg="loc", value=ast.List(elts=[ast.Constant(value="api")], ctx=ast.Load())
                                ),
                                ast.keyword(arg="msg", value=ast.Name(id="_detail", ctx=ast.Load())),
                                ast.keyword(arg="type_", value=ast.Constant(value="string")),
                            ],
                        )
                    ],
                    keywords=[],
                )
            )
        ],
        orelse=[
            ast.For(
                target=ast.Name(id="item", ctx=ast.Store()),
                iter=iter_node,
                body=[
                    ast.Assign(
                        targets=[ast.Name(id="detail_item", ctx=ast.Store())],
                        value=ast.Call(
                            func=ast.Attribute(
                                ast.Name(id="ValidationError", ctx=ast.Load()), attr="from_dict", ctx=ast.Load()
                            ),
                            args=[ast.Name(id="item", ctx=ast.Load())],
                            keywords=[],
                        ),
                    ),
                    ast.Expr(
                        ast.Call(
                            func=ast.Attribute(ast.Name(id="detail", ctx=ast.Load()), attr="append", ctx=ast.Load()),
                            args=[ast.Name(id="detail_item", ctx=ast.Load())],
                            keywords=[],
                        )
                    ),
                ],
                orelse=[],
            )
        ],
    )


class HTTPValidationErrorPatcher(ast.NodeTransformer):
    """AST transformer for `HTTPValidationError.from_dict`."""

    def __init__(self) -> None:
        super().__init__()
        self.patch_applied: bool = False

    # Helpers

    @staticmethod
    def _target_loop(stmt: ast.For) -> bool:
        """Return True if loop matches the autogenerated pattern."""
        if not any(isinstance(n, ast.Name) and n.id == "_detail" for n in ast.walk(stmt.iter)):
            return False

        def _has(attr_target: str, attr_name: str) -> bool:
            return any(
                isinstance(n, ast.Attribute)
                and isinstance(n.value, ast.Name)
                and n.value.id == attr_target
                and n.attr == attr_name
                for n in ast.walk(stmt)
            )

        return _has("ValidationError", "from_dict") and _has("detail", "append")

    def _patch_method(self, fn: ast.FunctionDef) -> bool:
        new_body: list[ast.stmt] = []
        replaced = False
        for stmt in fn.body:
            if not replaced and isinstance(stmt, ast.For) and self._target_loop(stmt):
                if_node = _build_replacement_if_node(stmt.iter)
                ast.copy_location(if_node, stmt)
                new_body.append(if_node)
                replaced = True
            else:
                new_body.append(stmt)
        if replaced:
            fn.body = new_body
        return replaced

    # NodeTransformer

    def visit_ClassDef(self, node: ast.ClassDef) -> ast.AST:
        if self.patch_applied or node.name != "HTTPValidationError":
            return node
        for child in node.body:
            if isinstance(child, ast.FunctionDef) and child.name == "from_dict":
                if self._patch_method(child):
                    self.patch_applied = True
                    break
        return node


# Main


def main() -> int:
    if len(sys.argv) != 2:
        print(f"Usage: {Path(sys.argv[0]).name} <file_path>", file=sys.stderr)
        return 1

    target = Path(sys.argv[1])

    try:
        tree = ast.parse(target.read_text(encoding="utf-8"))
    except FileNotFoundError:
        print(f"{target} not found", file=sys.stderr)
        return 1
    except SyntaxError as e:
        print(f"Syntax error in {target}: {e}", file=sys.stderr)
        return 1

    patcher = HTTPValidationErrorPatcher()
    patcher.visit(tree)

    if not patcher.patch_applied:
        print(f"Target loop not found in {target} â€” template may have changed.", file=sys.stderr)
        return 2

    ast.fix_missing_locations(tree)
    target.write_text(ast.unparse(tree), encoding="utf-8")
    print(f"Patched {target}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
